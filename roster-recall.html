<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Player Recall - Mountainside Aces</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
:root {
  --primary-color: #2d5016;
  --secondary-color: #1a6b4a;
  --accent-color: #ffd700;
  --card-bg: #ffffff;
  --text-dark: #2d3748;
  --text-light: #718096;
  --border-color: #e2e8f0;
  --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
  --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
  
  /* Roster Recall theme - Red/Orange energy */
  --recall-primary: #dc2626;
  --recall-secondary: #ea580c;
  --recall-gradient: linear-gradient(135deg, #dc2626, #ea580c);
  --correct: #10b981;
  --timer-warning: #f59e0b;
  --timer-danger: #ef4444;
}

* { box-sizing: border-box; }

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  margin: 0;
  padding: 0;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  min-height: 100vh;
  color: var(--text-dark);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,255,255,0.95);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.5s ease, visibility 0.5s ease;
}

.loading-overlay.hidden {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

.softball-spinner::before {
  content: '‚öæ';
  font-size: 60px;
  animation: spin 1.5s ease-in-out infinite;
  display: block;
}

@keyframes spin {
  0%, 100% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.1); }
}

/* Page Container */
.page-container {
  max-width: 600px;
  margin: 0 auto;
  padding: 1rem;
}

/* Page Header */
.page-header {
  background: var(--recall-gradient);
  color: white;
  text-align: center;
  padding: 1.5rem 1rem;
  border-radius: 16px;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
}

.back-link {
  position: absolute;
  top: 1rem;
  left: 1rem;
  color: rgba(255,255,255,0.85);
  text-decoration: none;
  font-size: 0.85rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.35rem 0.75rem;
  background: rgba(255,255,255,0.15);
  border-radius: 6px;
  transition: all 0.2s ease;
  z-index: 10;
}

.back-link:hover {
  background: rgba(255,255,255,0.25);
  color: white;
}

.page-header::before {
  content: '';
  position: absolute;
  top: -100px;
  right: -100px;
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
  border-radius: 50%;
}

.page-header h1 {
  margin: 0 0 0.25rem 0;
  font-size: 1.75rem;
  font-weight: 700;
  position: relative;
  z-index: 1;
}

.page-header .subtitle {
  opacity: 0.9;
  font-size: 0.9rem;
  margin: 0;
  position: relative;
  z-index: 1;
}

.puzzle-date {
  font-size: 0.85rem;
  opacity: 0.85;
  margin-top: 0.5rem;
  position: relative;
  z-index: 1;
}

/* Timer Display */
.timer-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
  text-align: center;
}

.timer-display {
  font-size: 3.5rem;
  font-weight: 800;
  font-variant-numeric: tabular-nums;
  color: var(--text-dark);
  transition: color 0.3s ease;
}

.timer-display.warning {
  color: var(--timer-warning);
}

.timer-display.danger {
  color: var(--timer-danger);
  animation: pulse 0.5s ease infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.timer-label {
  font-size: 0.85rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-top: 0.25rem;
}

.timer-bar {
  width: 100%;
  height: 8px;
  background: var(--border-color);
  border-radius: 4px;
  margin-top: 1rem;
  overflow: hidden;
}

.timer-bar-fill {
  height: 100%;
  background: var(--recall-gradient);
  border-radius: 4px;
  transition: width 0.1s linear;
}

.timer-bar-fill.warning {
  background: var(--timer-warning);
}

.timer-bar-fill.danger {
  background: var(--timer-danger);
}

/* Category Display */
.category-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
  text-align: center;
}

.category-label {
  font-size: 0.8rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 0.5rem;
}

.category-name {
  font-size: 1.35rem;
  font-weight: 700;
  color: var(--recall-primary);
}

.found-count {
  margin-top: 0.75rem;
  font-size: 1.1rem;
  color: var(--text-dark);
}

.found-count span {
  font-weight: 700;
  color: var(--correct);
}

/* Input Section */
.input-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
}

.guess-input-container {
  position: relative;
}

.guess-input {
  width: 100%;
  padding: 1rem;
  font-size: 1.1rem;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  outline: none;
  transition: border-color 0.2s;
}

.guess-input:focus {
  border-color: var(--recall-primary);
}

.guess-input:disabled {
  background: #f7fafc;
  cursor: not-allowed;
}

/* Autocomplete Dropdown */
.autocomplete-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: white;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  margin-top: 4px;
  max-height: 200px;
  overflow-y: auto;
  z-index: 100;
  box-shadow: var(--shadow-md);
  display: none;
}

.autocomplete-dropdown.active {
  display: block;
}

.autocomplete-item {
  padding: 0.75rem 1rem;
  cursor: pointer;
  transition: background 0.15s;
  border-bottom: 1px solid var(--border-color);
}

.autocomplete-item:last-child {
  border-bottom: none;
}

.autocomplete-item:hover {
  background: #f7fafc;
}

.autocomplete-item.selected {
  background: rgba(220, 38, 38, 0.1);
}

.autocomplete-item.already-guessed {
  opacity: 0.4;
  text-decoration: line-through;
}

/* Feedback Messages */
.feedback {
  text-align: center;
  margin-top: 0.75rem;
  font-weight: 600;
  min-height: 24px;
}

.feedback.correct {
  color: var(--correct);
  animation: popIn 0.3s ease;
}

.feedback.wrong {
  color: var(--timer-danger);
  animation: shake 0.3s ease;
}

@keyframes popIn {
  0% { transform: scale(0.8); opacity: 0; }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

/* Found Players List */
.found-list-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
}

.found-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.found-list-title {
  font-weight: 600;
  color: var(--text-dark);
}

.found-list-toggle {
  background: none;
  border: none;
  color: var(--text-light);
  cursor: pointer;
  font-size: 0.85rem;
}

.found-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.found-list.collapsed {
  display: none;
}

.found-player {
  background: linear-gradient(135deg, #d1fae5, #a7f3d0);
  color: #065f46;
  padding: 0.35rem 0.75rem;
  border-radius: 20px;
  font-size: 0.85rem;
  font-weight: 500;
  animation: popIn 0.3s ease;
}

/* Pre-game State */
.pre-game {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 2rem;
  text-align: center;
  box-shadow: var(--shadow-md);
}

.pre-game h2 {
  margin: 0 0 0.5rem 0;
  color: var(--text-dark);
}

.pre-game p {
  color: var(--text-light);
  margin: 0 0 1.5rem 0;
}

.start-btn {
  padding: 1rem 2.5rem;
  font-size: 1.25rem;
  font-weight: 700;
  background: var(--recall-gradient);
  color: white;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.start-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(220, 38, 38, 0.4);
}

/* Results Section */
.results-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.5rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
  text-align: center;
}

.results-title {
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: 0.5rem;
}

.results-subtitle {
  color: var(--text-light);
  margin-bottom: 1rem;
}

.score-breakdown {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
  margin: 1.5rem 0;
}

.score-item {
  background: #f7fafc;
  padding: 1rem;
  border-radius: 12px;
}

.score-value {
  font-size: 1.75rem;
  font-weight: 700;
  color: var(--recall-primary);
}

.score-label {
  font-size: 0.75rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.total-score {
  background: var(--recall-gradient);
  color: white;
  padding: 1.25rem;
  border-radius: 12px;
  margin-top: 1rem;
}

.total-score .score-value {
  color: white;
  font-size: 2.5rem;
}

.total-score .score-label {
  color: rgba(255,255,255,0.85);
}

/* Missed Players */
.missed-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
}

.missed-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
  cursor: pointer;
}

.missed-title {
  font-weight: 600;
  color: var(--text-dark);
}

.missed-toggle {
  color: var(--text-light);
  font-size: 0.9rem;
}

.missed-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.missed-list.collapsed {
  display: none;
}

.missed-player {
  background: #fee2e2;
  color: #991b1b;
  padding: 0.35rem 0.75rem;
  border-radius: 20px;
  font-size: 0.85rem;
  font-weight: 500;
}

/* Action Buttons */
.action-buttons {
  display: flex;
  justify-content: center;
  gap: 0.75rem;
  margin-top: 1rem;
  flex-wrap: wrap;
}

.action-btn {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.action-btn.primary {
  background: var(--recall-gradient);
  color: white;
}

.action-btn.primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
}

.action-btn.secondary {
  background: var(--card-bg);
  color: var(--text-dark);
  border: 2px solid var(--border-color);
}

.action-btn.secondary:hover {
  border-color: var(--recall-primary);
  color: var(--recall-primary);
}

/* User Stats Section */
.user-stats-container {
  background: var(--card-bg);
  border-radius: 12px;
  padding: 0.75rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-sm);
}

.user-stats-content {
  text-align: center;
}

.sign-in-prompt {
  color: var(--text-light);
  font-size: 0.85rem;
}

.sign-in-prompt a {
  color: var(--recall-primary);
  font-weight: 600;
  text-decoration: none;
}

.user-greeting {
  font-weight: 600;
  color: var(--text-dark);
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
}

.lifetime-stats {
  display: flex;
  justify-content: center;
  gap: 1.25rem;
  flex-wrap: wrap;
}

.lifetime-stat {
  text-align: center;
}

.lifetime-value {
  font-size: 1.1rem;
  font-weight: 700;
  color: var(--recall-primary);
  display: block;
}

.lifetime-label {
  font-size: 0.65rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* How to Play */
.how-to-play {
  background: var(--card-bg);
  border-radius: 12px;
  padding: 1rem;
  margin-top: 1rem;
  box-shadow: var(--shadow-sm);
}

.how-to-play h3 {
  margin: 0 0 0.75rem 0;
  font-size: 1rem;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.how-to-play-content {
  display: none;
  font-size: 0.85rem;
  color: var(--text-light);
  line-height: 1.6;
}

.how-to-play.expanded .how-to-play-content {
  display: block;
}

/* Stats Modal */
.modal-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
  padding: 1rem;
}

.modal-overlay.active {
  opacity: 1;
  visibility: visible;
}

.modal-content {
  background: white;
  border-radius: 16px;
  padding: 1.5rem;
  max-width: 400px;
  width: 100%;
  box-shadow: var(--shadow-lg);
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  text-align: center;
  margin-bottom: 1rem;
}

.modal-header h2 {
  margin: 0;
  font-size: 1.5rem;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.75rem;
  margin: 1rem 0;
}

.stat-box {
  background: #f7fafc;
  padding: 0.75rem;
  border-radius: 8px;
  text-align: center;
}

.stat-number {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-dark);
}

.stat-label {
  font-size: 0.65rem;
  color: var(--text-light);
  text-transform: uppercase;
}

.share-btn {
  width: 100%;
  padding: 0.75rem 1.5rem;
  background: var(--recall-gradient);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  margin-top: 1rem;
}

/* Toast */
.toast {
  position: fixed;
  top: 10%;
  left: 50%;
  transform: translateX(-50%);
  background: var(--text-dark);
  color: white;
  padding: 0.75rem 1.25rem;
  border-radius: 8px;
  font-weight: 600;
  z-index: 2000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
}

.toast.show {
  opacity: 1;
  visibility: visible;
}

/* Mobile Adjustments */
@media (max-width: 480px) {
  .timer-display {
    font-size: 2.75rem;
  }
  
  .score-breakdown {
    grid-template-columns: 1fr 1fr;
  }
  
  .stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}
</style>
</head>
<body>

<div class="loading-overlay" id="loadingOverlay">
  <div class="softball-spinner"></div>
</div>

<!-- Navigation placeholder -->
<nav id="main-nav"></nav>

<div class="page-container">
  <div class="page-header">
    <a href="games.html" class="back-link">‚Üê Games</a>
    <h1>‚è±Ô∏è Player Recall</h1>
    <p class="subtitle">Name everyone in the category before time runs out!</p>
    <div class="puzzle-date" id="puzzleDate">Puzzle #1</div>
  </div>

  <!-- User Stats Section -->
  <div class="user-stats-container" id="userStatsContainer">
    <div class="user-stats-content">
      <div class="sign-in-prompt">
        <span>üîí</span>
        <a href="signin.html">Sign in</a> to track your stats across devices
      </div>
    </div>
  </div>

  <!-- Game Content (dynamically rendered) -->
  <div id="gameContent"></div>

  <!-- How to Play -->
  <div class="how-to-play" id="howToPlay">
    <h3 onclick="toggleHowToPlay()">üìñ How to Play <span id="howToPlayToggle">‚ñº</span></h3>
    <div class="how-to-play-content">
      <p>Name all players in the category before time runs out!</p>
      
      <p><strong>How it works:</strong></p>
      <ul>
        <li>Each puzzle has a category (team roster, stat threshold, etc.)</li>
        <li>Type player names as fast as you can</li>
        <li>Timer scales with group size (60s base + 3s per player)</li>
        <li>You won't know how many players are in the group!</li>
      </ul>
      
      <p><strong>Scoring:</strong></p>
      <ul>
        <li><strong>Base:</strong> 1 point per % of group found</li>
        <li><strong>Completion bonus:</strong> +25 points for 100%</li>
        <li><strong>Speed bonus:</strong> +1 point per 5 seconds remaining (if 100%)</li>
      </ul>
      
      <p style="margin-top: 1rem;">A new puzzle is available each day at midnight!</p>
    </div>
  </div>
</div>

<!-- Stats Modal -->
<div class="modal-overlay" id="statsModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>üìä Statistics</h2>
    </div>
    
    <div class="stats-grid">
      <div class="stat-box">
        <div class="stat-number" id="statPlayed">0</div>
        <div class="stat-label">Played</div>
      </div>
      <div class="stat-box">
        <div class="stat-number" id="statPerfect">0</div>
        <div class="stat-label">Perfect</div>
      </div>
      <div class="stat-box">
        <div class="stat-number" id="statAvgScore">0</div>
        <div class="stat-label">Avg Score</div>
      </div>
      <div class="stat-box">
        <div class="stat-number" id="statBestScore">0</div>
        <div class="stat-label">Best Score</div>
      </div>
    </div>
    
    <button class="share-btn" onclick="shareResults()">üì§ Share Results</button>
    
    <div class="action-buttons" style="margin-top: 1rem;">
      <button class="action-btn secondary" onclick="closeStatsModal()">Close</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script type="module">
import { 
  db, 
  doc,
  getDoc
} from './firebase-config.js';

import {
  setDoc,
  serverTimestamp
} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

import { getAllPlayerStatsOptimized } from './firebase-data.js';

import {
  getCurrentUser,
  onAuthChange
} from './firebase-auth.js';

// ============================================
// VERSION CHECK - Increment to clear old localStorage data
// ============================================
const DATA_VERSION = 2;
const VERSION_KEY = 'acesRosterRecall_dataVersion';

(function checkDataVersion() {
  const storedVersion = localStorage.getItem(VERSION_KEY);
  if (!storedVersion || parseInt(storedVersion) < DATA_VERSION) {
    console.log('üîÑ Clearing old Roster Recall data (version update)');
    localStorage.removeItem('acesRosterRecall_game');
    localStorage.removeItem('acesRosterRecall_stats');
    localStorage.setItem(VERSION_KEY, String(DATA_VERSION));
  }
})();

// ============================================
// CONFIGURATION
// ============================================
const LAUNCH_YEAR = 2026;
const LAUNCH_MONTH = 0;
const LAUNCH_DAY = 6;
const BASE_TIME = 60; // 60 seconds base
const TIME_PER_PLAYER = 3; // +3 seconds per player

// ============================================
// SUBSTITUTE SEASON HELPER
// ============================================
function isSubstituteSeason(season) {
  return season.sub === 'Yes' || season.sub === 'yes' || season.sub === true;
}

function getNonSubSeasons(player) {
  if (!player.seasons) return [];
  return Object.entries(player.seasons)
    .filter(([, s]) => !isSubstituteSeason(s))
    .map(([id, s]) => ({ seasonId: id, ...s }));
}

// ============================================
// AUTH STATE
// ============================================
let currentUser = null;

// ============================================
// GAME STATE
// ============================================
let allPlayers = [];
let playerNames = [];
let todaysPuzzle = null;
let gameState = {
  phase: 'pre', // 'pre', 'playing', 'finished'
  foundPlayers: [],
  timeRemaining: 0,
  totalTime: 0,
  startTime: null,
  endTime: null,
  score: 0
};
let timerInterval = null;

// ============================================
// SEEDED RANDOM
// ============================================
function seededRandom(seed) {
  const x = Math.sin(seed) * 10000;
  return x - Math.floor(x);
}

function getDayNumber() {
  const start = new Date(LAUNCH_YEAR, LAUNCH_MONTH, LAUNCH_DAY).setHours(0, 0, 0, 0);
  const now = new Date().setHours(0, 0, 0, 0);
  const daysSinceLaunch = Math.floor((now - start) / (1000 * 60 * 60 * 24));
  return Math.max(1, daysSinceLaunch + 1);
}

function shuffleWithSeed(array, seed) {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    seed++;
    const j = Math.floor(seededRandom(seed) * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

// ============================================
// CATEGORY GENERATORS
// ============================================
function getTeamRoster(team, seasonId) {
  const players = [];
  allPlayers.forEach(p => {
    const seasons = getNonSubSeasons(p);
    const match = seasons.find(s => s.seasonId === seasonId && s.team?.toLowerCase() === team.toLowerCase());
    if (match) {
      players.push(p.name || p.playerName);
    }
  });
  return [...new Set(players)];
}

function getCareerStatPlayers(stat, threshold, label) {
  const players = [];
  allPlayers.forEach(p => {
    const seasons = getNonSubSeasons(p);
    if (seasons.length === 0) return;
    
    let value = 0;
    if (stat === 'hits') value = p.career?.hits || p.careerHits || 0;
    else if (stat === 'runs') value = p.career?.runs || p.careerRuns || 0;
    else if (stat === 'walks') value = p.career?.walks || p.careerWalks || 0;
    else if (stat === 'games') value = p.career?.games || p.careerGames || 0;
    
    if (value >= threshold) {
      players.push(p.name || p.playerName);
    }
  });
  return [...new Set(players)];
}

function getSeasonStatPlayers(stat, threshold) {
  const players = [];
  allPlayers.forEach(p => {
    const seasons = getNonSubSeasons(p);
    const qualifies = seasons.some(s => {
      let value = 0;
      if (stat === 'hits') value = s.hits || 0;
      else if (stat === 'runs') value = s.runs || 0;
      else if (stat === 'walks') value = s.walks || 0;
      else if (stat === 'games') value = s.games || 0;
      return value >= threshold;
    });
    if (qualifies) {
      players.push(p.name || p.playerName);
    }
  });
  return [...new Set(players)];
}

function getMultiTeamPlayers(count) {
  const players = [];
  allPlayers.forEach(p => {
    const seasons = getNonSubSeasons(p);
    const teams = new Set(seasons.map(s => s.team?.toLowerCase()).filter(Boolean));
    if (teams.size >= count) {
      players.push(p.name || p.playerName);
    }
  });
  return [...new Set(players)];
}

function getVeteranPlayers(seasonCount) {
  const players = [];
  allPlayers.forEach(p => {
    const seasons = getNonSubSeasons(p);
    if (seasons.length >= seasonCount) {
      players.push(p.name || p.playerName);
    }
  });
  return [...new Set(players)];
}

// ============================================
// PUZZLE GENERATION
// ============================================
function generateCategoryPool() {
  const categories = [];
  
  // Get available season IDs
  const seasonIds = new Set();
  allPlayers.forEach(p => {
    getNonSubSeasons(p).forEach(s => seasonIds.add(s.seasonId));
  });
  const sortedSeasons = [...seasonIds].sort().reverse();
  
  // Team rosters (recent seasons)
  const teams = ['Black', 'Blue', 'Green', 'Red', 'Orange', 'Purple', 'Gold', 'Silver', 'White', 'Carolina'];
  sortedSeasons.slice(0, 6).forEach(seasonId => {
    teams.forEach(team => {
      const roster = getTeamRoster(team, seasonId);
      if (roster.length >= 6 && roster.length <= 20) {
        const [year, szn] = seasonId.split('-');
        categories.push({
          name: `${year} ${szn.charAt(0).toUpperCase() + szn.slice(1)} ${team} Roster`,
          players: roster,
          type: 'roster'
        });
      }
    });
  });
  
  // Career stat thresholds
  [
    { stat: 'hits', threshold: 100, label: '100+ Career Hits' },
    { stat: 'hits', threshold: 75, label: '75+ Career Hits' },
    { stat: 'hits', threshold: 50, label: '50+ Career Hits' },
    { stat: 'runs', threshold: 50, label: '50+ Career Runs' },
    { stat: 'runs', threshold: 30, label: '30+ Career Runs' },
    { stat: 'walks', threshold: 30, label: '30+ Career Walks' },
    { stat: 'games', threshold: 50, label: '50+ Career Games' },
    { stat: 'games', threshold: 75, label: '75+ Career Games' },
  ].forEach(c => {
    const players = getCareerStatPlayers(c.stat, c.threshold);
    if (players.length >= 5 && players.length <= 25) {
      categories.push({
        name: c.label,
        players,
        type: 'career'
      });
    }
  });
  
  // Season stat thresholds
  [
    { stat: 'hits', threshold: 20, label: '20+ Hits in a Season' },
    { stat: 'hits', threshold: 25, label: '25+ Hits in a Season' },
    { stat: 'runs', threshold: 15, label: '15+ Runs in a Season' },
    { stat: 'runs', threshold: 20, label: '20+ Runs in a Season' },
    { stat: 'walks', threshold: 10, label: '10+ Walks in a Season' },
  ].forEach(c => {
    const players = getSeasonStatPlayers(c.stat, c.threshold);
    if (players.length >= 5 && players.length <= 25) {
      categories.push({
        name: c.label,
        players,
        type: 'season'
      });
    }
  });
  
  // Multi-team players
  [3, 4].forEach(count => {
    const players = getMultiTeamPlayers(count);
    if (players.length >= 5 && players.length <= 20) {
      categories.push({
        name: `Played for ${count}+ Teams`,
        players,
        type: 'multi'
      });
    }
  });
  
  // Veteran players
  [5, 6, 7].forEach(count => {
    const players = getVeteranPlayers(count);
    if (players.length >= 5 && players.length <= 20) {
      categories.push({
        name: `${count}+ Seasons Played`,
        players,
        type: 'veteran'
      });
    }
  });
  
  return categories;
}

function generateDailyPuzzle() {
  const dayNum = getDayNumber();
  const seed = dayNum * 13583;
  
  const categories = generateCategoryPool();
  const shuffled = shuffleWithSeed(categories, seed);
  const category = shuffled[0];
  
  const totalTime = BASE_TIME + (category.players.length * TIME_PER_PLAYER);
  
  return {
    dayNum,
    categoryName: category.name,
    players: category.players,
    totalTime
  };
}

// ============================================
// UI RENDERING
// ============================================
function renderPreGame() {
  const content = document.getElementById('gameContent');
  content.innerHTML = `
    <div class="pre-game">
      <h2>üéØ Today's Challenge</h2>
      <div class="category-name" style="margin: 1rem 0; font-size: 1.5rem; color: var(--recall-primary);">
        ${todaysPuzzle.categoryName}
      </div>
      <p>Name all the players in this category!</p>
      <button class="start-btn" onclick="startGame()">‚ñ∂Ô∏è Start</button>
    </div>
  `;
}

function renderPlaying() {
  const content = document.getElementById('gameContent');
  content.innerHTML = `
    <!-- Timer -->
    <div class="timer-container">
      <div class="timer-display" id="timerDisplay">${formatTime(gameState.timeRemaining)}</div>
      <div class="timer-label">Time Remaining</div>
      <div class="timer-bar">
        <div class="timer-bar-fill" id="timerBar" style="width: 100%"></div>
      </div>
    </div>
    
    <!-- Category -->
    <div class="category-container">
      <div class="category-label">Category</div>
      <div class="category-name">${todaysPuzzle.categoryName}</div>
      <div class="found-count"><span id="foundCount">${gameState.foundPlayers.length}</span> found</div>
    </div>
    
    <!-- Input -->
    <div class="input-container">
      <div class="guess-input-container">
        <input type="text" class="guess-input" id="guessInput" placeholder="Type a player's name..." autocomplete="off">
        <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
      </div>
      <div class="feedback" id="feedback"></div>
    </div>
    
    <!-- Found List -->
    <div class="found-list-container">
      <div class="found-list-header">
        <span class="found-list-title">‚úì Found Players</span>
        <button class="found-list-toggle" onclick="toggleFoundList()">Hide</button>
      </div>
      <div class="found-list" id="foundList"></div>
    </div>
  `;
  
  setupAutocomplete();
  document.getElementById('guessInput').focus();
  updateFoundList();
}

function renderFinished() {
  const found = gameState.foundPlayers.length;
  const total = todaysPuzzle.players.length;
  const percentage = Math.round((found / total) * 100);
  const isPerfect = found === total;
  const timeLeft = gameState.timeRemaining;
  
  // Calculate score
  const baseScore = percentage; // 1 point per %
  const completionBonus = isPerfect ? 25 : 0;
  const speedBonus = isPerfect ? Math.floor(timeLeft / 5) : 0;
  const totalScore = baseScore + completionBonus + speedBonus;
  
  gameState.score = totalScore;
  
  const missed = todaysPuzzle.players.filter(p => !gameState.foundPlayers.includes(p));
  
  const content = document.getElementById('gameContent');
  content.innerHTML = `
    <!-- Results -->
    <div class="results-container">
      <div class="results-title">${isPerfect ? 'üéâ Perfect!' : '‚è±Ô∏è Time\'s Up!'}</div>
      <div class="results-subtitle">${todaysPuzzle.categoryName}</div>
      
      <div class="score-breakdown">
        <div class="score-item">
          <div class="score-value">${found}/${total}</div>
          <div class="score-label">Found</div>
        </div>
        <div class="score-item">
          <div class="score-value">${percentage}%</div>
          <div class="score-label">Complete</div>
        </div>
        <div class="score-item">
          <div class="score-value">${baseScore}</div>
          <div class="score-label">Base Pts</div>
        </div>
        <div class="score-item">
          <div class="score-value">+${completionBonus + speedBonus}</div>
          <div class="score-label">Bonus</div>
        </div>
      </div>
      
      <div class="total-score">
        <div class="score-value">${totalScore}</div>
        <div class="score-label">Total Score</div>
      </div>
    </div>
    
    <!-- Found Players -->
    <div class="found-list-container">
      <div class="found-list-header">
        <span class="found-list-title">‚úì Found (${found})</span>
      </div>
      <div class="found-list" id="foundList">
        ${gameState.foundPlayers.map(p => `<span class="found-player">${p}</span>`).join('')}
      </div>
    </div>
    
    <!-- Missed Players -->
    ${missed.length > 0 ? `
    <div class="missed-container">
      <div class="missed-header" onclick="toggleMissedList()">
        <span class="missed-title">‚úó Missed (${missed.length})</span>
        <span class="missed-toggle" id="missedToggle">‚ñº</span>
      </div>
      <div class="missed-list collapsed" id="missedList">
        ${missed.map(p => `<span class="missed-player">${p}</span>`).join('')}
      </div>
    </div>
    ` : ''}
    
    <!-- Action Buttons -->
    <div class="action-buttons">
      <button class="action-btn primary" onclick="showStats()">üìä Stats</button>
      <button class="action-btn secondary" onclick="shareResults()">üì§ Share</button>
    </div>
  `;
  
  updateLifetimeStats();
  saveGameState();
}

function updateFoundList() {
  const list = document.getElementById('foundList');
  if (!list) return;
  
  list.innerHTML = gameState.foundPlayers
    .map(p => `<span class="found-player">${p}</span>`)
    .join('');
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// ============================================
// GAME LOGIC
// ============================================
window.startGame = function() {
  gameState.phase = 'playing';
  gameState.timeRemaining = todaysPuzzle.totalTime;
  gameState.totalTime = todaysPuzzle.totalTime;
  gameState.startTime = Date.now();
  gameState.foundPlayers = [];
  
  renderPlaying();
  startTimer();
  saveGameState();
};

function startTimer() {
  timerInterval = setInterval(() => {
    gameState.timeRemaining--;
    
    const display = document.getElementById('timerDisplay');
    const bar = document.getElementById('timerBar');
    
    if (display) {
      display.textContent = formatTime(gameState.timeRemaining);
      
      // Color changes
      const pct = gameState.timeRemaining / gameState.totalTime;
      display.classList.remove('warning', 'danger');
      bar.classList.remove('warning', 'danger');
      
      if (pct <= 0.15) {
        display.classList.add('danger');
        bar.classList.add('danger');
      } else if (pct <= 0.33) {
        display.classList.add('warning');
        bar.classList.add('warning');
      }
      
      bar.style.width = `${pct * 100}%`;
    }
    
    if (gameState.timeRemaining <= 0) {
      endGame();
    }
  }, 1000);
}

function endGame() {
  clearInterval(timerInterval);
  gameState.phase = 'finished';
  gameState.endTime = Date.now();
  renderFinished();
}

function checkGuess(guess) {
  const normalized = guess.trim().toLowerCase();
  
  // Find matching player
  const match = todaysPuzzle.players.find(p => 
    p.toLowerCase() === normalized ||
    p.toLowerCase().includes(normalized) ||
    normalized.includes(p.toLowerCase())
  );
  
  if (match && !gameState.foundPlayers.includes(match)) {
    gameState.foundPlayers.push(match);
    
    document.getElementById('foundCount').textContent = gameState.foundPlayers.length;
    updateFoundList();
    
    const feedback = document.getElementById('feedback');
    feedback.className = 'feedback correct';
    feedback.textContent = `‚úì ${match}`;
    
    setTimeout(() => {
      feedback.textContent = '';
      feedback.className = 'feedback';
    }, 1000);
    
    // Check for completion
    if (gameState.foundPlayers.length === todaysPuzzle.players.length) {
      setTimeout(() => endGame(), 500);
    }
    
    saveGameState();
    return true;
  } else if (match && gameState.foundPlayers.includes(match)) {
    const feedback = document.getElementById('feedback');
    feedback.className = 'feedback wrong';
    feedback.textContent = `Already found: ${match}`;
    setTimeout(() => {
      feedback.textContent = '';
      feedback.className = 'feedback';
    }, 1000);
    return false;
  } else {
    const feedback = document.getElementById('feedback');
    feedback.className = 'feedback wrong';
    feedback.textContent = `‚úó Not in category`;
    setTimeout(() => {
      feedback.textContent = '';
      feedback.className = 'feedback';
    }, 1000);
    return false;
  }
}

// ============================================
// AUTOCOMPLETE
// ============================================
function setupAutocomplete() {
  const input = document.getElementById('guessInput');
  const dropdown = document.getElementById('autocompleteDropdown');
  if (!input || !dropdown) return;
  
  let selectedIndex = -1;
  
  input.addEventListener('input', () => {
    const query = input.value.trim().toLowerCase();
    dropdown.innerHTML = '';
    selectedIndex = -1;
    
    if (query.length < 2) {
      dropdown.classList.remove('active');
      return;
    }
    
    const matches = playerNames.filter(name => 
      name.toLowerCase().includes(query)
    ).slice(0, 8);
    
    if (matches.length === 0) {
      dropdown.classList.remove('active');
      return;
    }
    
    matches.forEach((name, idx) => {
      const item = document.createElement('div');
      const alreadyGuessed = gameState.foundPlayers.includes(name);
      item.className = `autocomplete-item ${alreadyGuessed ? 'already-guessed' : ''}`;
      item.textContent = name;
      item.onclick = () => {
        if (!alreadyGuessed) {
          input.value = '';
          dropdown.classList.remove('active');
          checkGuess(name);
        }
      };
      dropdown.appendChild(item);
    });
    
    dropdown.classList.add('active');
  });
  
  input.addEventListener('keydown', (e) => {
    const items = dropdown.querySelectorAll('.autocomplete-item:not(.already-guessed)');
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
      updateSelected(items);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      selectedIndex = Math.max(selectedIndex - 1, -1);
      updateSelected(items);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (selectedIndex >= 0 && items[selectedIndex]) {
        const name = items[selectedIndex].textContent;
        input.value = '';
        dropdown.classList.remove('active');
        checkGuess(name);
      } else if (input.value.trim()) {
        const value = input.value;
        input.value = '';
        dropdown.classList.remove('active');
        checkGuess(value);
      }
    } else if (e.key === 'Escape') {
      dropdown.classList.remove('active');
    }
  });
  
  function updateSelected(items) {
    document.querySelectorAll('.autocomplete-item').forEach((item, idx) => {
      item.classList.toggle('selected', idx === selectedIndex);
    });
  }
  
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.guess-input-container')) {
      dropdown.classList.remove('active');
    }
  });
}

// ============================================
// UI HELPERS
// ============================================
window.toggleFoundList = function() {
  const list = document.getElementById('foundList');
  const btn = document.querySelector('.found-list-toggle');
  if (list && btn) {
    list.classList.toggle('collapsed');
    btn.textContent = list.classList.contains('collapsed') ? 'Show' : 'Hide';
  }
};

window.toggleMissedList = function() {
  const list = document.getElementById('missedList');
  const toggle = document.getElementById('missedToggle');
  if (list && toggle) {
    list.classList.toggle('collapsed');
    toggle.textContent = list.classList.contains('collapsed') ? '‚ñº' : '‚ñ≤';
  }
};

// ============================================
// STATS & SHARING
// ============================================
function getLocalStats() {
  try {
    const stored = localStorage.getItem('acesRosterRecall_stats');
    if (stored) return JSON.parse(stored);
  } catch (e) {}
  
  return {
    gamesPlayed: 0,
    perfectGames: 0,
    totalScore: 0,
    bestScore: 0,
    lastPlayedPuzzle: 0
  };
}

function saveLocalStats(stats) {
  try {
    localStorage.setItem('acesRosterRecall_stats', JSON.stringify(stats));
  } catch (e) {}
}

function updateLifetimeStats() {
  const stats = getLocalStats();
  
  if (stats.lastPlayedPuzzle === todaysPuzzle.dayNum) {
    return;
  }
  
  const isPerfect = gameState.foundPlayers.length === todaysPuzzle.players.length;
  
  // Check for speed demon - finished in less than 50% of time
  const timeUsed = gameState.totalTime - gameState.timeRemaining;
  const isSpeedDemon = isPerfect && timeUsed < (gameState.totalTime * 0.5);
  
  stats.gamesPlayed++;
  stats.lastPlayedPuzzle = todaysPuzzle.dayNum;
  stats.totalScore += gameState.score;
  stats.bestScore = Math.max(stats.bestScore, gameState.score);
  if (isPerfect) stats.perfectGames++;
  
  // Track fastest completion time (time remaining when finished)
  if (isPerfect) {
    stats.bestTimeRemaining = Math.max(stats.bestTimeRemaining || 0, gameState.timeRemaining);
  }
  
  // Track speed demon achievement
  if (isSpeedDemon) {
    stats.hasSpeedDemon = true;
  }
  
  saveLocalStats(stats);
  
  if (currentUser) {
    saveStatsToFirebase(stats);
  }
}

window.showStats = function() {
  const modal = document.getElementById('statsModal');
  const stats = getLocalStats();
  
  document.getElementById('statPlayed').textContent = stats.gamesPlayed;
  document.getElementById('statPerfect').textContent = stats.perfectGames;
  document.getElementById('statAvgScore').textContent = stats.gamesPlayed > 0 
    ? Math.round(stats.totalScore / stats.gamesPlayed) 
    : 0;
  document.getElementById('statBestScore').textContent = stats.bestScore;
  
  modal.classList.add('active');
};

window.closeStatsModal = function() {
  document.getElementById('statsModal').classList.remove('active');
};

window.shareResults = function() {
  if (gameState.phase !== 'finished') return;
  
  const found = gameState.foundPlayers.length;
  const total = todaysPuzzle.players.length;
  const pct = Math.round((found / total) * 100);
  
  // Create visual grid (filled squares for found, empty for missed)
  let visual = '';
  for (let i = 0; i < total; i++) {
    visual += i < found ? 'üü©' : '‚¨ú';
    if ((i + 1) % 10 === 0) visual += '\n';
  }
  
  const text = `Player Recall #${todaysPuzzle.dayNum}\n${todaysPuzzle.categoryName}\n\n${visual.trim()}\n\n${found}/${total} (${pct}%) - ${gameState.score} pts\n\nhttps://mountainsideaces.com/roster-recall.html`;
  
  if (navigator.share) {
    navigator.share({ text }).catch(() => copyToClipboard(text));
  } else {
    copyToClipboard(text);
  }
};

function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    showToast('Copied to clipboard!');
  }).catch(() => {
    showToast('Could not copy');
  });
}

function showToast(text) {
  const toast = document.getElementById('toast');
  toast.textContent = text;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 2000);
}

// ============================================
// FIREBASE PERSISTENCE
// ============================================
async function saveStatsToFirebase(stats) {
  if (!currentUser) return;
  
  try {
    const statsRef = doc(db, 'acesRosterRecallGames', currentUser.uid);
    await setDoc(statsRef, {
      ...stats,
      lastPlayedAt: serverTimestamp(),
      displayName: currentUser.displayName || 'Anonymous'
    }, { merge: true });
  } catch (error) {
    console.error('Error saving stats:', error);
  }
}

function saveGameStateLocal() {
  try {
    localStorage.setItem('acesRosterRecall_game', JSON.stringify({
      dayNum: todaysPuzzle.dayNum,
      phase: gameState.phase,
      foundPlayers: gameState.foundPlayers,
      timeRemaining: gameState.timeRemaining,
      totalTime: gameState.totalTime,
      score: gameState.score
    }));
  } catch (e) {}
}

function loadGameStateLocal() {
  try {
    const stored = localStorage.getItem('acesRosterRecall_game');
    if (stored) {
      const data = JSON.parse(stored);
      if (data.dayNum === todaysPuzzle.dayNum) {
        gameState.phase = data.phase || 'pre';
        gameState.foundPlayers = data.foundPlayers || [];
        gameState.timeRemaining = data.timeRemaining || 0;
        gameState.totalTime = data.totalTime || todaysPuzzle.totalTime;
        gameState.score = data.score || 0;
        return true;
      }
    }
  } catch (e) {}
  return false;
}

async function saveGameStateFirebase() {
  if (!currentUser) return;
  
  try {
    const gameRef = doc(db, 'acesRosterRecallGames', currentUser.uid, 'dailyGames', String(todaysPuzzle.dayNum));
    await setDoc(gameRef, {
      dayNum: todaysPuzzle.dayNum,
      phase: gameState.phase,
      foundPlayers: gameState.foundPlayers,
      timeRemaining: gameState.timeRemaining,
      totalTime: gameState.totalTime,
      score: gameState.score,
      updatedAt: serverTimestamp()
    });
  } catch (error) {
    console.error('Error saving to Firebase:', error);
  }
}

async function loadGameStateFirebase() {
  if (!currentUser) return false;
  
  try {
    const gameRef = doc(db, 'acesRosterRecallGames', currentUser.uid, 'dailyGames', String(todaysPuzzle.dayNum));
    const gameDoc = await getDoc(gameRef);
    
    if (gameDoc.exists()) {
      const data = gameDoc.data();
      if (data.dayNum === todaysPuzzle.dayNum) {
        gameState.phase = data.phase || 'pre';
        gameState.foundPlayers = data.foundPlayers || [];
        gameState.timeRemaining = data.timeRemaining || 0;
        gameState.totalTime = data.totalTime || todaysPuzzle.totalTime;
        gameState.score = data.score || 0;
        return true;
      }
    }
  } catch (error) {
    console.error('Error loading from Firebase:', error);
  }
  return false;
}

function saveGameState() {
  saveGameStateLocal();
  if (currentUser) {
    saveGameStateFirebase();
  }
}

async function loadGameState() {
  if (currentUser) {
    const loaded = await loadGameStateFirebase();
    if (loaded) return true;
  }
  return loadGameStateLocal();
}

// ============================================
// USER STATS DISPLAY
// ============================================
function updateUserStatsDisplay() {
  const container = document.getElementById('userStatsContainer');
  if (!container) return;
  
  if (!currentUser) {
    container.innerHTML = `
      <div class="user-stats-content">
        <div class="sign-in-prompt">
          <span>üîí</span>
          <a href="signin.html">Sign in</a> to track your stats across devices
        </div>
      </div>
    `;
    return;
  }
  
  const stats = getLocalStats();
  const avgScore = stats.gamesPlayed > 0 ? Math.round(stats.totalScore / stats.gamesPlayed) : 0;
  
  container.innerHTML = `
    <div class="user-stats-content">
      <div class="user-greeting">üëã ${currentUser.displayName || 'Player'}</div>
      <div class="lifetime-stats">
        <div class="lifetime-stat">
          <span class="lifetime-value">${stats.gamesPlayed}</span>
          <span class="lifetime-label">Played</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${stats.perfectGames}</span>
          <span class="lifetime-label">Perfect</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${avgScore}</span>
          <span class="lifetime-label">Avg Score</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${stats.bestScore}</span>
          <span class="lifetime-label">Best</span>
        </div>
      </div>
    </div>
  `;
}

// ============================================
// AUTH STATE
// ============================================
function setupAuthListener() {
  onAuthChange(async (user) => {
    currentUser = user;
    
    if (user && todaysPuzzle) {
      const firebaseHasState = await loadGameStateFirebase();
      if (firebaseHasState) {
        renderBasedOnPhase();
      }
    }
    
    updateUserStatsDisplay();
  });
}

function renderBasedOnPhase() {
  if (gameState.phase === 'pre') {
    renderPreGame();
  } else if (gameState.phase === 'playing') {
    // Game was in progress but page was closed - treat as finished
    gameState.phase = 'finished';
    renderFinished();
  } else if (gameState.phase === 'finished') {
    renderFinished();
  }
}

// ============================================
// HOW TO PLAY
// ============================================
window.toggleHowToPlay = function() {
  const section = document.getElementById('howToPlay');
  const toggle = document.getElementById('howToPlayToggle');
  section.classList.toggle('expanded');
  toggle.textContent = section.classList.contains('expanded') ? '‚ñ≤' : '‚ñº';
};

// ============================================
// INITIALIZATION
// ============================================
async function init() {
  try {
    // Check if before launch
    const launchDate = new Date(LAUNCH_YEAR, LAUNCH_MONTH, LAUNCH_DAY).setHours(0, 0, 0, 0);
    const now = new Date().setHours(0, 0, 0, 0);
    
    if (now < launchDate) {
      document.getElementById('loadingOverlay').classList.add('hidden');
      const launchDateObj = new Date(LAUNCH_YEAR, LAUNCH_MONTH, LAUNCH_DAY);
      document.getElementById('puzzleDate').textContent = `Launching ${launchDateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}`;
      document.getElementById('gameContent').innerHTML = `
        <div class="pre-game">
          <div style="font-size: 3rem; margin-bottom: 1rem;">‚è±Ô∏è</div>
          <h3 style="margin: 0;">Coming Soon!</h3>
        </div>
      `;
      return;
    }
    
    // Check for existing auth
    currentUser = getCurrentUser();
    
    // Load players
    console.log('Loading player data...');
    const rawPlayers = await getAllPlayerStatsOptimized();
    allPlayers = rawPlayers.filter(p => p.migrated !== true);
    playerNames = allPlayers.map(p => p.name || p.playerName).filter(Boolean);
    console.log(`Loaded ${allPlayers.length} players`);
    
    // Generate puzzle
    todaysPuzzle = generateDailyPuzzle();
    console.log('Today\'s puzzle:', todaysPuzzle.categoryName, `(${todaysPuzzle.players.length} players, ${todaysPuzzle.totalTime}s)`);
    
    // Display date
    const today = new Date();
    document.getElementById('puzzleDate').textContent = 
      `Puzzle #${todaysPuzzle.dayNum} ‚Ä¢ ${today.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' })}`;
    
    // Load saved state
    await loadGameState();
    
    // Setup
    setupAuthListener();
    updateUserStatsDisplay();
    
    // Render based on state
    renderBasedOnPhase();
    
    // Hide loading
    document.getElementById('loadingOverlay').classList.add('hidden');
    
  } catch (error) {
    console.error('Error initializing game:', error);
    document.getElementById('loadingOverlay').innerHTML = `
      <div style="text-align: center; padding: 2rem;">
        <p>Error loading game</p>
        <p style="color: var(--text-light); font-size: 0.9rem;">${error.message}</p>
        <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.75rem 1.5rem; cursor: pointer;">Retry</button>
      </div>
    `;
  }
}

// Start
init();
</script>

<script type="module">
  import { NavigationComponent } from './nav-component.js';
</script>
<script src="mobile-enhancements.js"></script>
</body>
</html>

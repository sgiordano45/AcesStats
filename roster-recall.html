<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Player Recall - Mountainside Aces</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
:root {
  --primary-color: #2d5016;
  --secondary-color: #1a6b4a;
  --accent-color: #ffd700;
  --card-bg: #ffffff;
  --text-dark: #2d3748;
  --text-light: #718096;
  --border-color: #e2e8f0;
  --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
  --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
  
  /* Roster Recall theme - Red/Orange energy */
  --recall-primary: #dc2626;
  --recall-secondary: #ea580c;
  --recall-gradient: linear-gradient(135deg, #dc2626, #ea580c);
  --correct: #10b981;
  --timer-warning: #f59e0b;
  --timer-danger: #ef4444;
}

* { box-sizing: border-box; }

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  margin: 0;
  padding: 0;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  min-height: 100vh;
  color: var(--text-dark);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,255,255,0.95);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.5s ease, visibility 0.5s ease;
}

.loading-overlay.hidden {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

.softball-spinner::before {
  content: '‚öæ';
  font-size: 60px;
  animation: spin 1.5s ease-in-out infinite;
  display: block;
}

@keyframes spin {
  0%, 100% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.1); }
}

/* Page Container */
.page-container {
  max-width: 600px;
  margin: 0 auto;
  padding: 1rem;
}

/* Page Header */
.page-header {
  background: var(--recall-gradient);
  color: white;
  text-align: center;
  padding: 1.5rem 1rem;
  border-radius: 16px;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
}

.back-link {
  position: absolute;
  top: 1rem;
  left: 1rem;
  color: rgba(255,255,255,0.85);
  text-decoration: none;
  font-size: 0.85rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.35rem 0.75rem;
  background: rgba(255,255,255,0.15);
  border-radius: 6px;
  transition: all 0.2s ease;
  z-index: 10;
}

.back-link:hover {
  background: rgba(255,255,255,0.25);
  color: white;
}

.page-header::before {
  content: '';
  position: absolute;
  top: -100px;
  right: -100px;
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
  border-radius: 50%;
}

.page-header h1 {
  margin: 0 0 0.25rem 0;
  font-size: 1.75rem;
  font-weight: 700;
  position: relative;
  z-index: 1;
}

.page-header .subtitle {
  opacity: 0.9;
  font-size: 0.9rem;
  margin: 0;
  position: relative;
  z-index: 1;
}

.puzzle-date {
  font-size: 0.85rem;
  opacity: 0.85;
  margin-top: 0.5rem;
  position: relative;
  z-index: 1;
}

/* Timer Display */
.timer-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
  text-align: center;
}

.timer-display {
  font-size: 3.5rem;
  font-weight: 800;
  font-variant-numeric: tabular-nums;
  color: var(--text-dark);
  transition: color 0.3s ease;
}

.timer-display.warning {
  color: var(--timer-warning);
}

.timer-display.danger {
  color: var(--timer-danger);
  animation: pulse 0.5s ease infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.timer-label {
  font-size: 0.85rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-top: 0.25rem;
}

.timer-bar {
  width: 100%;
  height: 8px;
  background: var(--border-color);
  border-radius: 4px;
  margin-top: 1rem;
  overflow: hidden;
}

.timer-bar-fill {
  height: 100%;
  background: var(--recall-gradient);
  border-radius: 4px;
  transition: width 0.1s linear;
}

.timer-bar-fill.warning {
  background: var(--timer-warning);
}

.timer-bar-fill.danger {
  background: var(--timer-danger);
}

/* Category Display */
.category-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
  text-align: center;
}

.category-label {
  font-size: 0.8rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 0.5rem;
}

.category-name {
  font-size: 1.35rem;
  font-weight: 700;
  color: var(--recall-primary);
}

.found-count {
  margin-top: 0.75rem;
  font-size: 1.1rem;
  color: var(--text-dark);
}

.found-count span {
  font-weight: 700;
  color: var(--correct);
}

/* Input Section */
.input-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-md);
}

.guess-input-container {
  position: relative;
}

.guess-input {
  width: 100%;
  padding: 1rem;
  font-size: 1.1rem;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  outline: none;
  transition: border-color 0.2s;
}

.guess-input:focus {
  border-color: var(--recall-primary);
}

.guess-input:disabled {
  background: #f7fafc;
  cursor: not-allowed;
}

/* Autocomplete Dropdown */
.autocomplete-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: white;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  margin-top: 4px;
  max-height: 200px;
  overflow-y: auto;
  z-index: 100;
  box-shadow: var(--shadow-md);
  display: none;
}

.autocomplete-dropdown.active {
  display: block;
}

.autocomplete-item {
  padding: 0.75rem 1rem;
  cursor: pointer;
  transition: background 0.15s;
  border-bottom: 1px solid var(--border-color);
}

.autocomplete-item:last-child {
  border-bottom: none;
}

.autocomplete-item:hover {
  background: #f7fafc;
}

.autocomplete-item.selected {
  background: #edf2f7;
}

.autocomplete-item.already-guessed {
  opacity: 0.4;
  text-decoration: line-through;
  cursor: not-allowed;
}

/* Feedback */
.feedback {
  min-height: 1.5rem;
  text-align: center;
  font-weight: 600;
  font-size: 0.95rem;
  margin-top: 0.75rem;
  transition: all 0.2s;
}

.feedback.correct {
  color: var(--correct);
}

.feedback.wrong {
  color: var(--timer-danger);
}

/* Found List */
.found-list-container {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border-color);
  display: none;
}

.found-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.found-list-label {
  font-size: 0.85rem;
  color: var(--text-light);
  font-weight: 500;
}

.found-list-toggle {
  font-size: 0.8rem;
  color: var(--recall-primary);
  cursor: pointer;
  background: none;
  border: none;
  padding: 0;
}

.found-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.found-list.collapsed {
  display: none;
}

.found-player {
  background: rgba(16, 185, 129, 0.1);
  color: var(--correct);
  padding: 0.35rem 0.75rem;
  border-radius: 20px;
  font-size: 0.85rem;
  font-weight: 500;
}

/* Give Up Button */
.give-up-container {
  text-align: center;
  margin-top: 1rem;
}

.give-up-btn {
  background: none;
  border: none;
  color: var(--text-light);
  font-size: 0.85rem;
  cursor: pointer;
  padding: 0.5rem 1rem;
  transition: color 0.2s;
}

.give-up-btn:hover {
  color: var(--timer-danger);
}

/* Pre-game Screen */
.pre-game {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 2rem 1.5rem;
  text-align: center;
  box-shadow: var(--shadow-md);
}

.pre-game h3 {
  font-size: 1.3rem;
  margin: 0 0 0.5rem 0;
}

.pre-game p {
  color: var(--text-light);
  margin: 0 0 1.5rem 0;
}

.start-btn {
  background: var(--recall-gradient);
  color: white;
  border: none;
  padding: 1rem 2.5rem;
  font-size: 1.1rem;
  font-weight: 600;
  border-radius: 12px;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: transform 0.2s, box-shadow 0.2s;
}

.start-btn:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

/* Results Screen */
.results-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.5rem;
  text-align: center;
  box-shadow: var(--shadow-md);
}

.results-emoji {
  font-size: 4rem;
  margin-bottom: 0.5rem;
}

.results-title {
  font-size: 1.5rem;
  font-weight: 700;
  margin: 0 0 0.25rem 0;
}

.results-subtitle {
  color: var(--text-light);
  margin: 0 0 1.5rem 0;
}

.score-display {
  background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
  border-radius: 12px;
  padding: 1.25rem;
  margin-bottom: 1.5rem;
}

.score-value {
  font-size: 3rem;
  font-weight: 800;
  color: var(--correct);
}

.score-label {
  font-size: 0.85rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.results-stats {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.result-stat {
  text-align: center;
}

.result-stat-value {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-dark);
}

.result-stat-label {
  font-size: 0.75rem;
  color: var(--text-light);
  text-transform: uppercase;
}

.missed-section {
  text-align: left;
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid var(--border-color);
}

.missed-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.missed-label {
  font-size: 0.9rem;
  color: var(--text-light);
  font-weight: 500;
}

.missed-toggle {
  font-size: 0.8rem;
  color: var(--recall-primary);
  cursor: pointer;
  background: none;
  border: none;
  padding: 0;
}

.missed-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.missed-list.collapsed {
  display: none;
}

.missed-player {
  background: rgba(239, 68, 68, 0.1);
  color: var(--timer-danger);
  padding: 0.35rem 0.75rem;
  border-radius: 20px;
  font-size: 0.85rem;
}

.share-btn {
  background: var(--recall-gradient);
  color: white;
  border: none;
  padding: 1rem 2rem;
  font-size: 1rem;
  font-weight: 600;
  border-radius: 12px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

/* User Stats Section */
.user-stats-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1rem 1.25rem;
  margin-bottom: 1rem;
  box-shadow: var(--shadow-sm);
}

.user-stats-content {
  text-align: center;
}

.user-greeting {
  font-weight: 600;
  margin-bottom: 0.75rem;
  font-size: 0.95rem;
}

.lifetime-stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.5rem;
}

.lifetime-stat {
  text-align: center;
}

.lifetime-value {
  display: block;
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--recall-primary);
}

.lifetime-label {
  font-size: 0.7rem;
  color: var(--text-light);
  text-transform: uppercase;
}

.sign-in-prompt {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  font-size: 0.9rem;
  color: var(--text-light);
}

.sign-in-prompt a {
  color: var(--recall-primary);
  font-weight: 600;
}

/* How to Play */
.how-to-play-section {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1rem 1.25rem;
  margin-top: 1rem;
  box-shadow: var(--shadow-sm);
}

.how-to-play-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
}

.how-to-play-title {
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--text-dark);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.how-to-play-toggle {
  color: var(--text-light);
  font-size: 0.8rem;
}

.how-to-play-content {
  display: none;
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border-color);
  text-align: left;
}

.how-to-play-section.expanded .how-to-play-content {
  display: block;
}

.how-to-play-content p {
  margin: 0 0 0.75rem 0;
  font-size: 0.9rem;
  color: var(--text-light);
  line-height: 1.5;
}

.how-to-play-content p:last-child {
  margin-bottom: 0;
}

/* Toast */
.toast {
  position: fixed;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%) translateY(100px);
  background: var(--text-dark);
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  font-size: 0.9rem;
  opacity: 0;
  transition: all 0.3s ease;
  z-index: 1000;
}

.toast.show {
  transform: translateX(-50%) translateY(0);
  opacity: 1;
}

/* Mobile adjustments */
@media (max-width: 480px) {
  .page-header h1 { font-size: 1.5rem; }
  .timer-display { font-size: 2.75rem; }
  .lifetime-stats { gap: 0.25rem; }
  .lifetime-value { font-size: 1.1rem; }
  .results-stats { gap: 0.5rem; }
}
</style>
</head>
<body>

<nav-component></nav-component>

<div id="loadingOverlay" class="loading-overlay">
  <div class="softball-spinner"></div>
  <p style="margin-top: 1rem; color: var(--text-light);">Loading puzzle...</p>
</div>

<div class="page-container">
  <div class="page-header">
    <a href="index.html" class="back-link">‚Üê Home</a>
    <h1>üß† Player Recall</h1>
    <p class="subtitle">Name players from memory!</p>
    <div id="puzzleDate" class="puzzle-date"></div>
  </div>
  
  <div id="userStatsContainer" class="user-stats-container">
    <div class="user-stats-content">
      <div class="sign-in-prompt">Loading...</div>
    </div>
  </div>
  
  <div id="gameContent">
    <!-- Game content renders here -->
  </div>
  
  <div class="how-to-play-section" id="howToPlay">
    <div class="how-to-play-header" onclick="toggleHowToPlay()">
      <span class="how-to-play-title">‚ùì How to Play</span>
      <span class="how-to-play-toggle" id="howToPlayToggle">‚ñº</span>
    </div>
    <div class="how-to-play-content">
      <p><strong>Goal:</strong> Name all Aces players who match today's category before time runs out!</p>
      <p><strong>Scoring:</strong> +10 points per correct answer, plus time bonus. Perfect games (all players found) get a 50-point bonus!</p>
      <p><strong>Tips:</strong> Type quickly - the autocomplete helps! Focus on the most prolific players first.</p>
      <p>A new puzzle appears every day at midnight.</p>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script type="module">
import { db } from './firebase-config.js';
import { doc, getDoc, setDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
import { getAllPlayerStatsOptimized } from './firebase-data.js';
import { onAuthChange, getCurrentUser } from './firebase-auth.js';

// Game configuration
const LAUNCH_YEAR = 2025;
const LAUNCH_MONTH = 5; // June (0-indexed)
const LAUNCH_DAY = 1;

// State
let currentUser = null;
let allPlayers = [];
let playerNames = [];
let todaysPuzzle = null;
let timerInterval = null;

const gameState = {
  phase: 'pre', // pre, playing, finished
  foundPlayers: [],
  timeRemaining: 0,
  totalTime: 0,
  score: 0
};

// Category definitions - use Firebase field names (lowercase full words)
const CATEGORIES = [
  { 
    name: 'Players with 50+ Career Hits',
    filter: (p) => (p.career?.hits || 0) >= 50,
    time: 120
  },
  { 
    name: 'Players with 100+ Career Hits',
    filter: (p) => (p.career?.hits || 0) >= 100,
    time: 90
  },
  { 
    name: 'Players with 200+ Career At-Bats',
    filter: (p) => (p.career?.atBats || 0) >= 200,
    time: 90
  },
  { 
    name: 'Players with 30+ Career Walks',
    filter: (p) => (p.career?.walks || 0) >= 30,
    time: 90
  },
  { 
    name: 'Players with 50+ Career RBI',
    filter: (p) => (p.career?.rbi || 0) >= 50,
    time: 120
  },
  { 
    name: 'Players with 50+ Career Runs',
    filter: (p) => (p.career?.runs || 0) >= 50,
    time: 120
  },
  { 
    name: 'Players with .400+ Career AVG (min 50 AB)',
    filter: (p) => (p.career?.atBats || 0) >= 50 && (p.career?.battingAverage || 0) >= 0.400,
    time: 90
  },
  { 
    name: 'Players with 100+ Career Games',
    filter: (p) => (p.career?.games || 0) >= 100,
    time: 90
  },
  { 
    name: 'Players with 55+ AcesBPI (min 50 AB)',
    filter: (p) => (p.career?.atBats || 0) >= 50 && (p.career?.acesBPI || 0) >= 55,
    time: 90
  },
  { 
    name: 'Current Green Team Players',
    filter: (p) => p.currentTeam === 'Green',
    time: 60
  },
  { 
    name: 'Current Gold Team Players',
    filter: (p) => p.currentTeam === 'Gold',
    time: 60
  },
  { 
    name: 'Current White Team Players',
    filter: (p) => p.currentTeam === 'White',
    time: 60
  },
  { 
    name: 'Current Blue Team Players',
    filter: (p) => p.currentTeam === 'Blue',
    time: 60
  },
  { 
    name: 'Current Black Team Players',
    filter: (p) => p.currentTeam === 'Black',
    time: 60
  },
  { 
    name: 'Current Red Team Players',
    filter: (p) => p.currentTeam === 'Red',
    time: 60
  },
  { 
    name: 'Current Silver Team Players',
    filter: (p) => p.currentTeam === 'Silver',
    time: 60
  },
  { 
    name: 'Current Orange Team Players',
    filter: (p) => p.currentTeam === 'Orange',
    time: 60
  },
  { 
    name: 'Current Purple Team Players',
    filter: (p) => p.currentTeam === 'Purple',
    time: 60
  },
  { 
    name: 'Current Army Team Players',
    filter: (p) => p.currentTeam === 'Army',
    time: 60
  },
  { 
    name: 'Current Carolina Team Players',
    filter: (p) => p.currentTeam === 'Carolina',
    time: 60
  }
];

// Seeded random for consistent daily puzzles
function seededRandom(seed) {
  const x = Math.sin(seed) * 10000;
  return x - Math.floor(x);
}

function generateDailyPuzzle() {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const launch = new Date(LAUNCH_YEAR, LAUNCH_MONTH, LAUNCH_DAY);
  launch.setHours(0, 0, 0, 0);
  
  const dayNum = Math.floor((today - launch) / (1000 * 60 * 60 * 24)) + 1;
  const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
  
  // Pick category based on day
  const categoryIndex = Math.floor(seededRandom(seed) * CATEGORIES.length);
  const category = CATEGORIES[categoryIndex];
  
  // Filter players
  const matchingPlayers = allPlayers
    .filter(category.filter)
    .map(p => p.name || p.playerName)
    .filter(Boolean);
  
  return {
    dayNum,
    categoryName: category.name,
    players: matchingPlayers,
    totalTime: category.time
  };
}

// ============================================
// GAME RENDERING
// ============================================
function renderPreGame() {
  const content = document.getElementById('gameContent');
  content.innerHTML = `
    <div class="pre-game">
      <div style="font-size: 3rem; margin-bottom: 1rem;">üéØ</div>
      <h3>Today's Challenge</h3>
      <p><strong>${todaysPuzzle.categoryName}</strong></p>
      <p>${todaysPuzzle.players.length} players to find ‚Ä¢ ${todaysPuzzle.totalTime} seconds</p>
      <button class="start-btn" onclick="startGame()">Start Game</button>
    </div>
  `;
}

function renderPlaying() {
  const content = document.getElementById('gameContent');
  content.innerHTML = `
    <div class="timer-container">
      <div class="timer-display" id="timerDisplay">${formatTime(gameState.timeRemaining)}</div>
      <div class="timer-label">Time Remaining</div>
      <div class="timer-bar">
        <div class="timer-bar-fill" id="timerBar" style="width: 100%"></div>
      </div>
    </div>
    
    <div class="category-container">
      <div class="category-label">Find all players who are:</div>
      <div class="category-name">${todaysPuzzle.categoryName}</div>
      <div class="found-count">
        Found: <span id="foundCount">0</span> / ${todaysPuzzle.players.length}
      </div>
    </div>
    
    <div class="input-container">
      <div class="guess-input-container">
        <input type="text" 
               id="guessInput" 
               class="guess-input" 
               placeholder="Type a player name..."
               autocomplete="off"
               autocorrect="off"
               autocapitalize="off"
               spellcheck="false">
        <div class="autocomplete-dropdown" id="autocomplete"></div>
      </div>
      <div id="feedback" class="feedback"></div>
      
      <div class="found-list-container" id="foundListContainer">
        <div class="found-list-header">
          <span class="found-list-label">Found Players:</span>
          <button class="found-list-toggle" onclick="toggleFoundList()">Hide</button>
        </div>
        <div class="found-list" id="foundList"></div>
      </div>
    </div>
    
    <div class="give-up-container">
      <button class="give-up-btn" onclick="giveUp()">Give Up</button>
    </div>
  `;
  
  setupAutocomplete();
  document.getElementById('guessInput').focus();
}

function renderFinished() {
  const found = gameState.foundPlayers.length;
  const total = todaysPuzzle.players.length;
  const pct = Math.round((found / total) * 100);
  const missed = todaysPuzzle.players.filter(p => !gameState.foundPlayers.includes(p));
  
  let emoji, title;
  if (found === total) {
    emoji = 'üèÜ';
    title = 'Perfect!';
  } else if (pct >= 80) {
    emoji = 'üåü';
    title = 'Excellent!';
  } else if (pct >= 60) {
    emoji = 'üëç';
    title = 'Good Job!';
  } else if (pct >= 40) {
    emoji = 'üòÖ';
    title = 'Nice Try!';
  } else {
    emoji = 'üí™';
    title = 'Keep Practicing!';
  }
  
  const content = document.getElementById('gameContent');
  content.innerHTML = `
    <div class="results-container">
      <div class="results-emoji">${emoji}</div>
      <h2 class="results-title">${title}</h2>
      <p class="results-subtitle">${todaysPuzzle.categoryName}</p>
      
      <div class="score-display">
        <div class="score-value">${gameState.score}</div>
        <div class="score-label">Points</div>
      </div>
      
      <div class="results-stats">
        <div class="result-stat">
          <div class="result-stat-value">${found}/${total}</div>
          <div class="result-stat-label">Found</div>
        </div>
        <div class="result-stat">
          <div class="result-stat-value">${pct}%</div>
          <div class="result-stat-label">Complete</div>
        </div>
        <div class="result-stat">
          <div class="result-stat-value">${formatTime(todaysPuzzle.totalTime - gameState.timeRemaining)}</div>
          <div class="result-stat-label">Time Used</div>
        </div>
      </div>
      
      <button class="share-btn" onclick="shareResults()">
        üì§ Share Results
      </button>
      
      ${missed.length > 0 ? `
        <div class="missed-section">
          <div class="missed-header">
            <span class="missed-label">Missed ${missed.length} player${missed.length > 1 ? 's' : ''}:</span>
            <button class="missed-toggle" id="missedToggle" onclick="toggleMissed()">Show ‚ñº</button>
          </div>
          <div class="missed-list collapsed" id="missedList">
            ${missed.map(p => `<span class="missed-player">${p}</span>`).join('')}
          </div>
        </div>
      ` : ''}
    </div>
  `;
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// ============================================
// GAME LOGIC
// ============================================
window.startGame = function() {
  gameState.phase = 'playing';
  gameState.timeRemaining = todaysPuzzle.totalTime;
  gameState.totalTime = todaysPuzzle.totalTime;
  gameState.foundPlayers = [];
  gameState.score = 0;
  
  renderPlaying();
  startTimer();
  saveGameState();
};

function startTimer() {
  timerInterval = setInterval(() => {
    gameState.timeRemaining--;
    
    const display = document.getElementById('timerDisplay');
    const bar = document.getElementById('timerBar');
    
    if (display) {
      display.textContent = formatTime(gameState.timeRemaining);
      
      const pct = (gameState.timeRemaining / gameState.totalTime) * 100;
      bar.style.width = `${pct}%`;
      
      // Color changes
      display.classList.remove('warning', 'danger');
      bar.classList.remove('warning', 'danger');
      
      if (gameState.timeRemaining <= 10) {
        display.classList.add('danger');
        bar.classList.add('danger');
      } else if (gameState.timeRemaining <= 30) {
        display.classList.add('warning');
        bar.classList.add('warning');
      }
    }
    
    if (gameState.timeRemaining <= 0) {
      endGame();
    }
  }, 1000);
}

function endGame() {
  clearInterval(timerInterval);
  timerInterval = null;
  
  gameState.phase = 'finished';
  
  // Calculate score
  const found = gameState.foundPlayers.length;
  const total = todaysPuzzle.players.length;
  const basePoints = found * 10;
  const timeBonus = Math.floor(gameState.timeRemaining / 2);
  const perfectBonus = (found === total) ? 50 : 0;
  
  gameState.score = basePoints + timeBonus + perfectBonus;
  
  saveGameState();
  updateStats(found === total, gameState.score);
  
  renderFinished();
  updateUserStatsDisplay();
}

window.giveUp = function() {
  if (confirm('Are you sure you want to give up?')) {
    gameState.timeRemaining = 0;
    endGame();
  }
};

// ============================================
// AUTOCOMPLETE
// ============================================
function setupAutocomplete() {
  const input = document.getElementById('guessInput');
  const dropdown = document.getElementById('autocomplete');
  let selectedIndex = -1;
  
  input.addEventListener('input', () => {
    const value = input.value.toLowerCase().trim();
    
    if (value.length < 2) {
      dropdown.classList.remove('active');
      return;
    }
    
    const matches = playerNames.filter(name => 
      name.toLowerCase().includes(value)
    ).slice(0, 8);
    
    if (matches.length === 0) {
      dropdown.classList.remove('active');
      return;
    }
    
    dropdown.innerHTML = matches.map((name, i) => {
      const alreadyGuessed = gameState.foundPlayers.includes(name);
      return `<div class="autocomplete-item ${alreadyGuessed ? 'already-guessed' : ''} ${i === selectedIndex ? 'selected' : ''}" 
                   data-name="${name}">${name}</div>`;
    }).join('');
    
    dropdown.classList.add('active');
    selectedIndex = -1;
    
    dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
      item.addEventListener('click', () => {
        if (!item.classList.contains('already-guessed')) {
          submitGuess(item.dataset.name);
        }
      });
    });
  });
  
  input.addEventListener('keydown', (e) => {
    const items = dropdown.querySelectorAll('.autocomplete-item:not(.already-guessed)');
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
      updateSelection(items);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      selectedIndex = Math.max(selectedIndex - 1, 0);
      updateSelection(items);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (selectedIndex >= 0 && items[selectedIndex]) {
        submitGuess(items[selectedIndex].dataset.name);
      } else if (items.length === 1) {
        submitGuess(items[0].dataset.name);
      }
    } else if (e.key === 'Escape') {
      dropdown.classList.remove('active');
    }
  });
  
  function updateSelection(items) {
    items.forEach((item, i) => {
      item.classList.toggle('selected', i === selectedIndex);
    });
    if (items[selectedIndex]) {
      items[selectedIndex].scrollIntoView({ block: 'nearest' });
    }
  }
  
  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!input.contains(e.target) && !dropdown.contains(e.target)) {
      dropdown.classList.remove('active');
    }
  });
}

function submitGuess(name) {
  const input = document.getElementById('guessInput');
  const dropdown = document.getElementById('autocomplete');
  const feedback = document.getElementById('feedback');
  
  dropdown.classList.remove('active');
  input.value = '';
  
  // Check if already found
  if (gameState.foundPlayers.includes(name)) {
    showFeedback('Already found!', 'wrong');
    return;
  }
  
  // Check if correct
  if (todaysPuzzle.players.includes(name)) {
    gameState.foundPlayers.push(name);
    showFeedback(`‚úì ${name}`, 'correct');
    updateFoundDisplay();
    saveGameState();
    
    // Check for win
    if (gameState.foundPlayers.length === todaysPuzzle.players.length) {
      setTimeout(() => endGame(), 500);
    }
  } else {
    showFeedback('Not in this category', 'wrong');
  }
  
  input.focus();
}

function showFeedback(text, type) {
  const feedback = document.getElementById('feedback');
  feedback.textContent = text;
  feedback.className = `feedback ${type}`;
  
  setTimeout(() => {
    feedback.textContent = '';
    feedback.className = 'feedback';
  }, 1500);
}

function updateFoundDisplay() {
  const count = document.getElementById('foundCount');
  const list = document.getElementById('foundList');
  const container = document.getElementById('foundListContainer');
  
  count.textContent = gameState.foundPlayers.length;
  
  const newest = gameState.foundPlayers[gameState.foundPlayers.length - 1];
  list.innerHTML += `<span class="found-player">${newest}</span>`;
  
  container.style.display = '';
}

window.toggleFoundList = function() {
  const list = document.getElementById('foundList');
  const btn = list.previousElementSibling.querySelector('.found-list-toggle');
  list.classList.toggle('collapsed');
  btn.textContent = list.classList.contains('collapsed') ? 'Show' : 'Hide';
};

window.toggleMissed = function() {
  const list = document.getElementById('missedList');
  const toggle = document.getElementById('missedToggle');
  list.classList.toggle('collapsed');
  toggle.textContent = list.classList.contains('collapsed') ? 'Show ‚ñº' : 'Hide ‚ñ≤';
};

// ============================================
// STATS MANAGEMENT - FIREBASE-FIRST WITH PROTECTION
// ============================================

// Get default stats object
function getDefaultStats() {
  return {
    gamesPlayed: 0,
    perfectGames: 0,
    totalScore: 0,
    bestScore: 0,
    lastPlayedPuzzle: 0
  };
}

// Get stats from localStorage
function getLocalStats() {
  try {
    const stored = localStorage.getItem('acesRosterRecall_stats');
    if (stored) return JSON.parse(stored);
  } catch (e) {
    console.warn('Error reading localStorage stats:', e);
  }
  return getDefaultStats();
}

// Save stats to localStorage
function saveLocalStats(stats) {
  try {
    localStorage.setItem('acesRosterRecall_stats', JSON.stringify(stats));
  } catch (e) {
    console.warn('Error saving localStorage stats:', e);
  }
}

// Load stats from Firebase with proper error handling
async function loadStatsFromFirebase() {
  if (!currentUser) return null;
  
  try {
    const statsRef = doc(db, 'acesRosterRecallGames', currentUser.uid);
    const statsDoc = await getDoc(statsRef);
    
    if (statsDoc.exists()) {
      const data = statsDoc.data();
      return {
        gamesPlayed: data.gamesPlayed || 0,
        perfectGames: data.perfectGames || 0,
        totalScore: data.totalScore || 0,
        bestScore: data.bestScore || 0,
        lastPlayedPuzzle: data.lastPlayedPuzzle || 0
      };
    }
    // Document doesn't exist yet - this is OK, return null
    return null;
  } catch (error) {
    console.error('Error loading stats from Firebase:', error);
    // Return undefined to indicate error (different from null which means no data)
    return undefined;
  }
}

// Save stats to Firebase with protection against overwriting good data with zeros
async function saveStatsToFirebase(stats) {
  if (!currentUser) return;
  
  try {
    const statsRef = doc(db, 'acesRosterRecallGames', currentUser.uid);
    await setDoc(statsRef, {
      ...stats,
      lastPlayedAt: serverTimestamp(),
      displayName: currentUser.displayName || 'Anonymous'
    }, { merge: true });
    console.log('Stats saved to Firebase:', stats);
  } catch (error) {
    console.error('Error saving stats to Firebase:', error);
  }
}

// Get the best stats between Firebase and localStorage (for migration/sync)
function mergeStats(firebaseStats, localStats) {
  // If either is null/undefined, return the other
  if (!firebaseStats) return localStats;
  if (!localStats) return firebaseStats;
  
  // Return the stats with more games played (or better data)
  return {
    gamesPlayed: Math.max(firebaseStats.gamesPlayed || 0, localStats.gamesPlayed || 0),
    perfectGames: Math.max(firebaseStats.perfectGames || 0, localStats.perfectGames || 0),
    totalScore: Math.max(firebaseStats.totalScore || 0, localStats.totalScore || 0),
    bestScore: Math.max(firebaseStats.bestScore || 0, localStats.bestScore || 0),
    lastPlayedPuzzle: Math.max(firebaseStats.lastPlayedPuzzle || 0, localStats.lastPlayedPuzzle || 0)
  };
}

// Main stats update function with protection
async function updateStats(isPerfect, score) {
  let stats;
  let firebaseLoadFailed = false;
  
  // Try to load from Firebase first
  if (currentUser) {
    const firebaseStats = await loadStatsFromFirebase();
    
    if (firebaseStats === undefined) {
      // Firebase load failed - DO NOT proceed with zeros
      firebaseLoadFailed = true;
      console.warn('Firebase load failed, using localStorage only for this update');
      stats = getLocalStats();
    } else if (firebaseStats === null) {
      // No Firebase data exists yet - merge with localStorage for migration
      const localStats = getLocalStats();
      stats = localStats;
      console.log('No Firebase stats found, migrating from localStorage:', stats);
    } else {
      // Firebase has data - merge with localStorage to get best of both
      const localStats = getLocalStats();
      stats = mergeStats(firebaseStats, localStats);
    }
  } else {
    // Not logged in - use localStorage
    stats = getLocalStats();
  }
  
  // Only count if we haven't played this puzzle today
  if (stats.lastPlayedPuzzle !== todaysPuzzle.dayNum) {
    stats.gamesPlayed++;
    if (isPerfect) stats.perfectGames++;
    stats.totalScore += score;
    stats.bestScore = Math.max(stats.bestScore, score);
    stats.lastPlayedPuzzle = todaysPuzzle.dayNum;
    
    // Always save to localStorage
    saveLocalStats(stats);
    
    // Only save to Firebase if load didn't fail (protect against overwriting with bad data)
    if (currentUser && !firebaseLoadFailed) {
      await saveStatsToFirebase(stats);
    }
  }
}

// ============================================
// GAME STATE PERSISTENCE
// ============================================
function saveGameStateLocal() {
  try {
    localStorage.setItem('acesRosterRecall_game', JSON.stringify({
      dayNum: todaysPuzzle.dayNum,
      phase: gameState.phase,
      foundPlayers: gameState.foundPlayers,
      timeRemaining: gameState.timeRemaining,
      totalTime: gameState.totalTime,
      score: gameState.score
    }));
  } catch (e) {}
}

function loadGameStateLocal() {
  try {
    const stored = localStorage.getItem('acesRosterRecall_game');
    if (stored) {
      const data = JSON.parse(stored);
      if (data.dayNum === todaysPuzzle.dayNum) {
        gameState.phase = data.phase || 'pre';
        gameState.foundPlayers = data.foundPlayers || [];
        gameState.timeRemaining = data.timeRemaining || 0;
        gameState.totalTime = data.totalTime || todaysPuzzle.totalTime;
        gameState.score = data.score || 0;
        return true;
      }
    }
  } catch (e) {}
  return false;
}

async function saveGameStateFirebase() {
  if (!currentUser) return;
  
  try {
    const gameRef = doc(db, 'acesRosterRecallGames', currentUser.uid, 'dailyGames', String(todaysPuzzle.dayNum));
    await setDoc(gameRef, {
      dayNum: todaysPuzzle.dayNum,
      phase: gameState.phase,
      foundPlayers: gameState.foundPlayers,
      timeRemaining: gameState.timeRemaining,
      totalTime: gameState.totalTime,
      score: gameState.score,
      updatedAt: serverTimestamp()
    });
  } catch (error) {
    console.error('Error saving to Firebase:', error);
  }
}

async function loadGameStateFirebase() {
  if (!currentUser) return false;
  
  try {
    const gameRef = doc(db, 'acesRosterRecallGames', currentUser.uid, 'dailyGames', String(todaysPuzzle.dayNum));
    const gameDoc = await getDoc(gameRef);
    
    if (gameDoc.exists()) {
      const data = gameDoc.data();
      if (data.dayNum === todaysPuzzle.dayNum) {
        gameState.phase = data.phase || 'pre';
        gameState.foundPlayers = data.foundPlayers || [];
        gameState.timeRemaining = data.timeRemaining || 0;
        gameState.totalTime = data.totalTime || todaysPuzzle.totalTime;
        gameState.score = data.score || 0;
        return true;
      }
    }
  } catch (error) {
    console.error('Error loading from Firebase:', error);
  }
  return false;
}

function saveGameState() {
  saveGameStateLocal();
  if (currentUser) {
    saveGameStateFirebase();
  }
}

async function loadGameState() {
  if (currentUser) {
    const loaded = await loadGameStateFirebase();
    if (loaded) return true;
  }
  return loadGameStateLocal();
}

// ============================================
// USER STATS DISPLAY
// ============================================
async function updateUserStatsDisplay() {
  const container = document.getElementById('userStatsContainer');
  if (!container) return;
  
  if (!currentUser) {
    container.innerHTML = `
      <div class="user-stats-content">
        <div class="sign-in-prompt">
          <span>üîí</span>
          <a href="signin.html">Sign in</a> to track your stats across devices
        </div>
      </div>
    `;
    return;
  }
  
  // Load from Firebase first, merge with localStorage for best data
  let stats;
  const firebaseStats = await loadStatsFromFirebase();
  const localStats = getLocalStats();
  
  if (firebaseStats === undefined) {
    // Firebase failed - use localStorage only
    stats = localStats;
  } else {
    stats = mergeStats(firebaseStats, localStats);
    
    // If we merged and got better data, sync it back
    if (firebaseStats && localStats) {
      const needsSync = stats.gamesPlayed > (firebaseStats.gamesPlayed || 0);
      if (needsSync) {
        console.log('Syncing better localStorage stats to Firebase');
        await saveStatsToFirebase(stats);
      }
    }
  }
  
  if (!stats) stats = getDefaultStats();
  
  const avgScore = stats.gamesPlayed > 0 ? Math.round(stats.totalScore / stats.gamesPlayed) : 0;
  
  container.innerHTML = `
    <div class="user-stats-content">
      <div class="user-greeting">üëã ${currentUser.displayName || 'Player'}</div>
      <div class="lifetime-stats">
        <div class="lifetime-stat">
          <span class="lifetime-value">${stats.gamesPlayed}</span>
          <span class="lifetime-label">Played</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${stats.perfectGames}</span>
          <span class="lifetime-label">Perfect</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${avgScore}</span>
          <span class="lifetime-label">Avg Score</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${stats.bestScore}</span>
          <span class="lifetime-label">Best</span>
        </div>
      </div>
    </div>
  `;
}

// ============================================
// AUTH STATE
// ============================================
function setupAuthListener() {
  onAuthChange(async (user) => {
    const wasLoggedOut = !currentUser;
    currentUser = user;
    
    if (user) {
      // User just signed in - migrate localStorage stats to Firebase if needed
      if (wasLoggedOut) {
        const localStats = getLocalStats();
        const firebaseStats = await loadStatsFromFirebase();
        
        if (localStats.gamesPlayed > 0 && (!firebaseStats || firebaseStats.gamesPlayed < localStats.gamesPlayed)) {
          console.log('Migrating localStorage stats to Firebase on sign-in');
          const merged = mergeStats(firebaseStats, localStats);
          await saveStatsToFirebase(merged);
        }
      }
      
      // Load game state from Firebase
      if (todaysPuzzle) {
        const firebaseHasState = await loadGameStateFirebase();
        if (firebaseHasState) {
          renderBasedOnPhase();
        }
      }
    }
    
    await updateUserStatsDisplay();
  });
}

function renderBasedOnPhase() {
  if (gameState.phase === 'pre') {
    renderPreGame();
  } else if (gameState.phase === 'playing') {
    // Game was in progress but page was closed - treat as finished
    gameState.phase = 'finished';
    renderFinished();
  } else if (gameState.phase === 'finished') {
    renderFinished();
  }
}

// ============================================
// SHARE
// ============================================
window.shareResults = function() {
  const found = gameState.foundPlayers.length;
  const total = todaysPuzzle.players.length;
  const pct = Math.round((found / total) * 100);
  
  const bars = [];
  for (let i = 0; i < 10; i++) {
    bars.push(i < Math.round(pct / 10) ? 'üü©' : '‚¨ú');
  }
  
  const text = `üß† Player Recall #${todaysPuzzle.dayNum}
${todaysPuzzle.categoryName}
${found}/${total} (${pct}%) | ${gameState.score} pts

${bars.join('')}

acessoftballreference.com/roster-recall.html`;
  
  if (navigator.share) {
    navigator.share({ text }).catch(() => copyToClipboard(text));
  } else {
    copyToClipboard(text);
  }
};

function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    showToast('Copied to clipboard!');
  }).catch(() => {
    showToast('Could not copy');
  });
}

function showToast(text) {
  const toast = document.getElementById('toast');
  toast.textContent = text;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 2000);
}

// ============================================
// HOW TO PLAY
// ============================================
window.toggleHowToPlay = function() {
  const section = document.getElementById('howToPlay');
  const toggle = document.getElementById('howToPlayToggle');
  section.classList.toggle('expanded');
  toggle.textContent = section.classList.contains('expanded') ? '‚ñ≤' : '‚ñº';
};

// ============================================
// INITIALIZATION
// ============================================
async function init() {
  try {
    // Check if before launch
    const launchDate = new Date(LAUNCH_YEAR, LAUNCH_MONTH, LAUNCH_DAY).setHours(0, 0, 0, 0);
    const now = new Date().setHours(0, 0, 0, 0);
    
    if (now < launchDate) {
      document.getElementById('loadingOverlay').classList.add('hidden');
      const launchDateObj = new Date(LAUNCH_YEAR, LAUNCH_MONTH, LAUNCH_DAY);
      document.getElementById('puzzleDate').textContent = `Launching ${launchDateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}`;
      document.getElementById('gameContent').innerHTML = `
        <div class="pre-game">
          <div style="font-size: 3rem; margin-bottom: 1rem;">‚è±Ô∏è</div>
          <h3 style="margin: 0;">Coming Soon!</h3>
        </div>
      `;
      return;
    }
    
    // Check for existing auth
    currentUser = getCurrentUser();
    
    // Load players
    console.log('Loading player data...');
    const rawPlayers = await getAllPlayerStatsOptimized();
    allPlayers = rawPlayers.filter(p => p.migrated !== true);
    playerNames = allPlayers.map(p => p.name || p.playerName).filter(Boolean);
    console.log(`Loaded ${allPlayers.length} players`);
    
    // Generate puzzle
    todaysPuzzle = generateDailyPuzzle();
    console.log('Today\'s puzzle:', todaysPuzzle.categoryName, `(${todaysPuzzle.players.length} players, ${todaysPuzzle.totalTime}s)`);
    
    // Display date
    const today = new Date();
    document.getElementById('puzzleDate').textContent = 
      `Puzzle #${todaysPuzzle.dayNum} ‚Ä¢ ${today.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' })}`;
    
    // Load saved state
    await loadGameState();
    
    // Setup
    setupAuthListener();
    await updateUserStatsDisplay();
    
    // Render based on state
    renderBasedOnPhase();
    
    // Hide loading
    document.getElementById('loadingOverlay').classList.add('hidden');
    
  } catch (error) {
    console.error('Error initializing game:', error);
    document.getElementById('loadingOverlay').innerHTML = `
      <div style="text-align: center; padding: 2rem;">
        <p>Error loading game</p>
        <p style="color: var(--text-light); font-size: 0.9rem;">${error.message}</p>
        <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.75rem 1.5rem; cursor: pointer;">Retry</button>
      </div>
    `;
  }
}

// Start
init();
</script>

<script type="module">
  import { NavigationComponent } from './nav-component.js';
</script>
<script src="mobile-enhancements.js"></script>
<script src="theme-toggle.js"></script>
</body>
</html>

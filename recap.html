<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Year in Review - Mountainside Aces</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
  :root {
    --primary-color: #2d5016;
    --secondary-color: #1a6b4a;
    --accent-color: #ffd700;
    --fall-color: #c45c26;
    --fall-secondary: #8b4513;
    --summer-color: #1e88e5;
    --summer-secondary: #0d47a1;
    --card-bg: #ffffff;
    --text-dark: #2d3748;
    --text-light: #718096;
    --border-color: #e2e8f0;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
    --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
    --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    min-height: 100vh;
    line-height: 1.6;
    color: var(--text-dark);
  }

  /* Loading Spinner */
  .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    transition: opacity 0.5s ease;
  }

  .loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .softball-spinner::before {
    content: '‚öæ';
    font-size: 80px;
    animation: spin 1.5s ease-in-out infinite;
  }

  @keyframes spin {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }

  /* Page Header */
  .page-header {
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    color: white;
    text-align: center;
    padding: 4rem 2rem;
    border-radius: 16px;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
  }

  .page-header::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -10%;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }

  .page-header::after {
    content: 'üèÜ';
    position: absolute;
    bottom: -20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 120px;
    opacity: 0.1;
  }

  .page-header h1 {
    margin: 0;
    font-size: 3rem;
    font-weight: 800;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    position: relative;
    z-index: 1;
  }

  .page-header p {
    margin: 1rem 0 0;
    font-size: 1.2rem;
    opacity: 0.9;
    position: relative;
    z-index: 1;
  }

  /* Year Navigation */
  .year-nav {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
  }

  .year-btn {
    padding: 0.75rem 1.5rem;
    border: 2px solid var(--primary-color);
    background: white;
    color: var(--primary-color);
    border-radius: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
  }

  .year-btn:hover, .year-btn.active {
    background: var(--primary-color);
    color: white;
  }

  /* Season Section */
  .season-section {
    background: var(--card-bg);
    border-radius: 16px;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-md);
    overflow: hidden;
    border: 1px solid var(--border-color);
  }

  .season-header {
    padding: 2rem;
    color: white;
    position: relative;
    overflow: hidden;
  }

  .season-header.fall {
    background: linear-gradient(135deg, var(--fall-color) 0%, var(--fall-secondary) 100%);
  }

  .season-header.summer {
    background: linear-gradient(135deg, var(--summer-color) 0%, var(--summer-secondary) 100%);
  }

  .season-header::after {
    position: absolute;
    right: 2rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 4rem;
    opacity: 0.2;
  }

  .season-header.fall::after {
    content: 'üçÇ';
  }

  .season-header.summer::after {
    content: '‚òÄÔ∏è';
  }

  .season-header h2 {
    margin: 0;
    font-size: 2rem;
    font-weight: 800;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .season-content {
    padding: 2rem;
  }

  /* Champion Banner */
  .champion-banner {
    background: linear-gradient(135deg, #ffd700 0%, #ffb300 100%);
    border-radius: 12px;
    padding: 1.5rem 2rem;
    margin-bottom: 2rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    box-shadow: var(--shadow-sm);
  }

  .champion-trophy {
    font-size: 3rem;
  }

  .champion-info h3 {
    margin: 0;
    font-size: 1.1rem;
    color: #5d4e00;
    font-weight: 600;
  }

  .champion-team {
    margin: 0;
    font-size: 1.75rem;
    font-weight: 800;
    color: #3d3200;
  }

  /* Subsection */
  .subsection {
    margin-bottom: 2rem;
  }

  .subsection:last-child {
    margin-bottom: 0;
  }

  .subsection-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--border-color);
  }

  .subsection-header h3 {
    margin: 0;
    font-size: 1.25rem;
    color: var(--text-dark);
  }

  /* Standings Table */
  .standings-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.95rem;
  }

  .standings-table th {
    background: var(--primary-color);
    color: white;
    padding: 0.75rem;
    text-align: center;
    font-weight: 600;
  }

  .standings-table th:first-child,
  .standings-table td:first-child {
    text-align: left;
    padding-left: 1rem;
  }

  .standings-table td {
    padding: 0.75rem;
    text-align: center;
    border-bottom: 1px solid var(--border-color);
  }

  .standings-table tr:hover {
    background: #f8f9fa;
  }

  .standings-table .champion-row {
    background: linear-gradient(90deg, #fff9e6 0%, #ffffff 100%);
  }

  .standings-table .champion-row td:first-child::before {
    content: 'üèÜ ';
  }

  /* Leaders Grid */
  .leaders-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
  }

  .leader-card {
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
    border-radius: 12px;
    padding: 1.25rem;
    text-align: center;
    border-left: 4px solid var(--primary-color);
    transition: transform 0.2s ease;
  }

  .leader-card:hover {
    transform: translateY(-2px);
  }

  .leader-category {
    font-size: 0.8rem;
    color: var(--text-light);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0.5rem;
  }

  .leader-name {
    font-size: 1rem;
    font-weight: 700;
    color: var(--text-dark);
    margin-bottom: 0.25rem;
  }

  .leader-name a {
    color: inherit;
    text-decoration: none;
  }

  .leader-name a:hover {
    color: var(--primary-color);
  }

  .leader-value {
    font-size: 1.5rem;
    font-weight: 800;
    color: var(--primary-color);
  }

  /* Awards Grid */
  .awards-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
  }

  .award-card {
    background: linear-gradient(135deg, #fffde7 0%, #ffffff 100%);
    border-radius: 12px;
    padding: 1.25rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    border: 1px solid #ffe082;
  }

  .award-icon {
    font-size: 2rem;
  }

  .award-info {
    flex: 1;
  }

  .award-category {
    font-size: 0.85rem;
    color: var(--text-light);
    margin-bottom: 0.25rem;
  }

  .award-winner {
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--text-dark);
  }

  .award-winner a {
    color: inherit;
    text-decoration: none;
  }

  .award-winner a:hover {
    color: var(--primary-color);
  }

  .award-value {
    font-size: 0.9rem;
    color: var(--text-light);
  }

  /* Rookies List */
  .rookies-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .rookie-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, #e8f5e9 0%, #ffffff 100%);
    border-radius: 10px;
    border-left: 4px solid var(--secondary-color);
  }

  .rookie-rank {
    font-size: 1.5rem;
    font-weight: 800;
    color: var(--secondary-color);
    min-width: 2rem;
  }

  .rookie-info {
    flex: 1;
  }

  .rookie-name {
    font-weight: 700;
    color: var(--text-dark);
  }

  .rookie-name a {
    color: inherit;
    text-decoration: none;
  }

  .rookie-name a:hover {
    color: var(--primary-color);
  }

  .rookie-stats {
    font-size: 0.9rem;
    color: var(--text-light);
  }

  .rookie-bpi {
    font-weight: 700;
    color: var(--primary-color);
    font-size: 1.1rem;
  }

  /* Pitching Leaders */
  .pitching-leaders {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
  }

  /* Empty State */
  .empty-state {
    text-align: center;
    padding: 2rem;
    color: var(--text-light);
    font-style: italic;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .container {
      padding: 1rem;
    }

    .page-header {
      padding: 2rem 1rem;
    }

    .page-header h1 {
      font-size: 2rem;
    }

    .season-header h2 {
      font-size: 1.5rem;
    }

    .season-content {
      padding: 1.5rem;
    }

    .champion-banner {
      flex-direction: column;
      text-align: center;
    }

    .standings-table {
      font-size: 0.85rem;
      display: block;
      overflow-x: auto;
    }

    .leaders-grid {
      grid-template-columns: repeat(2, 1fr);
    }

    .awards-grid {
      grid-template-columns: 1fr;
    }
  }

  @media (max-width: 480px) {
    .leaders-grid {
      grid-template-columns: 1fr;
    }
  }
</style>
</head>
<body>

<!-- Navigation Component -->
<nav-component></nav-component>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="softball-spinner"></div>
</div>

<div class="container">
  <!-- Page Header -->
  <div class="page-header">
    <h1 id="pageTitle">Year in Review</h1>
    <p id="pageSubtitle">Loading...</p>
  </div>

  <!-- Year Navigation -->
  <div class="year-nav" id="yearNav">
    <!-- Populated dynamically -->
  </div>

  <!-- Season Sections Container -->
  <div id="seasonsContainer">
    <!-- Fall and Summer sections will be inserted here -->
  </div>
</div>

<script type="module">
  import { NavigationComponent } from './nav-component.js';
  import {
    getSeasonGames,
    getSeasonPlayerStatsOptimized,
    getSeasonPitchingStatsOptimized,
    getSeasonAwards,
    getAllPlayerStatsOptimized,
    getAllSeasons,
    db,
    doc,
    getDoc
  } from './firebase-data.js';
  import { collection, getDocs } from './firebase-config.js';

  // Global state
  let currentYear = null;
  let allSeasons = [];
  let allPlayers = [];

  // Initialize page
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      // Get year from URL or siteConfig
      const urlParams = new URLSearchParams(window.location.search);
      let year = urlParams.get('year');
      
      if (!year) {
        // Try to get default year from siteConfig
        try {
          const recapConfigRef = doc(db, 'siteConfig', 'navigation', 'pages', 'recap');
          const recapConfigSnap = await getDoc(recapConfigRef);
          if (recapConfigSnap.exists()) {
            const configData = recapConfigSnap.data();
            year = configData.year?.toString();
          }
        } catch (e) {
          console.log('Could not fetch recap config, using current year');
        }
      }
      
      // Default to current year if still not set
      if (!year) {
        year = new Date().getFullYear().toString();
      }
      
      currentYear = parseInt(year);
      
      // Load all seasons and players for context
      [allSeasons, allPlayers] = await Promise.all([
        getAllSeasons(),
        getAllPlayerStatsOptimized()
      ]);
      
      // Build year navigation
      buildYearNav();
      
      // Load the recap data
      await loadYearRecap(currentYear);
      
      // Hide loading overlay
      document.getElementById('loadingOverlay').classList.add('hidden');
      
    } catch (error) {
      console.error('Error initializing recap page:', error);
      document.getElementById('seasonsContainer').innerHTML = `
        <div class="empty-state">
          <p>Error loading recap data. Please try again later.</p>
        </div>
      `;
      document.getElementById('loadingOverlay').classList.add('hidden');
    }
  });

  function buildYearNav() {
    const navContainer = document.getElementById('yearNav');
    
    // Get unique years from seasons
    const years = [...new Set(allSeasons.map(s => {
      const parts = s.id.split('-');
      return parseInt(parts[0]);
    }))].sort((a, b) => b - a);
    
    navContainer.innerHTML = years.map(year => `
      <a href="?year=${year}" class="year-btn ${year === currentYear ? 'active' : ''}">${year}</a>
    `).join('');
  }

  async function loadYearRecap(year) {
    const container = document.getElementById('seasonsContainer');
    container.innerHTML = '<div class="empty-state">Loading recap data...</div>';
    
    // Update header
    document.getElementById('pageTitle').textContent = `${year} Year in Review`;
    document.getElementById('pageSubtitle').textContent = `Celebrating the achievements of the ${year} Mountainside Aces seasons`;
    document.title = `${year} Year in Review - Mountainside Aces`;
    
    const fallSeasonId = `${year}-fall`;
    const summerSeasonId = `${year}-summer`;
    
    // Check which seasons exist
    const fallExists = allSeasons.some(s => s.id === fallSeasonId);
    const summerExists = allSeasons.some(s => s.id === summerSeasonId);
    
    let html = '';
    
    // Load Fall Season (displayed first)
    if (fallExists) {
      html += await buildSeasonSection(fallSeasonId, 'fall', year, false);
    }
    
    // Load Summer Season
    if (summerExists) {
      html += await buildSeasonSection(summerSeasonId, 'summer', year, true);
    }
    
    if (!fallExists && !summerExists) {
      html = `<div class="empty-state"><p>No season data found for ${year}.</p></div>`;
    }
    
    container.innerHTML = html;
  }

  async function buildSeasonSection(seasonId, seasonType, year, includeAwards) {
    const seasonLabel = seasonType.charAt(0).toUpperCase() + seasonType.slice(1);
    const emoji = seasonType === 'fall' ? 'üçÇ' : '‚òÄÔ∏è';
    
    try {
      // Fetch all season data in parallel
      const [games, battingStats, pitchingStats, awards] = await Promise.all([
        getSeasonGames(seasonId),
        getSeasonPlayerStatsOptimized(seasonId),
        getSeasonPitchingStatsOptimized(seasonId),
        includeAwards ? getSeasonAwards(seasonId) : Promise.resolve([])
      ]);
      
      // Calculate standings
      const standings = calculateStandings(games);
      
      // Find champion (first place in standings or from playoff data)
      const champion = findChampion(games, standings);
      
      // Get season leaders
      const battingLeaders = calculateBattingLeaders(battingStats);
      const pitchingLeaders = calculatePitchingLeaders(pitchingStats);
      
      // Get top rookies for this season
      const rookies = findSeasonRookies(seasonId, battingStats);
      
      return `
        <div class="season-section">
          <div class="season-header ${seasonType}">
            <h2>${emoji} ${seasonLabel.toUpperCase()} ${year}</h2>
          </div>
          <div class="season-content">
            ${champion ? `
              <div class="champion-banner">
                <div class="champion-trophy">üèÜ</div>
                <div class="champion-info">
                  <h3>SEASON CHAMPION</h3>
                  <p class="champion-team">${champion}</p>
                </div>
              </div>
            ` : ''}
            
            <!-- Final Standings -->
            <div class="subsection">
              <div class="subsection-header">
                <h3>üìä Final Standings</h3>
              </div>
              ${renderStandingsTable(standings, champion)}
            </div>
            
            ${includeAwards && awards.length > 0 ? `
              <!-- Awards (Summer Only) -->
              <div class="subsection">
                <div class="subsection-header">
                  <h3>üèÖ Season Awards</h3>
                </div>
                ${renderAwards(awards)}
              </div>
            ` : ''}
            
            <!-- Season Leaders - Batting -->
            <div class="subsection">
              <div class="subsection-header">
                <h3>‚öæ Batting Leaders</h3>
              </div>
              ${renderBattingLeaders(battingLeaders)}
            </div>
            
            <!-- Season Leaders - Pitching -->
            <div class="subsection">
              <div class="subsection-header">
                <h3>üéØ Pitching Leaders</h3>
              </div>
              ${renderPitchingLeaders(pitchingLeaders)}
            </div>
            
            <!-- Top Rookies -->
            <div class="subsection">
              <div class="subsection-header">
                <h3>üåü Top 5 Rookies</h3>
              </div>
              ${renderRookies(rookies)}
            </div>
          </div>
        </div>
      `;
    } catch (error) {
      console.error(`Error loading ${seasonId}:`, error);
      return `
        <div class="season-section">
          <div class="season-header ${seasonType}">
            <h2>${emoji} ${seasonLabel.toUpperCase()} ${year}</h2>
          </div>
          <div class="season-content">
            <div class="empty-state">Error loading season data.</div>
          </div>
        </div>
      `;
    }
  }

  function calculateStandings(games) {
    const teams = {};
    
    // Filter to regular season games only
    const regularGames = games.filter(g => {
      const gameType = (g.gameType || g.game_type || '').toLowerCase();
      return gameType !== 'playoff';
    });
    
    regularGames.forEach(game => {
      const homeTeam = game.homeTeamName || game.homeTeam || game['home team'];
      const awayTeam = game.awayTeamName || game.awayTeam || game['away team'];
      const winner = game.winner;
      
      if (!homeTeam || !awayTeam) return;
      
      // Initialize teams
      if (!teams[homeTeam]) {
        teams[homeTeam] = { name: homeTeam, wins: 0, losses: 0, ties: 0, runsFor: 0, runsAgainst: 0, gamesPlayed: 0 };
      }
      if (!teams[awayTeam]) {
        teams[awayTeam] = { name: awayTeam, wins: 0, losses: 0, ties: 0, runsFor: 0, runsAgainst: 0, gamesPlayed: 0 };
      }
      
      // Only count completed games
      if (winner && winner.trim() !== '') {
        teams[homeTeam].gamesPlayed++;
        teams[awayTeam].gamesPlayed++;
        
        const homeScore = parseInt(game.homeScore || game['home score']) || 0;
        const awayScore = parseInt(game.awayScore || game['away score']) || 0;
        
        teams[homeTeam].runsFor += homeScore;
        teams[homeTeam].runsAgainst += awayScore;
        teams[awayTeam].runsFor += awayScore;
        teams[awayTeam].runsAgainst += homeScore;
        
        const winnerLower = winner.toLowerCase();
        const homeLower = homeTeam.toLowerCase();
        const awayLower = awayTeam.toLowerCase();
        
        if (winnerLower === 'tie') {
          teams[homeTeam].ties++;
          teams[awayTeam].ties++;
        } else if (winnerLower === homeLower) {
          teams[homeTeam].wins++;
          teams[awayTeam].losses++;
        } else if (winnerLower === awayLower) {
          teams[awayTeam].wins++;
          teams[homeTeam].losses++;
        }
      }
    });
    
    // Convert to array and calculate percentages
    const standings = Object.values(teams).map(team => {
      const decidedGames = team.wins + team.losses;
      return {
        ...team,
        winPct: decidedGames > 0 ? team.wins / decidedGames : 0,
        runDiff: team.runsFor - team.runsAgainst
      };
    });
    
    // Sort by win percentage, then by wins
    standings.sort((a, b) => {
      if (b.winPct !== a.winPct) return b.winPct - a.winPct;
      return b.wins - a.wins;
    });
    
    return standings;
  }

  function findChampion(games, standings) {
    // First, try to find from playoff championship game
    const playoffGames = games.filter(g => {
      const gameType = (g.gameType || g.game_type || '').toLowerCase();
      return gameType === 'playoff';
    });
    
    if (playoffGames.length > 0) {
      // Find the last playoff game with a winner (championship)
      const completedPlayoffs = playoffGames.filter(g => g.winner && g.winner.trim() !== '');
      if (completedPlayoffs.length > 0) {
        // Sort by date descending to get the final game
        completedPlayoffs.sort((a, b) => {
          const dateA = new Date(a.date || a.gameDate);
          const dateB = new Date(b.date || b.gameDate);
          return dateB - dateA;
        });
        return completedPlayoffs[0].winner;
      }
    }
    
    // Fallback: first place in standings
    if (standings.length > 0) {
      return standings[0].name;
    }
    
    return null;
  }

  function calculateBattingLeaders(battingStats) {
    if (!battingStats || battingStats.length === 0) return null;
    
    // Filter players with minimum at-bats for rate stats
    const qualifiedForRate = battingStats.filter(p => (p.atBats || 0) >= 20);
    
    // Calculate BA and OBP for each player
    const withCalculatedStats = battingStats.map(p => ({
      ...p,
      ba: p.atBats > 0 ? p.hits / p.atBats : 0,
      obp: (p.atBats + p.walks) > 0 ? (p.hits + p.walks) / (p.atBats + p.walks) : 0,
      acesBPI: p.acesBPI || 0
    }));
    
    const qualifiedWithStats = qualifiedForRate.map(p => ({
      ...p,
      ba: p.atBats > 0 ? p.hits / p.atBats : 0,
      obp: (p.atBats + p.walks) > 0 ? (p.hits + p.walks) / (p.atBats + p.walks) : 0,
      acesBPI: p.acesBPI || 0
    }));
    
    return {
      ba: qualifiedWithStats.length > 0 ? 
        [...qualifiedWithStats].sort((a, b) => b.ba - a.ba)[0] : null,
      hits: [...withCalculatedStats].sort((a, b) => (b.hits || 0) - (a.hits || 0))[0] || null,
      runs: [...withCalculatedStats].sort((a, b) => (b.runs || 0) - (a.runs || 0))[0] || null,
      walks: [...withCalculatedStats].sort((a, b) => (b.walks || 0) - (a.walks || 0))[0] || null,
      obp: qualifiedWithStats.length > 0 ?
        [...qualifiedWithStats].sort((a, b) => b.obp - a.obp)[0] : null,
      acesBPI: qualifiedWithStats.length > 0 ?
        [...qualifiedWithStats].sort((a, b) => b.acesBPI - a.acesBPI)[0] : null
    };
  }

  function calculatePitchingLeaders(pitchingStats) {
    if (!pitchingStats || pitchingStats.length === 0) return null;
    
    // Filter pitchers with minimum innings
    const qualified = pitchingStats.filter(p => (p.inningsPitched || p.IP || 0) >= 5);
    
    if (qualified.length === 0) return null;
    
    const withStats = qualified.map(p => ({
      ...p,
      era: p.earnedRunAverage || p.era || p.ERA || 0,
      ip: p.inningsPitched || p.IP || 0
    }));
    
    return {
      era: [...withStats].sort((a, b) => a.era - b.era)[0] || null,
      innings: [...pitchingStats].map(p => ({
        ...p,
        ip: p.inningsPitched || p.IP || 0
      })).sort((a, b) => b.ip - a.ip)[0] || null
    };
  }

  function findSeasonRookies(seasonId, battingStats) {
    // A rookie is a player whose first season in aggregatedPlayerStats matches this season
    const rookies = [];
    
    // For each player in battingStats (players who played this season)
    battingStats.forEach(playerStats => {
      const playerName = playerStats.name;
      if (!playerName) return;
      
      // Find this player in allPlayers to check their full history
      const fullPlayerData = allPlayers.find(p => 
        (p.name === playerName || p.displayName === playerName) && !p.migrated
      );
      
      if (!fullPlayerData || !fullPlayerData.seasons) return;
      
      const seasonKeys = Object.keys(fullPlayerData.seasons);
      if (seasonKeys.length === 0) return;
      
      // Sort season keys chronologically
      // Keys are like "2025-fall-orange", "2024-summer-blue"
      seasonKeys.sort((a, b) => {
        const partsA = a.split('-');
        const partsB = b.split('-');
        const yearA = parseInt(partsA[0]);
        const yearB = parseInt(partsB[0]);
        
        if (yearA !== yearB) return yearA - yearB;
        
        // Summer comes before Fall in the same year
        const seasonA = partsA[1];
        const seasonB = partsB[1];
        if (seasonA === 'summer' && seasonB === 'fall') return -1;
        if (seasonA === 'fall' && seasonB === 'summer') return 1;
        return 0;
      });
      
      // Check if first season matches current season
      const firstSeasonKey = seasonKeys[0];
      if (firstSeasonKey.startsWith(seasonId)) {
        rookies.push({
          name: playerName,
          id: fullPlayerData.id || playerName.toLowerCase().replace(/\s+/g, '_'),
          games: playerStats.games || 0,
          hits: playerStats.hits || 0,
          runs: playerStats.runs || 0,
          ba: playerStats.atBats > 0 ? (playerStats.hits / playerStats.atBats) : 0,
          acesBPI: playerStats.acesBPI || 0
        });
      }
    });
    
    // Sort by AcesBPI and take top 5
    return rookies
      .sort((a, b) => b.acesBPI - a.acesBPI)
      .slice(0, 5);
  }

  function renderStandingsTable(standings, champion) {
    if (!standings || standings.length === 0) {
      return '<div class="empty-state">No standings data available.</div>';
    }
    
    const championLower = champion ? champion.toLowerCase() : '';
    
    return `
      <div style="overflow-x: auto;">
        <table class="standings-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Team</th>
              <th>W</th>
              <th>L</th>
              <th>T</th>
              <th>Win%</th>
              <th>RF</th>
              <th>RA</th>
              <th>Diff</th>
            </tr>
          </thead>
          <tbody>
            ${standings.map((team, index) => `
              <tr class="${team.name.toLowerCase() === championLower ? 'champion-row' : ''}">
                <td>${index + 1}</td>
                <td>${team.name}</td>
                <td>${team.wins}</td>
                <td>${team.losses}</td>
                <td>${team.ties}</td>
                <td>${team.winPct.toFixed(3)}</td>
                <td>${team.runsFor}</td>
                <td>${team.runsAgainst}</td>
                <td style="color: ${team.runDiff >= 0 ? '#22c55e' : '#ef4444'}">
                  ${team.runDiff >= 0 ? '+' : ''}${team.runDiff}
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;
  }

  function renderAwards(awards) {
    if (!awards || awards.length === 0) {
      return '<div class="empty-state">No awards data available.</div>';
    }
    
    const awardIcons = {
      'MVP': 'üèÜ',
      'Batting Champion': 'ü•á',
      'Batting Title': 'ü•á',
      'Home Run Champion': 'üí™',
      'RBI Leader': 'üìä',
      'Cy Young': '‚öæ',
      'Rookie of the Year': 'üåü',
      'Gold Glove': 'üß§',
      'default': 'üèÖ'
    };
    
    return `
      <div class="awards-grid">
        ${awards.map(award => `
          <div class="award-card">
            <div class="award-icon">${awardIcons[award.category] || awardIcons.default}</div>
            <div class="award-info">
              <div class="award-category">${award.category}</div>
              <div class="award-winner">
                <a href="player.html?id=${encodeURIComponent(award.playerName?.toLowerCase().replace(/\s+/g, '_') || '')}">${award.playerName}</a>
              </div>
              ${award.value ? `<div class="award-value">${award.value}</div>` : ''}
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }

  function renderBattingLeaders(leaders) {
    if (!leaders) {
      return '<div class="empty-state">No batting data available.</div>';
    }
    
    const categories = [
      { key: 'ba', label: 'Batting Average', format: v => v.ba.toFixed(3) },
      { key: 'hits', label: 'Hits', format: v => v.hits },
      { key: 'runs', label: 'Runs', format: v => v.runs },
      { key: 'walks', label: 'Walks', format: v => v.walks },
      { key: 'obp', label: 'On-Base %', format: v => v.obp.toFixed(3) },
      { key: 'acesBPI', label: 'AcesBPI', format: v => v.acesBPI.toFixed(2) }
    ];
    
    return `
      <div class="leaders-grid">
        ${categories.map(cat => {
          const leader = leaders[cat.key];
          if (!leader) return '';
          return `
            <div class="leader-card">
              <div class="leader-category">${cat.label}</div>
              <div class="leader-name">
                <a href="player.html?id=${encodeURIComponent(leader.playerId || leader.name?.toLowerCase().replace(/\s+/g, '_') || '')}">${leader.name}</a>
              </div>
              <div class="leader-value">${cat.format(leader)}</div>
            </div>
          `;
        }).join('')}
      </div>
    `;
  }

  function renderPitchingLeaders(leaders) {
    if (!leaders) {
      return '<div class="empty-state">No pitching data available.</div>';
    }
    
    return `
      <div class="pitching-leaders">
        ${leaders.era ? `
          <div class="leader-card">
            <div class="leader-category">ERA</div>
            <div class="leader-name">
              <a href="player.html?id=${encodeURIComponent(leaders.era.playerId || leaders.era.name?.toLowerCase().replace(/\s+/g, '_') || '')}">${leaders.era.name}</a>
            </div>
            <div class="leader-value">${leaders.era.era.toFixed(2)}</div>
          </div>
        ` : ''}
        ${leaders.innings ? `
          <div class="leader-card">
            <div class="leader-category">Innings Pitched</div>
            <div class="leader-name">
              <a href="player.html?id=${encodeURIComponent(leaders.innings.playerId || leaders.innings.name?.toLowerCase().replace(/\s+/g, '_') || '')}">${leaders.innings.name}</a>
            </div>
            <div class="leader-value">${leaders.innings.ip.toFixed(1)}</div>
          </div>
        ` : ''}
      </div>
    `;
  }

  function renderRookies(rookies) {
    if (!rookies || rookies.length === 0) {
      return '<div class="empty-state">No rookie data available for this season.</div>';
    }
    
    return `
      <div class="rookies-list">
        ${rookies.map((rookie, index) => `
          <div class="rookie-item">
            <div class="rookie-rank">${index + 1}</div>
            <div class="rookie-info">
              <div class="rookie-name">
                <a href="player.html?id=${encodeURIComponent(rookie.id || rookie.name?.toLowerCase().replace(/\s+/g, '_') || '')}">${rookie.name}</a>
              </div>
              <div class="rookie-stats">
                ${rookie.games}G ‚Ä¢ ${rookie.hits}H ‚Ä¢ ${rookie.runs}R ‚Ä¢ ${rookie.ba.toFixed(3)} BA
              </div>
            </div>
            <div class="rookie-bpi">${rookie.acesBPI.toFixed(2)} BPI</div>
          </div>
        `).join('')}
      </div>
    `;
  }
</script>

<script src="team-colors.js"></script>
<script src="mobile-enhancements.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<link rel="manifest" href="/manifest.json">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Year in Review - Mountainside Aces</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
  :root {
    --primary-color: #2d5016;
    --secondary-color: #1a6b4a;
    --accent-color: #ffd700;
    --fall-color: #c45c26;
    --fall-secondary: #8b4513;
    --summer-color: #1e88e5;
    --summer-secondary: #0d47a1;
    --card-bg: #ffffff;
    --text-dark: #2d3748;
    --text-light: #718096;
    --border-color: #e2e8f0;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
    --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
    --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    min-height: 100vh;
    line-height: 1.6;
    color: var(--text-dark);
  }

  /* Loading Spinner */
  .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    transition: opacity 0.5s ease;
  }

  .loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .softball-spinner::before {
    content: '‚öæ';
    font-size: 80px;
    animation: spin 1.5s ease-in-out infinite;
  }

  @keyframes spin {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
  }

  .page-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }

  /* Page Header */
  .page-header {
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    color: white;
    text-align: center;
    padding: 4rem 2rem;
    border-radius: 16px;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
  }

  .page-header::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -10%;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }

  .page-header::after {
    content: 'üèÜ';
    position: absolute;
    bottom: -20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 120px;
    opacity: 0.1;
  }

  .page-header h1 {
    margin: 0;
    font-size: 3rem;
    font-weight: 800;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    position: relative;
    z-index: 1;
  }

  .page-header p {
    margin: 1rem 0 0;
    font-size: 1.2rem;
    opacity: 0.9;
    position: relative;
    z-index: 1;
  }

  /* Year Navigation */
  .year-nav {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
  }

  .year-btn {
    padding: 0.75rem 1.5rem;
    border: 2px solid var(--primary-color);
    background: white;
    color: var(--primary-color);
    border-radius: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
  }

  .year-btn:hover, .year-btn.active {
    background: var(--primary-color);
    color: white;
  }

  /* Season Section */
  .season-section {
    background: var(--card-bg);
    border-radius: 16px;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-md);
    overflow: hidden;
    border: 1px solid var(--border-color);
  }

  .season-header {
    padding: 2rem;
    color: white;
    position: relative;
    overflow: hidden;
  }

  .season-header.fall {
    background: linear-gradient(135deg, var(--fall-color) 0%, var(--fall-secondary) 100%);
  }

  .season-header.summer {
    background: linear-gradient(135deg, var(--summer-color) 0%, var(--summer-secondary) 100%);
  }

  .season-header::after {
    position: absolute;
    right: 2rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 4rem;
    opacity: 0.2;
  }

  .season-header.fall::after {
    content: 'üçÇ';
  }

  .season-header.summer::after {
    content: '‚òÄÔ∏è';
  }

  .season-header h2 {
    margin: 0;
    font-size: 2rem;
    font-weight: 800;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .season-content {
    padding: 2rem;
  }

  /* Champion Banner */
  .champion-banner {
    background: linear-gradient(135deg, #ffd700 0%, #ffb300 100%);
    border-radius: 12px;
    padding: 1.5rem 2rem;
    margin-bottom: 2rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    box-shadow: var(--shadow-sm);
  }

  .champion-trophy {
    font-size: 3rem;
  }

  .champion-info h3 {
    margin: 0;
    font-size: 1.1rem;
    color: #5d4e00;
    font-weight: 600;
  }

  .champion-team {
    margin: 0;
    font-size: 1.75rem;
    font-weight: 800;
    color: #3d3200;
  }

  /* Subsection */
  .subsection {
    margin-bottom: 2rem;
  }

  .subsection:last-child {
    margin-bottom: 0;
  }

  .subsection-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--border-color);
  }

  .subsection-header h3 {
    margin: 0;
    font-size: 1.25rem;
    color: var(--text-dark);
  }

  /* Standings Table */
  .standings-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.95rem;
  }

  .standings-table th {
    background: var(--primary-color);
    color: white;
    padding: 0.75rem;
    text-align: center;
    font-weight: 600;
  }

  .standings-table th:first-child,
  .standings-table td:first-child {
    text-align: left;
    padding-left: 1rem;
  }

  .standings-table td {
    padding: 0.75rem;
    text-align: center;
    border-bottom: 1px solid var(--border-color);
  }

  .standings-table tr:hover {
    background: #f8f9fa;
  }

  .standings-table .champion-row {
    background: linear-gradient(90deg, #fff9e6 0%, #ffffff 100%);
  }

  .standings-table .champion-row td:first-child::before {
    content: 'üèÜ ';
  }

  /* Leaders Grid */
  .leaders-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
  }

  .leader-card {
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
    border-radius: 12px;
    padding: 1.25rem;
    text-align: center;
    border-left: 4px solid var(--primary-color);
    transition: transform 0.2s ease;
  }

  .leader-card:hover {
    transform: translateY(-2px);
  }

  .leader-category {
    font-size: 0.8rem;
    color: var(--text-light);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0.5rem;
  }

  .leader-name {
    font-size: 1rem;
    font-weight: 700;
    color: var(--text-dark);
    margin-bottom: 0.25rem;
  }

  .leader-name a {
    color: inherit;
    text-decoration: none;
  }

  .leader-name a:hover {
    color: var(--primary-color);
  }

  .leader-value {
    font-size: 1.5rem;
    font-weight: 800;
    color: var(--primary-color);
  }

  /* Awards Grid */
  .awards-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
  }

  .award-card {
    background: linear-gradient(135deg, #fffde7 0%, #ffffff 100%);
    border-radius: 12px;
    padding: 1.25rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    border: 1px solid #ffe082;
  }

  .award-icon {
    font-size: 2rem;
    min-width: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .award-icon-img {
    width: 60px;
    height: 60px;
    object-fit: contain;
  }

  .fallback-emoji {
    font-size: 2rem;
  }

  .award-info {
    flex: 1;
  }

  .award-category {
    font-size: 0.85rem;
    color: var(--text-light);
    margin-bottom: 0.25rem;
  }

  .award-winner {
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--text-dark);
  }

  .award-winner a {
    color: inherit;
    text-decoration: none;
  }

  .award-winner a:hover {
    color: var(--primary-color);
  }

  .award-value {
    font-size: 0.9rem;
    color: var(--text-light);
  }

  /* Rookies List */
  .rookies-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .rookie-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, #e8f5e9 0%, #ffffff 100%);
    border-radius: 10px;
    border-left: 4px solid var(--secondary-color);
  }

  .rookie-rank {
    font-size: 1.5rem;
    font-weight: 800;
    color: var(--secondary-color);
    min-width: 2rem;
  }

  .rookie-info {
    flex: 1;
  }

  .rookie-name {
    font-weight: 700;
    color: var(--text-dark);
  }

  .rookie-name a {
    color: inherit;
    text-decoration: none;
  }

  .rookie-name a:hover {
    color: var(--primary-color);
  }

  .rookie-stats {
    font-size: 0.9rem;
    color: var(--text-light);
  }

  .rookie-bpi {
    font-weight: 700;
    color: var(--primary-color);
    font-size: 1.1rem;
  }

  /* Pitching Leaders */
  .pitching-leaders {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
  }

  /* Empty State */
  .empty-state {
    text-align: center;
    padding: 2rem;
    color: var(--text-light);
    font-style: italic;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .page-container {
      padding: 1rem;
    }

    .page-header {
      padding: 2rem 1rem;
    }

    .page-header h1 {
      font-size: 2rem;
    }

    .season-header h2 {
      font-size: 1.5rem;
    }

    .season-content {
      padding: 1.5rem;
    }

    .champion-banner {
      flex-direction: column;
      text-align: center;
    }

    .standings-table {
      font-size: 0.85rem;
      display: block;
      overflow-x: auto;
    }

    .leaders-grid {
      grid-template-columns: repeat(2, 1fr);
    }

    .awards-grid {
      grid-template-columns: 1fr;
    }
  }

  @media (max-width: 480px) {
    .leaders-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Eulogies Section */
  .eulogies-section {
    margin-top: 2rem;
    border-top: 2px solid var(--border-color);
    padding-top: 2rem;
  }

  .eulogies-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--border-color);
  }

  .eulogies-header-image {
    width: 120px;
    height: 120px;
    object-fit: contain;
  }

  .eulogies-header h3 {
    margin: 0;
    font-size: 1.25rem;
    color: var(--text-dark);
  }

  .eulogies-header-subtitle {
    font-size: 0.9rem;
    color: var(--text-light);
    font-style: italic;
    margin: 0;
  }

  @media (min-width: 769px) {
    .eulogies-header-image {
      width: 150px;
      height: 150px;
    }
  }

  .eulogies-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .eulogy-card {
    background: linear-gradient(135deg, #f5f5f5 0%, #ffffff 100%);
    border-radius: 12px;
    border: 1px solid var(--border-color);
    overflow: hidden;
    transition: box-shadow 0.3s ease;
  }

  .eulogy-card:hover {
    box-shadow: var(--shadow-md);
  }

  .eulogy-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    cursor: pointer;
    background: linear-gradient(135deg, #4a4a4a 0%, #2d2d2d 100%);
    color: white;
    user-select: none;
  }

  .eulogy-header:hover {
    background: linear-gradient(135deg, #5a5a5a 0%, #3d3d3d 100%);
  }

  .eulogy-header.champion {
    background: linear-gradient(135deg, #ffd700 0%, #b8860b 100%);
    color: #3d3200;
  }

  .eulogy-header.champion:hover {
    background: linear-gradient(135deg, #ffe033 0%, #daa520 100%);
  }

  .eulogy-header.champion .eulogy-round {
    opacity: 0.7;
  }

  .eulogy-team-info {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .eulogy-tombstone {
    font-size: 1.5rem;
  }

  .eulogy-team-name {
    font-weight: 700;
    font-size: 1.1rem;
  }

  .eulogy-round {
    font-size: 0.85rem;
    opacity: 0.8;
    font-weight: 400;
  }

  .eulogy-toggle {
    font-size: 1.25rem;
    transition: transform 0.3s ease;
  }

  .eulogy-card.expanded .eulogy-toggle {
    transform: rotate(180deg);
  }

  .eulogy-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.4s ease-out;
  }

  .eulogy-card.expanded .eulogy-content {
    max-height: 2000px;
    transition: max-height 0.6s ease-in;
  }

  .eulogy-text {
    padding: 1.5rem;
    font-size: 1rem;
    line-height: 1.8;
    color: var(--text-dark);
    white-space: pre-wrap;
    border-top: 1px solid var(--border-color);
  }

  .eulogy-text p {
    margin: 0 0 1rem 0;
  }

  .eulogy-text p:last-child {
    margin-bottom: 0;
  }

  @media (max-width: 768px) {
    .eulogies-header-image {
      width: 100px;
      height: 100px;
    }

    .eulogy-header {
      padding: 0.875rem 1rem;
    }

    .eulogy-team-name {
      font-size: 1rem;
    }

    .eulogy-text {
      padding: 1rem;
      font-size: 0.95rem;
    }
  }

  /* Milestone Crossings Section */
  .milestones-section {
    margin-top: 2rem;
    padding-top: 1.5rem;
    border-top: 2px dashed var(--border-color);
  }

  .milestones-section-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    text-align: center;
  }

  .milestones-section-header h3 {
    margin: 0;
    font-size: 1.25rem;
    color: var(--text-dark);
  }

  .milestones-section-subtitle {
    font-size: 0.9rem;
    color: var(--text-light);
    margin: 0;
  }

  .milestone-crossings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 1rem;
  }

  .milestone-crossing-card {
    background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    border: 2px solid #f59e0b;
    border-radius: 12px;
    padding: 1.25rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .milestone-crossing-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
  }

  .milestone-crossing-card.major {
    background: linear-gradient(135deg, #fef3c7 0%, #fcd34d 100%);
    border-color: #d97706;
  }

  .milestone-icon {
    font-size: 2.5rem;
    flex-shrink: 0;
  }

  .milestone-details {
    flex: 1;
    min-width: 0;
  }

  .milestone-player-name {
    font-weight: 700;
    font-size: 1.05rem;
    color: var(--text-dark);
    margin-bottom: 0.25rem;
  }

  .milestone-player-name a {
    color: inherit;
    text-decoration: none;
  }

  .milestone-player-name a:hover {
    text-decoration: underline;
    color: var(--primary-color);
  }

  .milestone-description {
    font-size: 0.9rem;
    color: #92400e;
    font-weight: 500;
  }

  .milestone-current-total {
    font-size: 0.8rem;
    color: var(--text-light);
    margin-top: 0.25rem;
  }

  @media (max-width: 768px) {
    .milestone-crossings-grid {
      grid-template-columns: 1fr;
    }
    
    .milestone-crossing-card {
      padding: 1rem;
    }
    
    .milestone-icon {
      font-size: 2rem;
    }
  }
</style>
</head>
<body>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="softball-spinner"></div>
</div>

<!-- Page Header -->
<div class="page-header">
  <h1 id="pageTitle">Year in Review</h1>
  <p id="pageSubtitle">Loading...</p>
</div>

<div class="page-container">
  <!-- Filters and Navigation -->
  <div class="filters-nav">
    <!-- Navigation will be inserted here by nav-component.js -->
  </div>

  <!-- Year Navigation -->
  <div class="year-nav" id="yearNav">
    <!-- Populated dynamically -->
  </div>

  <!-- Season Sections Container -->
  <div id="seasonsContainer">
    <!-- Fall and Summer sections will be inserted here -->
  </div>
</div>

<script type="module">
  import {
    getSeasonGames,
    getSeasonPlayerStatsOptimized,
    getSeasonPitchingStatsOptimized,
    getSeasonAwards,
    getAllPlayerStatsOptimized,
    getAllSeasons,
    db,
    doc,
    getDoc
  } from './firebase-data.js';
  import { collection, getDocs, query, where, orderBy } from './firebase-config.js';

  // Fetch eulogies for a season
  async function getSeasonEulogies(seasonId) {
    try {
      const eulogiesRef = collection(db, 'eulogies');
      const q = query(
        eulogiesRef, 
        where('seasonId', '==', seasonId),
        orderBy('eliminationOrder', 'asc')
      );
      const snapshot = await getDocs(q);
      
      if (snapshot.empty) {
        return [];
      }
      
      return snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
    } catch (error) {
      console.log('Could not fetch eulogies for', seasonId, error);
      return [];
    }
  }

  // Global state
  let currentYear = null;
  let allSeasons = [];
  let allPlayers = [];

  // Initialize page
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      // Get year from URL or siteConfig
      const urlParams = new URLSearchParams(window.location.search);
      let year = urlParams.get('year');
      
      if (!year) {
        // Try to get default year from siteConfig
        try {
          const recapConfigRef = doc(db, 'siteConfig', 'navigation', 'pages', 'recap');
          const recapConfigSnap = await getDoc(recapConfigRef);
          if (recapConfigSnap.exists()) {
            const configData = recapConfigSnap.data();
            year = configData.year?.toString();
          }
        } catch (e) {
          console.log('Could not fetch recap config, using current year');
        }
      }
      
      // Default to current year if still not set
      if (!year) {
        year = new Date().getFullYear().toString();
      }
      
      currentYear = parseInt(year);
      
      // Load all seasons and players for context
      [allSeasons, allPlayers] = await Promise.all([
        getAllSeasons(),
        getAllPlayerStatsOptimized()
      ]);
      
      // Build year navigation
      buildYearNav();
      
      // Load the recap data
      await loadYearRecap(currentYear);
      
      // Hide loading overlay
      document.getElementById('loadingOverlay').classList.add('hidden');
      
    } catch (error) {
      console.error('Error initializing recap page:', error);
      document.getElementById('seasonsContainer').innerHTML = `
        <div class="empty-state">
          <p>Error loading recap data. Please try again later.</p>
        </div>
      `;
      document.getElementById('loadingOverlay').classList.add('hidden');
    }
  });

  function buildYearNav() {
    const navContainer = document.getElementById('yearNav');
    
    // Get unique years from seasons
    const years = [...new Set(allSeasons.map(s => {
      const parts = s.id.split('-');
      return parseInt(parts[0]);
    }))]
    .filter(year => year !== 2021 && year !== 2019) // Exclude years with limited data
    .sort((a, b) => b - a);
    
    navContainer.innerHTML = years.map(year => `
      <a href="?year=${year}" class="year-btn ${year === currentYear ? 'active' : ''}">${year}</a>
    `).join('');
  }

  async function loadYearRecap(year) {
    const container = document.getElementById('seasonsContainer');
    container.innerHTML = '<div class="empty-state">Loading recap data...</div>';
    
    // Update header
    document.getElementById('pageTitle').textContent = `${year} Year in Review`;
    document.getElementById('pageSubtitle').textContent = `Celebrating the achievements of the ${year} Mountainside Aces seasons`;
    document.title = `${year} Year in Review - Mountainside Aces`;
    
    const fallSeasonId = `${year}-fall`;
    const summerSeasonId = `${year}-summer`;
    
    // Check which seasons exist
    const fallExists = allSeasons.some(s => s.id === fallSeasonId);
    const summerExists = allSeasons.some(s => s.id === summerSeasonId);
    
    let html = '';
    
    // Load Fall Season (displayed first)
    if (fallExists) {
      html += await buildSeasonSection(fallSeasonId, 'fall', year, false);
    }
    
    // Load Summer Season
    if (summerExists) {
      html += await buildSeasonSection(summerSeasonId, 'summer', year, true);
    }
    
    if (!fallExists && !summerExists) {
      html = `<div class="empty-state"><p>No season data found for ${year}.</p></div>`;
    }
    
    container.innerHTML = html;
  }

  async function buildSeasonSection(seasonId, seasonType, year, includeAwards) {
    const seasonLabel = seasonType.charAt(0).toUpperCase() + seasonType.slice(1);
    const emoji = seasonType === 'fall' ? 'üçÇ' : '‚òÄÔ∏è';
    
    try {
      // Fetch all season data in parallel
      const [games, battingStats, pitchingStats, awards, eulogies] = await Promise.all([
        getSeasonGames(seasonId),
        getSeasonPlayerStatsOptimized(seasonId),
        getSeasonPitchingStatsOptimized(seasonId),
        includeAwards ? getSeasonAwards(seasonId) : Promise.resolve([]),
        getSeasonEulogies(seasonId)
      ]);
      
      // Calculate standings
      const standings = calculateStandings(games);
      
      // Find champion (first place in standings or from playoff data)
      const champion = findChampion(seasonId, games, standings);
      
      // Get season leaders
      const battingLeaders = calculateBattingLeaders(battingStats);
      const pitchingLeaders = calculatePitchingLeaders(pitchingStats);
      
      // Get top rookies for this season
      const rookies = findSeasonRookies(seasonId, battingStats);
      
      // Find milestone crossings for this season
      const milestoneCrossings = findMilestoneCrossings(seasonId, battingStats, allPlayers);
      
      return `
        <div class="season-section">
          <div class="season-header ${seasonType}">
            <h2>${emoji} ${seasonLabel.toUpperCase()} ${year}</h2>
          </div>
          <div class="season-content">
            ${champion ? `
              <div class="champion-banner">
                <div class="champion-trophy">üèÜ</div>
                <div class="champion-info">
                  <h3>SEASON CHAMPION</h3>
                  <p class="champion-team">${champion}</p>
                </div>
              </div>
            ` : ''}
            
            <!-- Final Standings -->
            <div class="subsection">
              <div class="subsection-header">
                <h3>üìä Final Standings</h3>
              </div>
              ${renderStandingsTable(standings, champion)}
            </div>
            
            ${includeAwards && awards.length > 0 ? `
              <!-- Awards (Summer Only) -->
              <div class="subsection">
                <div class="subsection-header">
                  <h3>üèÖ Season Awards</h3>
                </div>
                ${renderAwards(awards)}
              </div>
            ` : ''}
            
            <!-- Season Leaders - Batting -->
            <div class="subsection">
              <div class="subsection-header">
                <h3>‚öæ Batting Leaders</h3>
              </div>
              ${renderBattingLeaders(battingLeaders)}
            </div>
            
            <!-- Season Leaders - Pitching -->
            <div class="subsection">
              <div class="subsection-header">
                <h3>üéØ Pitching Leaders</h3>
              </div>
              ${renderPitchingLeaders(pitchingLeaders)}
            </div>
            
            <!-- Top Rookies -->
            <div class="subsection">
              <div class="subsection-header">
                <h3>üåü Top 5 Rookies</h3>
              </div>
              ${renderRookies(rookies)}
            </div>
            
            <!-- Milestone Achievements -->
            ${renderMilestoneCrossings(milestoneCrossings)}
            
            ${eulogies && eulogies.length > 0 ? `
            <!-- Team Eulogies -->
            <div class="eulogies-section">
              <div class="eulogies-header">
                <img src="logos/peterseulogy.png" alt="Eulogies" class="eulogies-header-image" onerror="this.style.display='none'">
                <h3>‚ö∞Ô∏è Fallen Teams</h3>
                <p class="eulogies-header-subtitle">In loving memory of those who didn't make it</p>
              </div>
              ${renderEulogies(eulogies, seasonId)}
            </div>
            ` : ''}
          </div>
        </div>
      `;
    } catch (error) {
      console.error(`Error loading ${seasonId}:`, error);
      return `
        <div class="season-section">
          <div class="season-header ${seasonType}">
            <h2>${emoji} ${seasonLabel.toUpperCase()} ${year}</h2>
          </div>
          <div class="season-content">
            <div class="empty-state">Error loading season data.</div>
          </div>
        </div>
      `;
    }
  }

  function calculateStandings(games) {
    const teams = {};
    
    // Filter to regular season games only
    const regularGames = games.filter(g => {
      const gameType = (g.gameType || g.game_type || '').toLowerCase();
      return gameType !== 'playoff';
    });
    
    regularGames.forEach(game => {
      // Use correct field names from Firebase
      const homeTeam = game.homeTeamName || game['home team'] || game.homeTeam;
      const awayTeam = game.awayTeamName || game['away team'] || game.awayTeam;
      const winner = game.winner;
      
      if (!homeTeam || !awayTeam) return;
      
      // Initialize teams
      if (!teams[homeTeam]) {
        teams[homeTeam] = { name: homeTeam, wins: 0, losses: 0, ties: 0, runsFor: 0, runsAgainst: 0, gamesPlayed: 0, h2h: {} };
      }
      if (!teams[awayTeam]) {
        teams[awayTeam] = { name: awayTeam, wins: 0, losses: 0, ties: 0, runsFor: 0, runsAgainst: 0, gamesPlayed: 0, h2h: {} };
      }
      
      // Initialize h2h records between these teams
      if (!teams[homeTeam].h2h[awayTeam]) {
        teams[homeTeam].h2h[awayTeam] = { wins: 0, losses: 0, ties: 0 };
      }
      if (!teams[awayTeam].h2h[homeTeam]) {
        teams[awayTeam].h2h[homeTeam] = { wins: 0, losses: 0, ties: 0 };
      }
      
      // Only count completed games
      if (winner && winner.trim() !== '') {
        teams[homeTeam].gamesPlayed++;
        teams[awayTeam].gamesPlayed++;
        
        const homeScore = parseInt(game.homeScore || game['home score']) || 0;
        const awayScore = parseInt(game.awayScore || game['away score']) || 0;
        
        teams[homeTeam].runsFor += homeScore;
        teams[homeTeam].runsAgainst += awayScore;
        teams[awayTeam].runsFor += awayScore;
        teams[awayTeam].runsAgainst += homeScore;
        
        // Case-insensitive comparison
        const winnerLower = winner.toLowerCase();
        const homeLower = homeTeam.toLowerCase();
        const awayLower = awayTeam.toLowerCase();
        
        if (winnerLower === 'tie') {
          teams[homeTeam].ties++;
          teams[awayTeam].ties++;
          teams[homeTeam].h2h[awayTeam].ties++;
          teams[awayTeam].h2h[homeTeam].ties++;
        } else if (winnerLower === homeLower) {
          teams[homeTeam].wins++;
          teams[awayTeam].losses++;
          teams[homeTeam].h2h[awayTeam].wins++;
          teams[awayTeam].h2h[homeTeam].losses++;
        } else if (winnerLower === awayLower) {
          teams[awayTeam].wins++;
          teams[homeTeam].losses++;
          teams[awayTeam].h2h[homeTeam].wins++;
          teams[homeTeam].h2h[awayTeam].losses++;
        }
      }
    });
    
    // Convert to array and calculate percentages
    const standings = Object.values(teams).map(team => {
      const decidedGames = team.wins + team.losses;
      return {
        ...team,
        winPct: decidedGames > 0 ? team.wins / decidedGames : 0,
        runDiff: team.runsFor - team.runsAgainst
      };
    });
    
    // Head-to-head comparison function
    function compareHeadToHead(teamA, teamB) {
      const aVsB = teamA.h2h[teamB.name];
      const bVsA = teamB.h2h[teamA.name];
      
      if (!aVsB || !bVsA) return 0;
      
      const aH2HWinPct = (aVsB.wins + aVsB.losses) > 0 ? aVsB.wins / (aVsB.wins + aVsB.losses) : 0;
      const bH2HWinPct = (bVsA.wins + bVsA.losses) > 0 ? bVsA.wins / (bVsA.wins + bVsA.losses) : 0;
      
      return bH2HWinPct - aH2HWinPct;
    }
    
    // Sort with proper tiebreakers
    standings.sort((a, b) => {
      // First tiebreaker: Win percentage
      if (a.winPct !== b.winPct) return b.winPct - a.winPct;
      
      // Check if there are 3+ teams tied at this win percentage
      const teamsAtSameWinPct = standings.filter(t => t.winPct === a.winPct);
      
      // Second tiebreaker: Only use H2H if EXACTLY 2 teams are tied
      if (teamsAtSameWinPct.length === 2) {
        const h2hComp = compareHeadToHead(a, b);
        if (h2hComp !== 0) return h2hComp;
      }
      
      // Third tiebreaker: Runs Against (for 3+ teams tied, or if H2H didn't resolve)
      if (a.runsAgainst !== b.runsAgainst) return a.runsAgainst - b.runsAgainst;
      
      // Fourth tiebreaker: Run Differential
      return b.runDiff - a.runDiff;
    });
    
    return standings;
  }

  function findChampion(seasonId, games, standings) {
    // Hard-coded champions for seasons with incomplete game data
    const hardCodedChampions = {
      '2023-summer': 'Sofa_Kings',
      '2022-summer': 'Master Batters'
    };
    
    if (hardCodedChampions[seasonId]) {
      console.log(`Using hard-coded champion for ${seasonId}: ${hardCodedChampions[seasonId]}`);
      return hardCodedChampions[seasonId];
    }
    
    // First, try to find from playoff games
    // Check for both game_type === 'Playoff' (old format) and gameType === 'playoff' (new format)
    const playoffGames = games.filter(g => 
      g.game_type === 'Playoff' || 
      g.gameType === 'playoff' ||
      (g.gameType && g.gameType.toLowerCase() === 'playoff')
    );
    
    console.log(`Found ${playoffGames.length} playoff games out of ${games.length} total games`);
    
    if (playoffGames.length > 0) {
      // Calculate playoff standings (includes all teams, including kings)
      const playoffStandings = calculatePlayoffStandings(playoffGames);
      
      console.log('Playoff standings:', playoffStandings.map(t => `${t.name}: ${t.wins}-${t.losses} (${t.winPct.toFixed(3)})`));
      
      if (playoffStandings.length > 0) {
        // Filter out substitute "kings" team from champion consideration
        const eligibleTeams = playoffStandings.filter(team => 
          !team.name.toLowerCase().includes('kings')
        );
        
        console.log('Eligible teams (excluding kings):', eligibleTeams.map(t => `${t.name}: ${t.wins}-${t.losses}`));
        
        if (eligibleTeams.length > 0) {
          console.log(`Champion from playoffs: ${eligibleTeams[0].name}`);
          return eligibleTeams[0].name;
        }
      }
    }
    
    console.log('No playoff games found, using regular season standings');
    
    // Fallback: first place in regular season standings (also excluding kings)
    if (standings.length > 0) {
      const eligibleTeams = standings.filter(team => 
        !team.name.toLowerCase().includes('kings')
      );
      if (eligibleTeams.length > 0) {
        return eligibleTeams[0].name;
      }
    }
    
    return null;
  }

  function calculatePlayoffStandings(playoffGames) {
    const teamStats = {};
    
    // Debug: Log first playoff game to see its structure
    if (playoffGames.length > 0) {
      console.log('Sample playoff game structure:', playoffGames[0]);
      console.log('Available fields:', Object.keys(playoffGames[0]));
    }
    
    playoffGames.forEach((game, index) => {
      // Use the correct field names from Firebase
      const homeTeam = game.homeTeamName || game["home team"] || game.homeTeam || game.home_team;
      const awayTeam = game.awayTeamName || game["away team"] || game.awayTeam || game.away_team;
      const winner = game.winner;
      
      // Debug first few games
      if (index < 3) {
        console.log(`Game ${index + 1}:`, {
          homeTeam,
          awayTeam,
          winner,
          homeScore: game.homeScore,
          awayScore: game.awayScore
        });
      }
      
      if (!homeTeam || !awayTeam) {
        if (index < 5) {
          console.warn(`Skipping game ${index + 1} - missing team names:`, {
            homeTeam,
            awayTeam,
            gameFields: Object.keys(game)
          });
        }
        return;
      }
      
      // INCLUDE all teams (including kings) in calculations
      if (!teamStats[homeTeam]) {
        teamStats[homeTeam] = { name: homeTeam, wins: 0, losses: 0, ties: 0 };
      }
      if (!teamStats[awayTeam]) {
        teamStats[awayTeam] = { name: awayTeam, wins: 0, losses: 0, ties: 0 };
      }
      
      if (!winner || winner.trim() === '') return;
      
      // Case-insensitive comparison since winner is lowercase but team names are capitalized
      const winnerLower = winner.toLowerCase();
      const homeLower = homeTeam.toLowerCase();
      const awayLower = awayTeam.toLowerCase();
      
      if (winnerLower === "tie") {
        teamStats[homeTeam].ties++;
        teamStats[awayTeam].ties++;
      } else if (winnerLower === homeLower) {
        teamStats[homeTeam].wins++;
        teamStats[awayTeam].losses++;
      } else if (winnerLower === awayLower) {
        teamStats[awayTeam].wins++;
        teamStats[homeTeam].losses++;
      } else if (winner.includes("Forfeit")) {
        // Handle forfeit wins
        const actualWinner = winner.replace("Forfeit - ", "").replace("Tie", "").trim();
        const actualWinnerLower = actualWinner.toLowerCase();
        if (actualWinner && actualWinnerLower !== "tie") {
          if (actualWinnerLower === homeLower) {
            teamStats[homeTeam].wins++;
            teamStats[awayTeam].losses++;
          } else if (actualWinnerLower === awayLower) {
            teamStats[awayTeam].wins++;
            teamStats[homeTeam].losses++;
          }
        } else {
          teamStats[homeTeam].ties++;
          teamStats[awayTeam].ties++;
        }
      }
    });
    
    console.log('Team stats after processing:', teamStats);
    
    // Convert to array and calculate win percentage
    const standings = Object.values(teamStats).map(team => {
      const totalDecidedGames = team.wins + team.losses;
      team.winPct = totalDecidedGames > 0 ? team.wins / totalDecidedGames : 0;
      return team;
    });
    
    // Sort by win percentage, then by wins (match teams.html logic)
    standings.sort((a, b) => {
      // First by win percentage (descending)
      if (b.winPct !== a.winPct) return b.winPct - a.winPct;
      // Then by total wins (descending)
      if (b.wins !== a.wins) return b.wins - a.wins;
      // Then by fewest losses (ascending)
      return a.losses - b.losses;
    });
    
    return standings;
  }

  function calculateBattingLeaders(battingStats) {
    if (!battingStats || battingStats.length === 0) return null;
    
    // Filter players with minimum at-bats for rate stats
    const qualifiedForRate = battingStats.filter(p => (p.atBats || 0) >= 20);
    
    // Calculate BA and OBP for each player
    const withCalculatedStats = battingStats.map(p => ({
      ...p,
      ba: p.atBats > 0 ? p.hits / p.atBats : 0,
      obp: (p.atBats + p.walks) > 0 ? (p.hits + p.walks) / (p.atBats + p.walks) : 0,
      acesBPI: p.acesBPI || 0
    }));
    
    const qualifiedWithStats = qualifiedForRate.map(p => ({
      ...p,
      ba: p.atBats > 0 ? p.hits / p.atBats : 0,
      obp: (p.atBats + p.walks) > 0 ? (p.hits + p.walks) / (p.atBats + p.walks) : 0,
      acesBPI: p.acesBPI || 0
    }));
    
    return {
      ba: qualifiedWithStats.length > 0 ? 
        [...qualifiedWithStats].sort((a, b) => b.ba - a.ba)[0] : null,
      hits: [...withCalculatedStats].sort((a, b) => (b.hits || 0) - (a.hits || 0))[0] || null,
      runs: [...withCalculatedStats].sort((a, b) => (b.runs || 0) - (a.runs || 0))[0] || null,
      walks: [...withCalculatedStats].sort((a, b) => (b.walks || 0) - (a.walks || 0))[0] || null,
      obp: qualifiedWithStats.length > 0 ?
        [...qualifiedWithStats].sort((a, b) => b.obp - a.obp)[0] : null,
      acesBPI: qualifiedWithStats.length > 0 ?
        [...qualifiedWithStats].sort((a, b) => b.acesBPI - a.acesBPI)[0] : null
    };
  }

  function calculatePitchingLeaders(pitchingStats) {
    if (!pitchingStats || pitchingStats.length === 0) return null;
    
    // Filter pitchers with minimum innings (20 IP for ERA qualification)
    const qualified = pitchingStats.filter(p => (p.inningsPitched || p.IP || 0) >= 20);
    
    if (qualified.length === 0) return null;
    
    const withStats = qualified.map(p => ({
      ...p,
      era: p.earnedRunAverage || p.era || p.ERA || 0,
      ip: p.inningsPitched || p.IP || 0
    }));
    
    return {
      era: [...withStats].sort((a, b) => a.era - b.era)[0] || null,
      innings: [...pitchingStats].map(p => ({
        ...p,
        ip: p.inningsPitched || p.IP || 0
      })).sort((a, b) => b.ip - a.ip)[0] || null
    };
  }

  function findSeasonRookies(seasonId, battingStats) {
    // A rookie is a player whose first season in aggregatedPlayerStats matches this season
    const rookies = [];
    
    // For each player in battingStats (players who played this season)
    battingStats.forEach(playerStats => {
      const playerName = playerStats.name;
      if (!playerName) return;
      
      // Find this player in allPlayers to check their full history
      const fullPlayerData = allPlayers.find(p => 
        (p.name === playerName || p.displayName === playerName) && !p.migrated
      );
      
      if (!fullPlayerData || !fullPlayerData.seasons) return;
      
      const seasonKeys = Object.keys(fullPlayerData.seasons);
      if (seasonKeys.length === 0) return;
      
      // Sort season keys chronologically
      // Keys are like "2025-fall-orange", "2024-summer-blue"
      seasonKeys.sort((a, b) => {
        const partsA = a.split('-');
        const partsB = b.split('-');
        const yearA = parseInt(partsA[0]);
        const yearB = parseInt(partsB[0]);
        
        if (yearA !== yearB) return yearA - yearB;
        
        // Summer comes before Fall in the same year
        const seasonA = partsA[1];
        const seasonB = partsB[1];
        if (seasonA === 'summer' && seasonB === 'fall') return -1;
        if (seasonA === 'fall' && seasonB === 'summer') return 1;
        return 0;
      });
      
      // Check if first season matches current season
      const firstSeasonKey = seasonKeys[0];
      if (firstSeasonKey.startsWith(seasonId)) {
        rookies.push({
          name: playerName,
          id: fullPlayerData.id || playerName.toLowerCase().replace(/\s+/g, '_'),
          games: playerStats.games || 0,
          hits: playerStats.hits || 0,
          runs: playerStats.runs || 0,
          ba: playerStats.atBats > 0 ? (playerStats.hits / playerStats.atBats) : 0,
          acesBPI: playerStats.acesBPI || 0
        });
      }
    });
    
    // Sort by AcesBPI and take top 5
    return rookies
      .sort((a, b) => b.acesBPI - a.acesBPI)
      .slice(0, 5);
  }

  /**
   * Calculate career totals up to and including a specific season
   * @param {Object} player - Player object with seasons object
   * @param {string} upToSeasonId - Season ID to calculate through (e.g., "2024-fall")
   * @returns {Object} Career totals for hits, runs, walks through that season
   */
  function calculateCareerTotalsThrough(player, upToSeasonId) {
    const totals = { hits: 0, runs: 0, walks: 0 };
    
    if (!player.seasons) return totals;
    
    // Parse the target season for comparison
    const [targetYear, targetSeason] = upToSeasonId.split('-');
    const targetYearNum = parseInt(targetYear);
    const targetSeasonValue = targetSeason === 'summer' ? 0 : 1; // summer=0, fall=1
    
    Object.entries(player.seasons).forEach(([seasonKey, season]) => {
      // Parse this season key (e.g., "2024-fall-orange" -> 2024, fall)
      const parts = seasonKey.split('-');
      const seasonYear = parseInt(parts[0]);
      const seasonType = parts[1];
      const seasonValue = seasonType === 'summer' ? 0 : 1;
      
      // Only include if this season is <= target season chronologically
      if (seasonYear < targetYearNum || 
          (seasonYear === targetYearNum && seasonValue <= targetSeasonValue)) {
        totals.hits += Number(season.hits) || 0;
        totals.runs += Number(season.runs) || 0;
        totals.walks += Number(season.walks) || 0;
      }
    });
    
    return totals;
  }

  /**
   * Find players who crossed milestone thresholds during a specific season
   * @param {string} seasonId - Season ID (e.g., "2024-fall")
   * @param {Array} battingStats - Season batting stats from getSeasonPlayerStatsOptimized
   * @param {Array} allPlayersData - All players from getAllPlayerStatsOptimized
   * @returns {Array} Array of milestone crossing objects
   */
  function findMilestoneCrossings(seasonId, battingStats, allPlayersData) {
    const milestoneThresholds = {
      hits: [100, 200, 300],
      runs: [50, 100, 150, 200],
      walks: [25, 50]
    };
    
    const crossings = [];
    
    battingStats.forEach(seasonPlayer => {
      // Find matching career record in allPlayers
      const careerPlayer = allPlayersData.find(p => {
        // Match by ID first
        if (p.id === seasonPlayer.playerId || p.playerId === seasonPlayer.playerId) {
          return !p.migrated;
        }
        // Fallback to name matching
        const pName = (p.name || p.displayName || '').toLowerCase();
        const spName = (seasonPlayer.name || seasonPlayer.playerName || '').toLowerCase();
        return pName === spName && !p.migrated;
      });
      
      if (!careerPlayer || !careerPlayer.seasons) return;
      
      // Calculate career totals through this season only (not future seasons)
      const careerTotals = calculateCareerTotalsThrough(careerPlayer, seasonId);
      
      // Get this season's stats
      const seasonHits = Number(seasonPlayer.hits) || 0;
      const seasonRuns = Number(seasonPlayer.runs) || 0;
      const seasonWalks = Number(seasonPlayer.walks) || 0;
      
      // Calculate pre-season totals (career minus this season)
      const preSeasonHits = careerTotals.hits - seasonHits;
      const preSeasonRuns = careerTotals.runs - seasonRuns;
      const preSeasonWalks = careerTotals.walks - seasonWalks;
      
      const playerName = seasonPlayer.name || seasonPlayer.playerName;
      const playerId = seasonPlayer.playerId || seasonPlayer.id;
      
      // Check hits milestones
      milestoneThresholds.hits.forEach(threshold => {
        if (preSeasonHits < threshold && careerTotals.hits >= threshold) {
          crossings.push({
            player: playerName,
            playerId: playerId,
            stat: 'Hits',
            threshold: threshold,
            currentTotal: careerTotals.hits,
            icon: getStatIcon('hits', threshold),
            isMajor: threshold >= 200
          });
        }
      });
      
      // Check runs milestones
      milestoneThresholds.runs.forEach(threshold => {
        if (preSeasonRuns < threshold && careerTotals.runs >= threshold) {
          crossings.push({
            player: playerName,
            playerId: playerId,
            stat: 'Runs',
            threshold: threshold,
            currentTotal: careerTotals.runs,
            icon: getStatIcon('runs', threshold),
            isMajor: threshold >= 150
          });
        }
      });
      
      // Check walks milestones
      milestoneThresholds.walks.forEach(threshold => {
        if (preSeasonWalks < threshold && careerTotals.walks >= threshold) {
          crossings.push({
            player: playerName,
            playerId: playerId,
            stat: 'Walks',
            threshold: threshold,
            currentTotal: careerTotals.walks,
            icon: getStatIcon('walks', threshold),
            isMajor: threshold >= 50
          });
        }
      });
    });
    
    // Sort by threshold (descending) then by stat importance
    const statPriority = { 'Hits': 1, 'Runs': 2, 'Walks': 3 };
    crossings.sort((a, b) => {
      if (b.threshold !== a.threshold) return b.threshold - a.threshold;
      return statPriority[a.stat] - statPriority[b.stat];
    });
    
    return crossings;
  }

  /**
   * Get appropriate icon for a milestone
   */
  function getStatIcon(stat, threshold) {
    const icons = {
      hits: { 100: 'üíØ', 200: 'üéØ', 300: 'üèÜ' },
      runs: { 50: 'üèÉ', 100: 'üíØ', 150: 'üî•', 200: 'üöÄ' },
      walks: { 25: 'üëÅÔ∏è', 50: 'üö∂' }
    };
    return icons[stat]?.[threshold] || 'üéâ';
  }

  /**
   * Render milestone crossings section
   */
  function renderMilestoneCrossings(crossings) {
    if (!crossings || crossings.length === 0) {
      return '';
    }
    
    return `
      <div class="milestones-section">
        <div class="milestones-section-header">
          <h3>üéØ Milestone Achievements</h3>
          <p class="milestones-section-subtitle">Players who reached career milestones this season</p>
        </div>
        <div class="milestone-crossings-grid">
          ${crossings.map(crossing => `
            <div class="milestone-crossing-card ${crossing.isMajor ? 'major' : ''}">
              <div class="milestone-icon">${crossing.icon}</div>
              <div class="milestone-details">
                <div class="milestone-player-name">
                  <a href="player.html?id=${encodeURIComponent(crossing.playerId)}">${crossing.player}</a>
                </div>
                <div class="milestone-description">
                  Reached ${crossing.threshold} career ${crossing.stat.toLowerCase()}!
                </div>
                <div class="milestone-current-total">
                  Now at ${crossing.currentTotal} ${crossing.stat.toLowerCase()}
                </div>
              </div>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  function renderStandingsTable(standings, champion) {
    if (!standings || standings.length === 0) {
      return '<div class="empty-state">No standings data available.</div>';
    }
    
    const championLower = champion ? champion.toLowerCase() : '';
    
    return `
      <div style="overflow-x: auto;">
        <table class="standings-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Team</th>
              <th>W</th>
              <th>L</th>
              <th>T</th>
              <th>Win%</th>
              <th>RF</th>
              <th>RA</th>
              <th>Diff</th>
            </tr>
          </thead>
          <tbody>
            ${standings.map((team, index) => `
              <tr class="${team.name.toLowerCase() === championLower ? 'champion-row' : ''}">
                <td>${index + 1}</td>
                <td>${team.name}</td>
                <td>${team.wins}</td>
                <td>${team.losses}</td>
                <td>${team.ties}</td>
                <td>${team.winPct.toFixed(3)}</td>
                <td>${team.runsFor}</td>
                <td>${team.runsAgainst}</td>
                <td style="color: ${team.runDiff >= 0 ? '#22c55e' : '#ef4444'}">
                  ${team.runDiff >= 0 ? '+' : ''}${team.runDiff}
                </td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;
  }

  function getAwardIcon(awardType) {
    const awardIcons = {
      'Team MVP': 'team_mvp.png',
      'All Aces': 'all_aces.png',
      'Gold Glove': 'gold_glove.png',
      'Team of the Year': 'team_of_the_year.png',
      'Rookie of the Year': 'rookie_of_the_year.png',
      'Most Improved Ace': 'most_improved_ace.png',
      'Comeback Player of the Year': 'comeback_player.png',
      'Slugger of the Year': 'slugger_of_the_year.png',
      'Pitcher of the Year': 'pitcher_of_the_year.png',
      'Captain of the Year': 'captain_of_the_year.png',
      'Al Pineda Good Guy Award': 'al_pineda_good_guy_award.png',
      'Iron Man Award': 'iron_man_award.png',
      'Sub of the Year': 'sub_of_the_year.png',
      'Andrew Streaman Boner Award': 'andrew_streaman_boner_award.png',
      'Erik Lund Perservenance Award': 'erik_lund_perservenance_award.png',
      'Mr. Streaman Award for Excellence': 'mr_streaman_award_for_excellence.png'
    };

    const fallbackEmojis = {
      'Team MVP': 'üëë',
      'All Aces': '‚≠ê',
      'Gold Glove': 'ü•á',
      'Team of the Year': 'üèÜ',
      'Rookie of the Year': 'üåü',
      'Most Improved Ace': 'üìà',
      'Comeback Player of the Year': 'üîÑ',
      'Slugger of the Year': 'üí™',
      'Pitcher of the Year': 'ü•é',
      'Captain of the Year': 'üéñÔ∏è',
      'Al Pineda Good Guy Award': 'ü§ù',
      'Iron Man Award': 'üíØ',
      'Sub of the Year': 'üÖæÔ∏è',
      'Andrew Streaman Boner Award': 'üé™',
      'Erik Lund Perservenance Award': '‚ö°',
      'Mr. Streaman Award for Excellence': 'üåü',
      'MVP': 'üèÜ',
      'Batting Champion': 'ü•á',
      'Batting Title': 'ü•á',
      'Home Run Champion': 'üí™',
      'RBI Leader': 'üìä',
      'Cy Young': '‚öæ',
      'default': 'üèÖ'
    };

    const iconFile = awardIcons[awardType];
    const fallbackEmoji = fallbackEmojis[awardType] || fallbackEmojis.default;

    return {
      iconFile: iconFile,
      fallbackEmoji: fallbackEmoji
    };
  }

  function renderAwards(awards) {
    if (!awards || awards.length === 0) {
      return '<div class="empty-state">No awards data available.</div>';
    }
    
    return `
      <div class="awards-grid">
        ${awards.map(award => {
          const awardIcon = getAwardIcon(award.category);
          const iconHtml = awardIcon.iconFile ? 
            `<img src="awards/${awardIcon.iconFile}" alt="${award.category}" class="award-icon-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';"><span class="fallback-emoji" style="display: none;">${awardIcon.fallbackEmoji}</span>` :
            `<span class="fallback-emoji">${awardIcon.fallbackEmoji}</span>`;
          
          return `
          <div class="award-card">
            <div class="award-icon">${iconHtml}</div>
            <div class="award-info">
              <div class="award-category">${award.category}</div>
              <div class="award-winner">
                <a href="player.html?id=${encodeURIComponent(award.playerName?.toLowerCase().replace(/\s+/g, '_') || '')}">${award.playerName}</a>
              </div>
              ${award.value ? `<div class="award-value">${award.value}</div>` : ''}
            </div>
          </div>
        `;
        }).join('')}
      </div>
    `;
  }

  function renderBattingLeaders(leaders) {
    if (!leaders) {
      return '<div class="empty-state">No batting data available.</div>';
    }
    
    const categories = [
      { key: 'ba', label: 'Batting Average', format: v => v.ba.toFixed(3) },
      { key: 'hits', label: 'Hits', format: v => v.hits },
      { key: 'runs', label: 'Runs', format: v => v.runs },
      { key: 'walks', label: 'Walks', format: v => v.walks },
      { key: 'obp', label: 'On-Base %', format: v => v.obp.toFixed(3) },
      { key: 'acesBPI', label: 'AcesBPI', format: v => v.acesBPI.toFixed(2) }
    ];
    
    return `
      <div class="leaders-grid">
        ${categories.map(cat => {
          const leader = leaders[cat.key];
          if (!leader) return '';
          return `
            <div class="leader-card">
              <div class="leader-category">${cat.label}</div>
              <div class="leader-name">
                <a href="player.html?id=${encodeURIComponent(leader.playerId || leader.name?.toLowerCase().replace(/\s+/g, '_') || '')}">${leader.name}</a>
              </div>
              <div class="leader-value">${cat.format(leader)}</div>
            </div>
          `;
        }).join('')}
      </div>
    `;
  }

  function renderPitchingLeaders(leaders) {
    if (!leaders) {
      return '<div class="empty-state">No pitching data available.</div>';
    }
    
    return `
      <div class="pitching-leaders">
        ${leaders.era ? `
          <div class="leader-card">
            <div class="leader-category">ERA</div>
            <div class="leader-name">
              <a href="player.html?id=${encodeURIComponent(leaders.era.playerId || leaders.era.name?.toLowerCase().replace(/\s+/g, '_') || '')}">${leaders.era.name}</a>
            </div>
            <div class="leader-value">${leaders.era.era.toFixed(2)}</div>
          </div>
        ` : ''}
        ${leaders.innings ? `
          <div class="leader-card">
            <div class="leader-category">Innings Pitched</div>
            <div class="leader-name">
              <a href="player.html?id=${encodeURIComponent(leaders.innings.playerId || leaders.innings.name?.toLowerCase().replace(/\s+/g, '_') || '')}">${leaders.innings.name}</a>
            </div>
            <div class="leader-value">${leaders.innings.ip.toFixed(1)}</div>
          </div>
        ` : ''}
      </div>
    `;
  }

  function renderRookies(rookies) {
    if (!rookies || rookies.length === 0) {
      return '<div class="empty-state">No rookie data available for this season.</div>';
    }
    
    return `
      <div class="rookies-list">
        ${rookies.map((rookie, index) => `
          <div class="rookie-item">
            <div class="rookie-rank">${index + 1}</div>
            <div class="rookie-info">
              <div class="rookie-name">
                <a href="player.html?id=${encodeURIComponent(rookie.id || rookie.name?.toLowerCase().replace(/\s+/g, '_') || '')}">${rookie.name}</a>
              </div>
              <div class="rookie-stats">
                ${rookie.games}G ‚Ä¢ ${rookie.hits}H ‚Ä¢ ${rookie.runs}R ‚Ä¢ ${rookie.ba.toFixed(3)} BA
              </div>
            </div>
            <div class="rookie-bpi">${rookie.acesBPI.toFixed(2)} BPI</div>
          </div>
        `).join('')}
      </div>
    `;
  }

  function renderEulogies(eulogies, seasonId) {
    if (!eulogies || eulogies.length === 0) {
      return '';
    }
    
    // Create a safe ID prefix from seasonId (e.g., "2025-fall" -> "2025-fall")
    const idPrefix = seasonId.replace(/[^a-zA-Z0-9-]/g, '');
    
    return `
      <div class="eulogies-list">
        ${eulogies.map((eulogy, index) => {
          const icon = eulogy.isChampion ? 'üèÜ' : 'ü™¶';
          return `
          <div class="eulogy-card ${eulogy.isChampion ? 'champion' : ''}" id="eulogy-${idPrefix}-${index}">
            <div class="eulogy-header ${eulogy.isChampion ? 'champion' : ''}" onclick="toggleEulogy('${idPrefix}', ${index})">
              <div class="eulogy-team-info">
                <span class="eulogy-tombstone">${icon}</span>
                <span class="eulogy-team-name">${eulogy.teamName}</span>
                ${eulogy.eliminatedInRound ? `<span class="eulogy-round">‚Äî ${eulogy.eliminatedInRound}</span>` : ''}
              </div>
              <span class="eulogy-toggle">‚ñº</span>
            </div>
            <div class="eulogy-content">
              <div class="eulogy-text">${formatEulogyText(eulogy.text)}</div>
            </div>
          </div>
        `}).join('')}
      </div>
    `;
  }

  function formatEulogyText(text) {
    if (!text) return '';
    // Convert line breaks to paragraphs and escape HTML
    const escaped = text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    
    // Split by double line breaks for paragraphs
    const paragraphs = escaped.split(/\n\n+/);
    if (paragraphs.length > 1) {
      return paragraphs.map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`).join('');
    }
    // Single paragraph with line breaks preserved
    return escaped.replace(/\n/g, '<br>');
  }

  // Global function to toggle eulogy expansion
  window.toggleEulogy = function(prefix, index) {
    const card = document.getElementById(`eulogy-${prefix}-${index}`);
    if (card) {
      card.classList.toggle('expanded');
    }
  };
</script>

<script type="module">
  import { NavigationComponent } from './nav-component.js';
  // Navigation auto-initializes on load!
</script>
<script src="team-colors.js"></script>
<script src="mobile-enhancements.js"></script>
<script src="theme-toggle.js"></script>
</body>
</html>

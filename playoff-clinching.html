<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Mountainside Aces">
<title>Playoff Seeding Scenarios - Mountainside Aces</title>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="mobile-enhancements.css">
<style>
  :root {
    --primary-color: #2d5016;
    --secondary-color: #1a6b4a;
    --accent-color: #ffd700;
    --card-bg: #ffffff;
    --text-dark: #2d3748;
    --text-light: #718096;
    --border-color: #e2e8f0;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
    --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
    --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
    --clinched-green: #10b981;
    --danger-red: #ef4444;
    --warning-yellow: #f59e0b;
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    min-height: 100vh;
    color: var(--text-dark);
  }

  /* Loading Spinner */
  .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 0.5s ease;
  }

  .loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .softball-spinner {
    width: 80px;
    height: 80px;
    position: relative;
    animation: spin 1.5s ease-in-out infinite;
  }

  .softball-spinner::before {
    content: 'üîí';
    font-size: 80px;
    position: absolute;
    top: 0;
    left: 0;
  }

  @keyframes spin {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
  }

  /* Header - Pumpkin theme for playoff scenarios */
  .header {
    background: linear-gradient(135deg, #ff6347 0%, #ff8c42 100%);
    color: white;
    text-align: center;
    padding: 4rem 2rem;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
  }

  .header::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -10%;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }

  .header::after {
    content: 'üîí';
    position: absolute;
    bottom: -30px;
    left: 10%;
    font-size: 120px;
    opacity: 0.15;
    transform: rotate(-15deg);
  }
  
  .header h1 {
    margin: 0;
    font-size: 3.5rem;
    font-weight: 800;
    text-shadow: 2px 4px 8px rgba(0,0,0,0.2);
    letter-spacing: -0.5px;
    position: relative;
    z-index: 1;
  }
  
  .header p {
    margin: 1rem 0 0 0;
    font-size: 1.3rem;
    opacity: 0.95;
    font-weight: 300;
    position: relative;
    z-index: 1;
  }

  .container {
    max-width: 1400px;
    margin: 3rem auto;
    padding: 0 2rem;
  }

  /* Modern Section Styling */
  .section {
    background: var(--card-bg);
    border-radius: 16px;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-sm);
    border: 1px solid var(--border-color);
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .section:hover {
    box-shadow: var(--shadow-md);
  }

  .section-header {
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    color: white;
    padding: 1.5rem 2rem;
    font-size: 1.5rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 0.8rem;
    position: relative;
  }

  .section-header::after {
    content: '‚öæ';
    position: absolute;
    right: 2rem;
    font-size: 2rem;
    opacity: 0.2;
  }

  .section-content {
    padding: 2rem;
  }

  /* Summary Cards */
  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .summary-card {
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
    border-radius: 12px;
    padding: 1.5rem;
    text-align: center;
    border-left: 4px solid var(--primary-color);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
  }

  .summary-card.clinched {
    border-left-color: var(--clinched-green);
  }

  .summary-card.danger {
    border-left-color: var(--danger-red);
  }

  .summary-card.warning {
    border-left-color: var(--warning-yellow);
  }

  .summary-card::before {
    content: '‚öæ';
    position: absolute;
    bottom: -10px;
    right: -10px;
    font-size: 60px;
    opacity: 0.05;
  }

  .summary-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-md);
  }

  .summary-number {
    font-size: 2rem;
    font-weight: 800;
    color: var(--text-dark);
    margin-bottom: 0.5rem;
  }

  .summary-label {
    font-size: 0.9rem;
    color: var(--text-light);
    font-weight: 500;
  }

  /* Clinching Table */
  .clinching-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1rem;
    font-size: 0.9rem;
  }

  .clinching-table th,
  .clinching-table td {
    padding: 12px 10px;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
  }

  .clinching-table th {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    font-weight: 600;
    color: var(--text-dark);
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .clinching-table tbody tr {
    transition: background-color 0.2s ease;
  }

  .clinching-table tbody tr:hover {
    background-color: #f8fafc;
  }

  .team-name {
    font-weight: 600;
    color: var(--text-dark);
  }

  .status-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .status-clinched {
    background-color: #d1fae5;
    color: #065f46;
  }

  .status-eliminated {
    background-color: #fee2e2;
    color: #991b1b;
  }

  .status-safe {
    background-color: #dbeafe;
    color: #1e40af;
  }

  .status-danger {
    background-color: #fef3c7;
    color: #92400e;
  }

  .status-contention {
    background-color: #e0e7ff;
    color: #3730a3;
  }

  .magic-number {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--primary-color);
  }

  .magic-number.low {
    color: var(--clinched-green);
  }

  .magic-number.high {
    color: var(--danger-red);
  }

  .scenario-text {
    font-size: 0.85rem;
    color: var(--text-light);
    line-height: 1.6;
    white-space: normal;
    text-align: left;
    max-width: 700px;
    padding: 8px 0;
  }
  
  .scenario-text strong {
    color: var(--text-dark);
    font-weight: 600;
  }
  
  .scenario-text div {
    margin-bottom: 8px;
  }
  
  .scenario-text strong:first-child {
    margin-top: 0;
  }

  .no-data {
    text-align: center;
    padding: 3rem;
    color: var(--text-light);
  }

  .no-data h4 {
    margin: 0 0 0.5rem 0;
    color: var(--text-dark);
  }

  /* Legend */
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    padding: 1rem;
    background: #f8f9fa;
    border-radius: 8px;
    margin-top: 1rem;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
  }

  .legend-color {
    width: 20px;
    height: 20px;
    border-radius: 4px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .header h1 {
      font-size: 2.5rem;
    }

    .header p {
      font-size: 1.1rem;
    }

    .summary-grid {
      grid-template-columns: 1fr;
    }

    .clinching-table {
      font-size: 0.8rem;
    }

    .clinching-table th,
    .clinching-table td {
      padding: 8px 6px;
    }
  }
</style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="softball-spinner"></div>
  </div>

  <!-- Header -->
  <div class="header">
    <h1>üîí Playoff Seeding Scenarios</h1>
    <p>All 10 teams make playoffs - Fight for your seed!</p>
  </div>

<!-- ADD THIS: Navigation container for desktop -->
<div class="filters-nav"></div>


  <!-- Main Content -->
  <div class="container">
    <!-- Summary Section -->
    <div class="section">
      <div class="section-header">üìä Playoff Seeding Summary</div>
      <div class="section-content">
        <div class="summary-grid" id="summaryGrid">
          <div class="summary-card clinched">
            <div class="summary-number" id="clinched">-</div>
            <div class="summary-label">Seeds Locked</div>
          </div>
          <div class="summary-card">
            <div class="summary-number" id="byeSeeds">-</div>
            <div class="summary-label">Direct to Round 1</div>
          </div>
          <div class="summary-card warning">
            <div class="summary-number" id="playInTeams">-</div>
            <div class="summary-label">Play-In Games</div>
          </div>
          <div class="summary-card">
            <div class="summary-number" id="gamesRemaining">-</div>
            <div class="summary-label">Total Games Remaining</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Seeding Scenarios -->
    <div class="section">
      <div class="section-header">üèÜ Team-by-Team Seeding Scenarios</div>
      <div class="section-content">
        <div style="overflow-x: auto;">
          <table class="clinching-table">
            <thead>
              <tr>
                <th>Seed</th>
                <th>Team</th>
                <th>Record</th>
                <th>Win%</th>
                <th>Status</th>
                <th>Seed Range</th>
                <th>Games Left</th>
                <th>Seeding Scenario</th>
              </tr>
            </thead>
            <tbody id="clinchingTableBody">
              <tr>
                <td colspan="8" class="loading">Loading seeding scenarios...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Legend -->
        <div class="legend">
          <div class="legend-item">
            <span class="status-badge status-safe">Top Seed</span>
            <span>Seeds 1-2 (vs play-in winners)</span>
          </div>
          <div class="legend-item">
            <span class="status-badge status-contention">Mid Seed</span>
            <span>Seeds 3-6 (direct to round 1)</span>
          </div>
          <div class="legend-item">
            <span class="status-badge status-danger">Play-In</span>
            <span>Seeds 7-10 (must win play-in)</span>
          </div>
        </div>
        <div style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; font-size: 0.85rem; color: #666;">
          <strong>Seed Range:</strong> Shows possible final seeds based on all remaining games. 
          <strong>#3</strong> = locked into that seed | 
          <strong>#2-4</strong> = can finish anywhere in that range
        </div>
      </div>
    </div>

    <!-- Key Matchups -->
    <div class="section">
      <div class="section-header">‚öîÔ∏è Key Remaining Matchups</div>
      <div class="section-content">
        <div id="keyMatchupsContent" class="loading">Loading key matchups...</div>
      </div>
    </div>

    <!-- Seeding Battles -->
    <div class="section">
      <div class="section-header">‚öîÔ∏è Key Seeding Battles</div>
      <div class="section-content">
        <div id="bubbleContent" class="loading">Loading seeding battles...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { db, getDocs, collection, query, where } from './firebase-config.js';

    // Wait for page load
    window.addEventListener('load', function() {
      setTimeout(function() {
        document.getElementById('loadingOverlay').classList.add('hidden');
      }, 800);
    });

    const TOTAL_TEAMS = 10; // All 10 teams make playoffs
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    /**
     * Parse game date - dates are already transformed to strings in loadData
     * @param {string} dateValue - Date as string "M/D/YYYY"
     * @returns {Date} JavaScript Date object
     */
    function parseGameDate(dateValue) {
      return new Date(dateValue);
    }

    /**
     * Get the current active season
     * @returns {Promise<Object>} Active season object
     */
    async function getCurrentSeason() {
      try {
        const q = query(
          collection(db, 'seasons'),
          where('isActive', '==', true)
        );
        const seasonsSnapshot = await getDocs(q);
        
        if (seasonsSnapshot.empty) {
          return null;
        }
        
        const seasonDoc = seasonsSnapshot.docs[0];
        return {
          id: seasonDoc.id,
          ...seasonDoc.data()
        };
      } catch (error) {
        console.error('Error fetching current season:', error);
        return null;
      }
    }

    /**
     * Get all games for a season
     * @param {string} seasonId - Season ID (e.g., "2025-fall")
     * @returns {Promise<Array>} Array of game objects
     */
    async function getSeasonGames(seasonId) {
      try {
        const gamesSnapshot = await getDocs(
          collection(db, 'seasons', seasonId, 'games')
        );
        return gamesSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
      } catch (error) {
        console.error('Error fetching season games:', error);
        return [];
      }
    }

    function calculateStandings(games) {
      const teamStats = {};
      
      games.forEach(game => {
        const homeTeam = game['home team'];
        const awayTeam = game['away team'];
        const winner = game.winner;
        const homeScore = parseInt(game['home score']) || 0;
        const awayScore = parseInt(game['away score']) || 0;
        
        if (!teamStats[homeTeam]) {
          teamStats[homeTeam] = { 
            name: homeTeam, 
            wins: 0, 
            losses: 0, 
            ties: 0, 
            gamesPlayed: 0, 
            runsFor: 0, 
            runsAgainst: 0,
            h2h: {} // Head-to-head records
          };
        }
        if (!teamStats[awayTeam]) {
          teamStats[awayTeam] = { 
            name: awayTeam, 
            wins: 0, 
            losses: 0, 
            ties: 0, 
            gamesPlayed: 0, 
            runsFor: 0, 
            runsAgainst: 0,
            h2h: {}
          };
        }
        
        teamStats[homeTeam].gamesPlayed++;
        teamStats[awayTeam].gamesPlayed++;
        teamStats[homeTeam].runsFor += homeScore;
        teamStats[homeTeam].runsAgainst += awayScore;
        teamStats[awayTeam].runsFor += awayScore;
        teamStats[awayTeam].runsAgainst += homeScore;
        
        // Initialize h2h records
        if (!teamStats[homeTeam].h2h[awayTeam]) {
          teamStats[homeTeam].h2h[awayTeam] = { wins: 0, losses: 0, ties: 0 };
        }
        if (!teamStats[awayTeam].h2h[homeTeam]) {
          teamStats[awayTeam].h2h[homeTeam] = { wins: 0, losses: 0, ties: 0 };
        }
        
        if (winner === "Tie") {
          teamStats[homeTeam].ties++;
          teamStats[awayTeam].ties++;
          teamStats[homeTeam].h2h[awayTeam].ties++;
          teamStats[awayTeam].h2h[homeTeam].ties++;
        } else if (winner === homeTeam) {
          teamStats[homeTeam].wins++;
          teamStats[awayTeam].losses++;
          teamStats[homeTeam].h2h[awayTeam].wins++;
          teamStats[awayTeam].h2h[homeTeam].losses++;
        } else if (winner === awayTeam) {
          teamStats[awayTeam].wins++;
          teamStats[homeTeam].losses++;
          teamStats[awayTeam].h2h[homeTeam].wins++;
          teamStats[homeTeam].h2h[awayTeam].losses++;
        }
      });
      
      const standings = Object.values(teamStats).map(team => {
        const totalDecided = team.wins + team.losses;
        return {
          ...team,
          winPct: totalDecided > 0 ? (team.wins / totalDecided) : 0,
          runDifferential: team.runsFor - team.runsAgainst
        };
      });
      
      // Sort with proper tiebreakers that handle 3+ team ties correctly
      return sortWithTiebreakers(standings);
    }
    
    function compareHeadToHead(teamA, teamB) {
      const aVsB = teamA.h2h[teamB.name];
      const bVsA = teamB.h2h[teamA.name];
      
      // No head-to-head data or 3+ team tie (can't use h2h)
      if (!aVsB || !bVsA) return 0;
      
      const aH2HWinPct = (aVsB.wins + aVsB.losses) > 0 ? aVsB.wins / (aVsB.wins + aVsB.losses) : 0;
      const bH2HWinPct = (bVsA.wins + bVsA.losses) > 0 ? bVsA.wins / (bVsA.wins + bVsA.losses) : 0;
      
      // Only return if there's a clear winner in h2h
      if (aH2HWinPct !== bH2HWinPct) {
        return bH2HWinPct - aH2HWinPct;
      }
      
      return 0; // H2H is tied, move to next tiebreaker
    }

    function calculateRemainingGames(games, teamName) {
      return games.filter(g => {
        const isFuture = parseGameDate(g.date) >= today;
        const noWinner = !g.winner || g.winner.trim() === "";
        const isRegularSeason = g.game_type === 'Regular';
        const involvesTeam = g['home team'] === teamName || g['away team'] === teamName;
        return isFuture && noWinner && isRegularSeason && involvesTeam;
      }).length;
    }

    /**
     * Check if two teams play each other in remaining games
     */
    function teamsPlayEachOther(team1, team2, games) {
      return games.some(g => {
        const isFuture = parseGameDate(g.date) >= today;
        const noWinner = !g.winner || g.winner.trim() === "";
        const isRegularSeason = g.game_type === 'Regular';
        const hasTeam1 = g['home team'] === team1 || g['away team'] === team1;
        const hasTeam2 = g['home team'] === team2 || g['away team'] === team2;
        return isFuture && noWinner && isRegularSeason && hasTeam1 && hasTeam2;
      });
    }

    /**
     * Check if a team truly clinches a seed (accounting for tiebreaker scenarios)
     * Returns true only if the seed is guaranteed regardless of game margins/tiebreakers
     */
    function trulyClinches(team, targetSeed, standings, gamesLeft) {
      if (gamesLeft === 0) return false;
      
      // Get teams that could threaten this seed
      const threateningTeams = standings.filter((t, idx) => {
        if (t.name === team.name) return false;
        const seed = idx + 1;
        return seed >= targetSeed;
      });
      
      if (threateningTeams.length === 0) return true;
      
      // Check if we can get enough wins to be ahead of ALL threats
      const maxPossibleWins = team.wins + gamesLeft;
      
      // Find if any team could tie us even in our best case
      let couldTie = false;
      threateningTeams.forEach(threat => {
        const threatGamesLeft = calculateRemainingGames(allGames, threat.name);
        const threatMaxWins = threat.wins + threatGamesLeft;
        
        // If they could match our max wins, we could tie
        if (threatMaxWins >= maxPossibleWins) {
          couldTie = true;
        }
      });
      
      // If no one can tie us, we truly clinch
      if (!couldTie) return true;
      
      // If someone could tie us, check if we have H2H advantage
      // But be conservative - if there's any tiebreaker uncertainty, don't claim clinch
      for (const threat of threateningTeams) {
        const threatGamesLeft = calculateRemainingGames(allGames, threat.name);
        const threatMaxWins = threat.wins + threatGamesLeft;
        
        // They could match our wins
        if (threatMaxWins >= maxPossibleWins) {
          // Check if we play them (H2H could be split)
          if (teamsPlayEachOther(team.name, threat.name, allGames)) {
            return false; // Could split H2H, goes to runs allowed = uncertain
          }
          
          // Check if we already have decisive H2H
          const h2h = team.h2h[threat.name];
          if (!h2h) return false; // No H2H data, uncertain
          
          const totalH2H = h2h.wins + h2h.losses;
          if (totalH2H === 0) return false; // No H2H games yet, uncertain
          
          // If H2H is tied or they're ahead, uncertain
          if (h2h.wins <= h2h.losses) return false;
          
          // Could be 3+ team tie, which skips H2H
          if (threateningTeams.length > 1) return false;
        }
      }
      
      return true;
    }

    /**
     * Calculate best and worst possible seeds for a team by simulating outcomes
     */
    function calculateSeedRange(team, standings, upcomingGames) {
      const teamName = team.name;
      const currentWins = team.wins;
      const gamesLeft = calculateRemainingGames(allGames, teamName);
      
      // Best case: team wins all remaining games (or current record if done)
      const bestWins = currentWins + gamesLeft;
      const bestLosses = team.losses;
      
      // Worst case: team loses all remaining games (or current record if done)
      const worstWins = currentWins;
      const worstLosses = team.losses + gamesLeft;
      
      // Simulate best case scenario (other teams lose)
      let bestSeed = simulateFinalStandings(teamName, bestWins, bestLosses, standings, true);
      
      // Simulate worst case scenario (other teams win)
      let worstSeed = simulateFinalStandings(teamName, worstWins, worstLosses, standings, false);
      
      return { bestSeed, worstSeed, bestWins, worstWins, gamesLeft };
    }
    
    /**
     * Sort teams with proper tiebreaker handling for 3+ team ties
     * Tiebreaker order:
     * 1. Win Percentage
     * 2. Head-to-Head (2-team ties ONLY)
     * 3. Runs Allowed (fewer is better)
     * 4. Run Differential (higher is better)
     */
    function sortWithTiebreakers(teams) {
      // First sort by win percentage
      const sorted = [...teams].sort((a, b) => b.winPct - a.winPct);
      
      // Find groups of teams with identical win percentages
      const winPctGroups = [];
      let currentGroup = [sorted[0]];
      
      for (let i = 1; i < sorted.length; i++) {
        if (Math.abs(sorted[i].winPct - sorted[i-1].winPct) < 0.0001) {
          // Same win percentage (accounting for floating point)
          currentGroup.push(sorted[i]);
        } else {
          // Different win percentage - save current group and start new one
          winPctGroups.push(currentGroup);
          currentGroup = [sorted[i]];
        }
      }
      winPctGroups.push(currentGroup); // Don't forget the last group
      
      // Apply appropriate tiebreakers to each group
      const brokenTies = winPctGroups.map(group => {
        if (group.length === 1) {
          // No tie to break
          return group;
        } else if (group.length === 2) {
          // 2-team tie: Use Head-to-Head
          const [a, b] = group;
          const h2hComp = compareHeadToHead(a, b);
          
          if (h2hComp !== 0) {
            return h2hComp > 0 ? [b, a] : [a, b];
          } else {
            // H2H tied, use Runs Allowed
            return breakTieByRunsAllowed(group);
          }
        } else {
          // 3+ team tie: Skip H2H, use Runs Allowed directly
          return breakTieByRunsAllowed(group);
        }
      });
      
      // Flatten the groups back into a single array
      return brokenTies.flat();
    }
    
    /**
     * Break ties using Runs Allowed (fewer is better), then Run Differential
     */
    function breakTieByRunsAllowed(teams) {
      return [...teams].sort((a, b) => {
        // Runs Allowed (fewer is better)
        if (a.runsAgainst !== b.runsAgainst) {
          return a.runsAgainst - b.runsAgainst;
        }
        // Run Differential (higher is better)
        return b.runDifferential - a.runDifferential;
      });
    }
    
    /**
     * Simulate final standings with team at specified record
     * favorableForTeam: true = assume favorable outcomes for other games, false = unfavorable
     * 
     * CRITICAL: We cannot predict game margins (runs allowed changes), so we use CONSERVATIVE sorting:
     * - If teams would be tied in wins AND the tiebreaker involves Runs Allowed (unknown margins),
     *   we treat them as potentially able to swap positions
     */
    function simulateFinalStandings(targetTeam, targetWins, targetLosses, currentStandings, favorableForTeam) {
      // Build hypothetical final standings
      const hypotheticalStandings = currentStandings.map(team => {
        if (team.name === targetTeam) {
          // Use the target team's hypothetical record
          const totalDecided = targetWins + targetLosses;
          return {
            ...team,
            wins: targetWins,
            losses: targetLosses,
            gamesPlayed: totalDecided + team.ties,
            winPct: totalDecided > 0 ? (targetWins / totalDecided) : 0,
            gamesRemaining: 0
          };
        } else {
          // For other teams, calculate their potential final record
          const otherGamesLeft = calculateRemainingGames(allGames, team.name);
          
          let finalWins, finalLosses;
          if (favorableForTeam) {
            // Favorable case for target team: others lose their remaining games
            finalWins = team.wins;
            finalLosses = team.losses + otherGamesLeft;
          } else {
            // Unfavorable case for target team: others win their remaining games
            finalWins = team.wins + otherGamesLeft;
            finalLosses = team.losses;
          }
          
          const totalDecided = finalWins + finalLosses;
          return {
            ...team,
            wins: finalWins,
            losses: finalLosses,
            gamesPlayed: totalDecided + team.ties,
            winPct: totalDecided > 0 ? (finalWins / totalDecided) : 0,
            gamesRemaining: otherGamesLeft
          };
        }
      });
      
      // Sort conservatively - if tiebreaker depends on runs allowed and games remain, 
      // assume worst case for target team
      const sortedStandings = sortWithTiebreakersConservative(hypotheticalStandings, targetTeam, favorableForTeam);
      
      // Find the target team's seed
      const seed = sortedStandings.findIndex(t => t.name === targetTeam) + 1;
      return seed;
    }
    
    /**
     * Conservative sorting that accounts for unknown game margins
     * When runs allowed tiebreaker would apply AND teams have games remaining,
     * we assume the worst case for the target team
     */
    function sortWithTiebreakersConservative(teams, targetTeam, favorableForTarget) {
      // First sort by win percentage
      const sorted = [...teams].sort((a, b) => b.winPct - a.winPct);
      
      // Find groups of teams with identical win percentages
      const winPctGroups = [];
      let currentGroup = [sorted[0]];
      
      for (let i = 1; i < sorted.length; i++) {
        if (Math.abs(sorted[i].winPct - sorted[i-1].winPct) < 0.0001) {
          currentGroup.push(sorted[i]);
        } else {
          winPctGroups.push(currentGroup);
          currentGroup = [sorted[i]];
        }
      }
      winPctGroups.push(currentGroup);
      
      // Apply appropriate tiebreakers to each group
      const brokenTies = winPctGroups.map(group => {
        if (group.length === 1) {
          return group;
        } else if (group.length === 2) {
          // 2-team tie: Check if H2H is decisive
          return breakTwoWayTieConservative(group, targetTeam, favorableForTarget);
        } else {
          // 3+ team tie: Uses Runs Allowed - be conservative
          return breakMultiWayTieConservative(group, targetTeam, favorableForTarget);
        }
      });
      
      return brokenTies.flat();
    }
    
    /**
     * Break 2-way tie conservatively
     */
    function breakTwoWayTieConservative(group, targetTeam, favorableForTarget) {
      const [a, b] = group;
      const hasTarget = a.name === targetTeam || b.name === targetTeam;
      
      // Check H2H
      const h2hComp = compareHeadToHead(a, b);
      
      if (h2hComp !== 0) {
        // H2H is decisive
        return h2hComp > 0 ? [b, a] : [a, b];
      }
      
      // H2H is tied or N/A - would use Runs Allowed
      // If either team has games remaining, margins are unknown
      const anyGamesRemaining = a.gamesRemaining > 0 || b.gamesRemaining > 0;
      
      if (anyGamesRemaining && hasTarget) {
        // Be conservative: assume worst case for target team
        if (favorableForTarget) {
          // This is best-case scenario - target should be higher
          return a.name === targetTeam ? [a, b] : [b, a];
        } else {
          // This is worst-case scenario - target should be lower
          return a.name === targetTeam ? [b, a] : [a, b];
        }
      }
      
      // No games remaining or no target in tie - use current runs allowed
      return breakTieByRunsAllowed(group);
    }
    
    /**
     * Break multi-way tie conservatively
     */
    function breakMultiWayTieConservative(group, targetTeam, favorableForTarget) {
      const hasTarget = group.some(t => t.name === targetTeam);
      const anyGamesRemaining = group.some(t => t.gamesRemaining > 0);
      
      if (anyGamesRemaining && hasTarget) {
        // Runs allowed will change - be conservative
        if (favorableForTarget) {
          // Best case - put target at top of this group
          return group.sort((a, b) => {
            if (a.name === targetTeam) return -1;
            if (b.name === targetTeam) return 1;
            return breakTieByRunsAllowed([a, b])[0].name === a.name ? -1 : 1;
          });
        } else {
          // Worst case - put target at bottom of this group
          return group.sort((a, b) => {
            if (a.name === targetTeam) return 1;
            if (b.name === targetTeam) return -1;
            return breakTieByRunsAllowed([a, b])[0].name === a.name ? -1 : 1;
          });
        }
      }
      
      // No games remaining or no target - use current runs allowed
      return breakTieByRunsAllowed(group);
    }

    /**
     * Calculate magic number to clinch a specific seed
     */
    function calculateMagicNumberForSeed(team, targetSeed, standings) {
      const teamName = team.name;
      const gamesLeft = calculateRemainingGames(allGames, teamName);
      
      if (gamesLeft === 0) return 0; // No games left
      
      // Find the team that could prevent us from getting targetSeed
      // That's the team at position targetSeed (if we want #1, it's current #2, etc.)
      let threateningTeams = standings.filter((t, idx) => {
        if (t.name === teamName) return false;
        const seed = idx + 1;
        return seed >= targetSeed; // Teams at or below our target seed
      });
      
      if (threateningTeams.length === 0) return 0;
      
      // Find the highest win total any threatening team could achieve
      let highestThreat = 0;
      threateningTeams.forEach(otherTeam => {
        const otherGamesLeft = calculateRemainingGames(allGames, otherTeam.name);
        const maxWins = otherTeam.wins + otherGamesLeft;
        highestThreat = Math.max(highestThreat, maxWins);
      });
      
      // Magic number = wins needed to guarantee we're ahead of highest threat
      const magicNumber = Math.max(0, highestThreat - team.wins + 1);
      
      // If impossible, return -1
      if (magicNumber > gamesLeft) return -1;
      
      return magicNumber;
    }

    /**
     * Generate comprehensive detailed seeding scenario text with tiebreaker math
     */
    function generateSeedingScenario(team, seed, standings) {
      const range = calculateSeedRange(team, standings, allGames);
      const teamName = team.name;
      const gamesLeft = range.gamesLeft;
      
      // If this team has no games left but seed is locked (best = worst)
      if (gamesLeft === 0 && range.bestSeed === range.worstSeed) {
        return `Season complete. Locked into #${range.bestSeed} seed`;
      }
      
      // If this team has no games left but seed can still change based on other results
      if (gamesLeft === 0) {
        return generateDetailedScenariosForCompletedTeam(team, seed, standings, range);
      }
      
      // Generate detailed scenarios for teams with games remaining
      return generateDetailedScenariosForActiveTeam(team, seed, standings, range);
    }

    /**
     * Generate detailed scenarios for teams that are done playing
     */
    function generateDetailedScenariosForCompletedTeam(team, seed, standings, range) {
      let scenarios = [];
      const teamName = team.name;
      
      // Generate header
      scenarios.push(`<div style="font-weight: bold; margin-bottom: 8px;">Season complete. Can finish #${range.bestSeed} to #${range.worstSeed}</div>`);
      
      // Generate scenarios for best seed
      const bestSeedDetails = generateCompletedTeamSeedPath(team, range.bestSeed, standings, 'best');
      if (bestSeedDetails) {
        scenarios.push(`<div style="margin-bottom: 12px;"><strong>Finish #${range.bestSeed} Seed if:</strong><br>${bestSeedDetails}</div>`);
      }
      
      // Generate scenarios for middle seeds if applicable
      if (range.worstSeed - range.bestSeed > 1) {
        for (let s = range.bestSeed + 1; s < range.worstSeed; s++) {
          const midDetails = generateCompletedTeamSeedPath(team, s, standings, 'mid');
          if (midDetails) {
            scenarios.push(`<div style="margin-bottom: 12px;"><strong>Finish #${s} Seed if:</strong><br>${midDetails}</div>`);
          }
        }
      }
      
      // Generate scenarios for worst seed
      if (range.worstSeed > range.bestSeed) {
        const worstSeedDetails = generateCompletedTeamSeedPath(team, range.worstSeed, standings, 'worst');
        if (worstSeedDetails) {
          scenarios.push(`<div style="margin-bottom: 12px;"><strong>Fall to #${range.worstSeed} Seed if:</strong><br>${worstSeedDetails}</div>`);
        }
      }
      
      return scenarios.join('');
    }
    
    /**
     * Generate path to a specific seed for teams with completed seasons
     */
    function generateCompletedTeamSeedPath(team, targetSeed, standings, pathType) {
      const teamName = team.name;
      const details = [];
      
      // Find all teams that could affect this team's final position
      const relevantTeams = standings.filter(other => {
        if (other.name === teamName) return false;
        const otherGamesLeft = calculateRemainingGames(allGames, other.name);
        if (otherGamesLeft === 0) return false; // Skip other completed teams
        
        const otherMaxWins = other.wins + otherGamesLeft;
        const otherMinWins = other.wins;
        
        // Could they end up tied with us or pass us?
        return otherMaxWins >= team.wins || otherMinWins <= team.wins;
      });
      
      if (relevantTeams.length === 0) {
        details.push(`‚Ä¢ All other teams have completed their seasons - seed is locked`);
        return details.join('<br>');
      }
      
      // Simulate what needs to happen for this team to reach target seed
      let foundScenario = false;
      let teamsToMention = [];
      
      // For best seed, check if all relevant teams losing their remaining games gives us this seed
      if (pathType === 'best') {
        const testSeed = simulateFinalStandings(teamName, team.wins, team.losses, standings, true);
        if (testSeed === targetSeed) {
          foundScenario = true;
          // Find which teams specifically need to lose for us to get this seed
          teamsToMention = relevantTeams.filter(other => {
            // Test: if this team wins out, do we lose the target seed?
            const otherGamesLeft = calculateRemainingGames(allGames, other.name);
            const hypotheticalStandings = standings.map(t => {
              if (t.name === other.name) {
                const finalWins = other.wins + otherGamesLeft;
                const finalLosses = other.losses;
                const totalDecided = finalWins + finalLosses;
                return {
                  ...t,
                  wins: finalWins,
                  losses: finalLosses,
                  gamesPlayed: totalDecided + t.ties,
                  winPct: totalDecided > 0 ? (finalWins / totalDecided) : 0
                };
              }
              return t;
            });
            const sorted = sortWithTiebreakers(hypotheticalStandings);
            const ourSeedIfTheyWin = sorted.findIndex(t => t.name === teamName) + 1;
            return ourSeedIfTheyWin > targetSeed;
          });
          
          if (teamsToMention.length > 0) {
            details.push(`‚Ä¢ These teams lose their remaining games:`);
            teamsToMention.forEach(other => {
              const gamesLeft = calculateRemainingGames(allGames, other.name);
              details.push(`  - ${other.name} (${gamesLeft} game${gamesLeft > 1 ? 's' : ''} left)`);
            });
          } else {
            details.push(`‚Ä¢ Locked into this seed or better`);
          }
        }
      }
      
      // For worst seed, check if all relevant teams winning gives us this seed
      if (pathType === 'worst') {
        const testSeed = simulateFinalStandings(teamName, team.wins, team.losses, standings, false);
        if (testSeed === targetSeed) {
          foundScenario = true;
          // Find which teams specifically need to win for us to fall to this seed
          teamsToMention = relevantTeams.filter(other => {
            // Test: if this team loses out, do we get a better seed?
            const otherGamesLeft = calculateRemainingGames(allGames, other.name);
            const hypotheticalStandings = standings.map(t => {
              if (t.name === other.name) {
                const finalWins = other.wins;
                const finalLosses = other.losses + otherGamesLeft;
                const totalDecided = finalWins + finalLosses;
                return {
                  ...t,
                  wins: finalWins,
                  losses: finalLosses,
                  gamesPlayed: totalDecided + t.ties,
                  winPct: totalDecided > 0 ? (finalWins / totalDecided) : 0
                };
              }
              return t;
            });
            const sorted = sortWithTiebreakers(hypotheticalStandings);
            const ourSeedIfTheyLose = sorted.findIndex(t => t.name === teamName) + 1;
            return ourSeedIfTheyLose < targetSeed;
          });
          
          if (teamsToMention.length > 0) {
            details.push(`‚Ä¢ These teams win their remaining games:`);
            teamsToMention.forEach(other => {
              const gamesLeft = calculateRemainingGames(allGames, other.name);
              details.push(`  - ${other.name} (${gamesLeft} game${gamesLeft > 1 ? 's' : ''} left)`);
            });
          } else {
            details.push(`‚Ä¢ Locked into this seed or worse`);
          }
        }
      }
      
      // For middle seeds, find specific combinations
      if (pathType === 'mid') {
        // Try to find a scenario where this team ends up at target seed
        const testSeed = simulateFinalStandings(teamName, team.wins, team.losses, standings, true);
        if (testSeed <= targetSeed) {
          const worstSeed = simulateFinalStandings(teamName, team.wins, team.losses, standings, false);
          if (worstSeed >= targetSeed) {
            foundScenario = true;
            details.push(`‚Ä¢ Specific combination of results from:`);
            relevantTeams.slice(0, 3).forEach(other => {
              const gamesLeft = calculateRemainingGames(allGames, other.name);
              details.push(`  - ${other.name} (${gamesLeft} game${gamesLeft > 1 ? 's' : ''} left)`);
            });
            if (relevantTeams.length > 3) {
              details.push(`  - And ${relevantTeams.length - 3} other team${relevantTeams.length - 3 > 1 ? 's' : ''}`);
            }
            teamsToMention = relevantTeams;
          }
        }
      }
      
      if (!foundScenario) {
        return null; // This seed is not achievable
      }
      
      // Add tiebreaker details if we'd be tied with teams
      const teamsAtSameRecord = teamsToMention.filter(other => {
        const otherGamesLeft = calculateRemainingGames(allGames, other.name);
        const otherMaxWins = other.wins + otherGamesLeft;
        const otherMinWins = other.wins;
        return team.wins >= otherMinWins && team.wins <= otherMaxWins;
      });
      
      if (teamsAtSameRecord.length > 0) {
        details.push(`<br>‚Ä¢ <strong>Tiebreaker context:</strong>`);
        
        // Show current runs allowed rankings among tied teams
        const allInTie = [team, ...teamsAtSameRecord].sort((a, b) => a.runsAgainst - b.runsAgainst);
        details.push(`  Current Runs Allowed:`);
        allInTie.forEach((t, idx) => {
          const marker = t.name === teamName ? '‚Üí ' : '   ';
          details.push(`  ${marker}${idx + 1}. ${t.name}: ${t.runsAgainst} RA`);
        });
        
        const teamRank = allInTie.findIndex(t => t.name === teamName) + 1;
        if (teamRank === 1) {
          const secondPlace = allInTie[1];
          const cushion = secondPlace.runsAgainst - team.runsAgainst;
          details.push(`  Leading by ${cushion} runs - ${secondPlace.name} would need to allow ${cushion + 1}+ fewer runs to pass in tiebreaker`);
        } else {
          const ahead = allInTie[teamRank - 2];
          const deficit = team.runsAgainst - ahead.runsAgainst;
          details.push(`  Behind ${ahead.name} by ${deficit} runs - ${ahead.name} would need to allow ${deficit + 1}+ more runs to fall behind`);
        }
      }
      
      return details.length > 0 ? details.join('<br>') : null;
    }
    
    /**
     * Simulate standings with a specific team at a specific record
     */
    function simulateOtherTeamRecord(targetTeam, currentStandings, finalWins, finalLosses) {
      const hypotheticalStandings = currentStandings.map(team => {
        if (team.name === targetTeam.name) {
          const totalDecided = finalWins + finalLosses;
          return {
            ...team,
            wins: finalWins,
            losses: finalLosses,
            gamesPlayed: totalDecided + team.ties,
            winPct: totalDecided > 0 ? (finalWins / totalDecided) : 0
          };
        }
        return team;
      });
      
      return sortWithTiebreakers(hypotheticalStandings);
    }

    /**
     * Generate detailed scenarios for teams with games remaining
     */
    function generateDetailedScenariosForActiveTeam(team, seed, standings, range) {
      let scenarios = [];
      const teamName = team.name;
      const gamesLeft = range.gamesLeft;
      
      // Check if already clinched
      if (range.bestSeed === 1 && range.worstSeed === 1) {
        return `üèÜ Clinched #1 seed!`;
      }
      
      if (range.bestSeed === range.worstSeed) {
        return `Locked into #${range.bestSeed} seed`;
      }
      
      // Generate header
      scenarios.push(`<div style="font-weight: bold; margin-bottom: 8px;">Can finish #${range.bestSeed} to #${range.worstSeed}</div>`);
      
      // Generate scenarios for best seed (usually involves winning out or winning most)
      const bestSeedDetails = generateComprehensiveSeedPath(team, range.bestSeed, standings, gamesLeft, 'best');
      if (bestSeedDetails) {
        scenarios.push(`<div style="margin-bottom: 12px;"><strong>Path to #${range.bestSeed} Seed:</strong><br>${bestSeedDetails}</div>`);
      }
      
      // Generate scenarios for middle seeds if applicable
      if (range.worstSeed - range.bestSeed > 1) {
        for (let s = range.bestSeed + 1; s < range.worstSeed; s++) {
          const midDetails = generateComprehensiveSeedPath(team, s, standings, gamesLeft, 'mid');
          if (midDetails) {
            scenarios.push(`<div style="margin-bottom: 12px;"><strong>Path to #${s} Seed:</strong><br>${midDetails}</div>`);
          }
        }
      }
      
      // Generate scenarios for worst seed
      if (range.worstSeed > range.bestSeed) {
        const worstSeedDetails = generateComprehensiveSeedPath(team, range.worstSeed, standings, gamesLeft, 'worst');
        if (worstSeedDetails) {
          scenarios.push(`<div style="margin-bottom: 12px;"><strong>Falls to #${range.worstSeed} Seed if:</strong><br>${worstSeedDetails}</div>`);
        }
      }
      
      return scenarios.join('');
    }

    /**
     * Generate comprehensive path to a specific seed with all win/loss combinations
     */
    function generateComprehensiveSeedPath(team, targetSeed, standings, gamesLeft, pathType) {
      const teamName = team.name;
      const details = [];
      
      // Determine which win/loss combinations to explore
      let combinationsToCheck = [];
      if (pathType === 'best') {
        // For best seed, start with winning out
        combinationsToCheck = [
          {wins: gamesLeft, losses: 0, label: `Win ${gamesLeft === 1 ? 'remaining game' : 'all ' + gamesLeft + ' games'}`}
        ];
        if (gamesLeft >= 2) {
          combinationsToCheck.push({wins: gamesLeft - 1, losses: 1, label: `Win ${gamesLeft - 1}, lose 1`});
        }
      } else if (pathType === 'worst') {
        // For worst seed, start with losing out
        combinationsToCheck = [
          {wins: 0, losses: gamesLeft, label: `Lose ${gamesLeft === 1 ? 'remaining game' : 'all ' + gamesLeft + ' games'}`}
        ];
        if (gamesLeft >= 2) {
          combinationsToCheck.push({wins: 1, losses: gamesLeft - 1, label: `Win 1, lose ${gamesLeft - 1}`});
        }
      } else {
        // For middle seeds, check multiple combinations that could lead to this seed
        // Start from most wins and work down
        for (let w = gamesLeft; w >= 0; w--) {
          const l = gamesLeft - w;
          combinationsToCheck.push({
            wins: w, 
            losses: l, 
            label: w === gamesLeft ? `Win all ${gamesLeft} games` :
                   w === 0 ? `Lose all ${gamesLeft} games` :
                   `Win ${w}, lose ${l}`
          });
        }
      }
      
      // Analyze each combination
      for (const combo of combinationsToCheck) {
        const projectedWins = team.wins + combo.wins;
        const projectedLosses = team.losses + combo.losses;
        const projectedRecord = `${projectedWins}-${projectedLosses}`;
        
        // First, verify if this combination actually leads to the target seed
        const bestCaseSeed = simulateFinalStandings(teamName, projectedWins, projectedLosses, standings, true);
        const worstCaseSeed = simulateFinalStandings(teamName, projectedWins, projectedLosses, standings, false);
        
        // Skip this combination if it doesn't lead to the target seed in any scenario
        if (targetSeed < bestCaseSeed || targetSeed > worstCaseSeed) {
          continue;
        }
        
        details.push(`‚Ä¢ <strong>${combo.label}</strong> (finish ${projectedRecord}):`);
        
        // Find teams we'd be tied with at this record
        const tiedTeams = findPotentialTies(team, projectedWins, standings);
        
        // Determine if this guarantees the target seed
        const guaranteesSeed = (bestCaseSeed === worstCaseSeed && bestCaseSeed === targetSeed);
        
        if (tiedTeams.length === 0) {
          // No ties - check if it guarantees this specific seed
          if (guaranteesSeed) {
            details.push(`  Would secure #${targetSeed} seed outright with this record`);
          } else {
            details.push(`  Could finish #${bestCaseSeed} to #${worstCaseSeed} depending on other results`);
          }
        } else if (tiedTeams.length === 1) {
          // 2-way tie - H2H applies
          const other = tiedTeams[0];
          const tieDetails = generate2WayTieDetails(team, other, projectedWins, combo.wins, combo.losses);
          details.push(`  Tied with ${other.name} at ${projectedRecord}:`);
          details.push(`  ${tieDetails}`);
        } else {
          // 3+ way tie - Runs Allowed applies
          const tieDetails = generate3PlusWayTieDetails(team, tiedTeams, projectedWins, combo.wins, combo.losses, targetSeed, standings);
          details.push(`  Tied with ${tiedTeams.length} teams at ${projectedRecord}:`);
          details.push(`  ${tieDetails}`);
        }
        
        // Add spacing between combinations
        if (combo !== combinationsToCheck[combinationsToCheck.length - 1]) {
          details.push('');
        }
      }
      
      return details.length > 0 ? details.join('<br>') : null;
    }

    /**
     * Find teams that could end up tied at a specific win total
     */
    function findPotentialTies(team, projectedWins, standings) {
      const teamName = team.name;
      const tiedTeams = [];
      
      for (const other of standings) {
        if (other.name === teamName) continue;
        
        const otherGamesLeft = calculateRemainingGames(allGames, other.name);
        const otherMaxWins = other.wins + otherGamesLeft;
        const otherMinWins = other.wins;
        
        // Could they end up at our projected wins?
        if (projectedWins >= otherMinWins && projectedWins <= otherMaxWins) {
          tiedTeams.push(other);
        }
      }
      
      return tiedTeams;
    }

    /**
     * Generate details for 2-way tie (H2H tiebreaker)
     */
    function generate2WayTieDetails(team, other, projectedWins, winsToAdd, lossesToAdd) {
      const teamName = team.name;
      const details = [];
      
      const h2h = team.h2h[other.name];
      const playEachOther = teamsPlayEachOther(teamName, other.name, allGames);
      
      if (playEachOther) {
        // They play each other - but we need to determine if the scenario outcome determines the result
        // Calculate how many games each team has left
        const teamGamesLeft = calculateRemainingGames(allGames, teamName);
        const otherGamesLeft = calculateRemainingGames(allGames, other.name);
        
        // If the team is adding exactly as many wins as games remaining, they won all remaining games (including vs other)
        // If the team is adding 0 wins, they lost all remaining games (including vs other)
        // If somewhere in between, the outcome of the direct matchup is uncertain
        
        const teamWinsAll = (winsToAdd === teamGamesLeft);
        const teamLosesAll = (winsToAdd === 0);
        
        // For them to be tied at the same record, calculate what the other team needs
        const otherProjectedWins = projectedWins;
        const otherCurrentWins = other.wins;
        const otherWinsToAdd = otherProjectedWins - otherCurrentWins;
        const otherWinsAll = (otherWinsToAdd === otherGamesLeft);
        const otherLosesAll = (otherWinsToAdd === 0);
        
        // Determine the outcome of the direct matchup based on scenarios
        let directMatchupKnown = false;
        let teamWinsMatchup = false;
        
        if (teamWinsAll && otherLosesAll) {
          // Team wins all, other loses all ‚Üí team wins the matchup
          directMatchupKnown = true;
          teamWinsMatchup = true;
        } else if (teamLosesAll && otherWinsAll) {
          // Team loses all, other wins all ‚Üí other wins the matchup
          directMatchupKnown = true;
          teamWinsMatchup = false;
        } else if (teamGamesLeft === 1 && otherGamesLeft === 1) {
          // Both teams have only 1 game left, and it's against each other
          // If team is projected to win that game (winsToAdd = 1), they win matchup
          // If team is projected to lose that game (winsToAdd = 0), they lose matchup
          directMatchupKnown = true;
          teamWinsMatchup = (winsToAdd === 1);
        }
        
        if (directMatchupKnown) {
          // We know the outcome of the direct matchup from this scenario
          const currentH2HWins = h2h ? h2h.wins : 0;
          const currentH2HLosses = h2h ? h2h.losses : 0;
          const finalH2HWins = currentH2HWins + (teamWinsMatchup ? 1 : 0);
          const finalH2HLosses = currentH2HLosses + (teamWinsMatchup ? 0 : 1);
          
          if (finalH2HWins > finalH2HLosses) {
            details.push(`‚úì Win H2H tiebreaker (${finalH2HWins}-${finalH2HLosses} after remaining matchup) ‚Üí get higher seed`);
          } else if (finalH2HWins < finalH2HLosses) {
            details.push(`‚úó Lose H2H tiebreaker (${finalH2HWins}-${finalH2HLosses} after remaining matchup) ‚Üí get lower seed`);
          } else {
            details.push(`H2H tied (${finalH2HWins}-${finalH2HLosses}) ‚Üí goes to Runs Allowed tiebreaker`);
            generateRunsAllowedDetails(team, other, winsToAdd, lossesToAdd, details);
          }
        } else {
          // Outcome of direct matchup is uncertain in this scenario
          if (!h2h || (h2h.wins + h2h.losses === 0)) {
            details.push(`Winner of remaining H2H matchup gets tiebreaker`);
          } else if (h2h.wins > h2h.losses) {
            details.push(`Currently lead H2H ${h2h.wins}-${h2h.losses}, but remaining matchup could split it ‚Üí would go to Runs Allowed`);
            const raDiff = other.runsAgainst - team.runsAgainst;
            details.push(`Currently ${raDiff > 0 ? 'lead' : 'trail'} by ${Math.abs(raDiff)} runs allowed`);
          } else if (h2h.wins < h2h.losses) {
            details.push(`Currently trail H2H ${h2h.wins}-${h2h.losses}, but remaining matchup could tie it ‚Üí would go to Runs Allowed`);
            const raDiff = other.runsAgainst - team.runsAgainst;
            details.push(`Currently ${raDiff > 0 ? 'lead' : 'trail'} by ${Math.abs(raDiff)} runs allowed`);
          } else {
            details.push(`H2H tied ${h2h.wins}-${h2h.losses}, remaining matchup breaks tie or goes to Runs Allowed if split`);
            const raDiff = other.runsAgainst - team.runsAgainst;
            details.push(`Currently ${raDiff > 0 ? 'lead' : 'trail'} by ${Math.abs(raDiff)} runs allowed`);
          }
        }
      } else {
        // H2H is final
        if (!h2h || (h2h.wins + h2h.losses === 0)) {
          details.push(`No H2H games ‚Üí goes to Runs Allowed tiebreaker`);
          generateRunsAllowedDetails(team, other, winsToAdd, lossesToAdd, details);
        } else if (h2h.wins > h2h.losses) {
          details.push(`‚úì Win H2H tiebreaker (${h2h.wins}-${h2h.losses}) ‚Üí get higher seed`);
        } else if (h2h.wins < h2h.losses) {
          details.push(`‚úó Lose H2H tiebreaker (${h2h.wins}-${h2h.losses}) ‚Üí get lower seed`);
        } else {
          details.push(`H2H tied (${h2h.wins}-${h2h.losses}) ‚Üí goes to Runs Allowed tiebreaker`);
          generateRunsAllowedDetails(team, other, winsToAdd, lossesToAdd, details);
        }
      }
      
      return details.join('<br>  ');
    }

    /**
     * Generate details for 3+ way tie (Runs Allowed tiebreaker)
     */
    function generate3PlusWayTieDetails(team, tiedTeams, projectedWins, winsToAdd, lossesToAdd, targetSeed, standings) {
      const teamName = team.name;
      const details = [];
      
      details.push(`3+ way tie ‚Üí H2H skipped, uses Runs Allowed tiebreaker`);
      details.push(`Current Runs Allowed rankings:`);
      
      // Sort all tied teams by runs allowed
      const allInTie = [team, ...tiedTeams].sort((a, b) => a.runsAgainst - b.runsAgainst);
      allInTie.forEach((t, idx) => {
        const marker = t.name === teamName ? '‚Üí ' : '   ';
        details.push(`${marker}${idx + 1}. ${t.name}: ${t.runsAgainst} RA`);
      });
      
      // Calculate the best possible seed available to this tied group
      // This is the seed of the highest-ranked team in the tie
      const baseSeed = Math.min(...allInTie.map(t => {
        const idx = standings.findIndex(st => st.name === t.name);
        return idx + 1;
      }));
      
      // Calculate what RA ranking position corresponds to the target seed
      // If baseSeed is #4 and targetSeed is #5, need to be 2nd in RA (5 - 4 + 1 = 2)
      const raRankingNeeded = targetSeed - baseSeed + 1;
      
      // Get current RA ranking
      const currentRank = allInTie.findIndex(t => t.name === teamName) + 1;
      const teamRA = team.runsAgainst;
      
      // Explain what's needed for THIS specific seed
      details.push(``);
      details.push(`<strong>To finish #${targetSeed} seed:</strong>`);
      
      if (raRankingNeeded === 1) {
        details.push(`Need to have the FEWEST runs allowed among all tied teams`);
        if (currentRank === 1) {
          const secondPlace = allInTie[1];
          const cushion = secondPlace.runsAgainst - teamRA;
          details.push(`Currently 1st - maintain by allowing ${cushion}+ fewer runs than ${secondPlace.name}`);
        } else {
          const firstPlace = allInTie[0];
          const deficit = teamRA - firstPlace.runsAgainst;
          details.push(`Currently ${currentRank}${getOrdinalSuffix(currentRank)} - need to allow ${deficit + 1}+ fewer runs than ${firstPlace.name} over remaining ${winsToAdd + lossesToAdd} game${winsToAdd + lossesToAdd > 1 ? 's' : ''}`);
        }
      } else if (raRankingNeeded === allInTie.length) {
        details.push(`Would finish with the MOST runs allowed among all tied teams`);
        if (currentRank === allInTie.length) {
          details.push(`Currently last in RA - would stay at this seed even if allowing more runs`);
        } else {
          const lastPlace = allInTie[allInTie.length - 1];
          const gap = lastPlace.runsAgainst - teamRA;
          details.push(`Currently ${currentRank}${getOrdinalSuffix(currentRank)} - would drop to this seed if allowing ${gap + 1}+ more runs than ${lastPlace.name}`);
        }
      } else {
        details.push(`Need to finish ${raRankingNeeded}${getOrdinalSuffix(raRankingNeeded)} in runs allowed among tied teams`);
        
        if (currentRank === raRankingNeeded) {
          // Already at the right position
          const above = allInTie[raRankingNeeded - 2];
          const below = allInTie[raRankingNeeded];
          const cushionAbove = teamRA - above.runsAgainst;
          const cushionBelow = below.runsAgainst - teamRA;
          details.push(`Currently ${raRankingNeeded}${getOrdinalSuffix(raRankingNeeded)} - maintain position by:`);
          details.push(`  - Keeping within ${cushionAbove} runs of ${above.name} (${cushionAbove + 1}+ would drop below them)`);
          details.push(`  - Staying ${cushionBelow}+ runs better than ${below.name}`);
        } else if (currentRank < raRankingNeeded) {
          // Currently too high, need to allow more runs to drop to target
          const targetTeam = allInTie[raRankingNeeded - 1];
          details.push(`Currently ${currentRank}${getOrdinalSuffix(currentRank)} (too high) - would need to allow more runs than ${targetTeam.name} to drop to ${raRankingNeeded}${getOrdinalSuffix(raRankingNeeded)}`);
        } else {
          // Currently too low, need to allow fewer runs to climb to target
          const targetTeam = allInTie[raRankingNeeded - 1];
          const deficit = teamRA - targetTeam.runsAgainst;
          details.push(`Currently ${currentRank}${getOrdinalSuffix(currentRank)} - need to allow ${deficit + 1}+ fewer runs than ${targetTeam.name} over remaining ${winsToAdd + lossesToAdd} game${winsToAdd + lossesToAdd > 1 ? 's' : ''} to reach ${raRankingNeeded}${getOrdinalSuffix(raRankingNeeded)}`);
        }
      }
      
      return details.join('<br>  ');
    }
    
    /**
     * Get ordinal suffix for a number (1st, 2nd, 3rd, etc.)
     */
    function getOrdinalSuffix(num) {
      const j = num % 10;
      const k = num % 100;
      if (j === 1 && k !== 11) return 'st';
      if (j === 2 && k !== 12) return 'nd';
      if (j === 3 && k !== 13) return 'rd';
      return 'th';
    }

    /**
     * Generate specific runs allowed differential details
     */
    function generateRunsAllowedDetails(team, other, winsToAdd, lossesToAdd, details) {
      const teamRA = team.runsAgainst;
      const otherRA = other.runsAgainst;
      const diff = teamRA - otherRA;
      const gamesRemaining = winsToAdd + lossesToAdd;
      const otherGamesLeft = calculateRemainingGames(allGames, other.name);
      
      if (diff > 0) {
        // We've allowed more runs - need to make up ground
        details.push(`Currently allowed ${diff} more runs than ${other.name}`);
        details.push(`Need to allow ${diff + 1}+ fewer runs over ${gamesRemaining} game${gamesRemaining > 1 ? 's' : ''}`);
      } else if (diff < 0) {
        // We've allowed fewer - have advantage
        details.push(`Currently allowed ${Math.abs(diff)} fewer runs than ${other.name}`);
        details.push(`${other.name} would need to allow ${Math.abs(diff) + 1}+ fewer runs over their ${otherGamesLeft} game${otherGamesLeft > 1 ? 's' : ''}`);
      } else {
        // Tied
        details.push(`Currently tied in runs allowed (${teamRA} each)`);
        details.push(`Whoever allows fewer runs over remaining games gets tiebreaker`);
        details.push(`If still tied ‚Üí goes to Run Differential (${team.runDifferential} vs ${other.runDifferential})`);
      }
    }

    function getSeedStatus(seed, magicNumber) {
      // Status based on current seed position, not magic number
      if (seed <= 2) {
        return { status: 'safe', badge: 'status-safe', text: 'TOP SEED' };
      } else if (seed <= 6) {
        return { status: 'contention', badge: 'status-contention', text: 'MID SEED' };
      } else {
        return { status: 'danger', badge: 'status-danger', text: 'PLAY-IN' };
      }
    }

    let allGames = [];

    async function loadData() {
      try {
        console.log('üîÑ Loading playoff seeding data...');
        
        const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
        
        const season = await getCurrentSeason();
        console.log('üìÖ Current season:', season);
        
        if (!season) {
          console.error('‚ùå No active season found');
          showError();
          return;
        }

        const gamesRaw = await getSeasonGames(season.id);
        console.log(`üìä Loaded ${gamesRaw.length} total games (raw)`);
        console.log('Sample raw game:', gamesRaw[0]);
        
        // Transform data to match current-season.html format
        allGames = (gamesRaw || []).map(g => {
          let dateString = "";
          if (g.date && g.date.seconds) {
            const dateObj = new Date(g.date.seconds * 1000);
            dateString = dateObj.toLocaleDateString('en-US');
          } else if (g.date) {
            dateString = g.date;
          }
          
          return {
            "home team": g.homeTeamName || capitalize(g.homeTeamId) || "",
            "away team": g.awayTeamName || capitalize(g.awayTeamId) || "",
            "home score": g.homeScore !== undefined ? g.homeScore : null,
            "away score": g.awayScore !== undefined ? g.awayScore : null,
            winner: capitalize(g.winner),
            game_type: g.gameType === "regular" ? "Regular" :
                       g.gameType === "playoff" ? "Playoff" :
                       capitalize(g.gameType) || "Regular",
            date: dateString,
            forfeit: g.forfeit ? "Yes" : "No",
            status: g.status || "",
            id: g.id || ""
          };
        });
        
        console.log(`‚úÖ Transformed ${allGames.length} games`);
        console.log('Sample transformed game:', allGames[0]);
        
        const completedGames = allGames.filter(g => {
          const gameDate = parseGameDate(g.date);
          const isPast = gameDate < today;
          const hasWinner = g.winner && g.winner.trim() !== "";
          const isRegular = g.game_type === 'Regular';
          return isPast && hasWinner && isRegular;
        });
        console.log(`‚úÖ ${completedGames.length} completed regular season games`);

        const upcomingGames = allGames.filter(g => {
          const gameDate = parseGameDate(g.date);
          const isFuture = gameDate >= today;
          const noWinner = !g.winner || g.winner.trim() === "";
          const isRegularSeason = g.game_type === 'Regular';
          return isFuture && noWinner && isRegularSeason;
        });
        console.log(`‚è∞ ${upcomingGames.length} upcoming regular season games`);

        const standings = calculateStandings(completedGames);
        console.log(`üèÜ Calculated standings for ${standings.length} teams:`, standings);
        
        if (standings.length === 0) {
          console.warn('‚ö†Ô∏è No standings data - no completed games yet?');
          document.getElementById('clinchingTableBody').innerHTML = `
            <tr><td colspan="8" class="no-data">No standings data yet. Games need to be played and completed first.</td></tr>
          `;
          return;
        }
        
        updateSummary(standings, upcomingGames);
        updateSeedingTable(standings, upcomingGames);
        updateKeyMatchups(standings, upcomingGames);
        updateSeedingBattles(standings, upcomingGames);
        
        console.log('‚úÖ All data loaded and displayed successfully!');

      } catch (error) {
        console.error('‚ùå Error loading data:', error);
        console.error('Error stack:', error.stack);
        showError();
      }
    }

    function updateSummary(standings, upcomingGames) {
      let lockedSeeds = 0;
      let byeSeeds = 0; // Seeds 1-6 (direct to round 1)
      let playInTeams = 0; // Seeds 7-10

      standings.slice(0, TOTAL_TEAMS).forEach((team, index) => {
        const seed = index + 1;
        const range = calculateSeedRange(team, standings, allGames);
        
        // Count locked seeds
        if (range.bestSeed === range.worstSeed) {
          lockedSeeds++;
        }
        
        // Count current positioning
        if (seed <= 6) {
          byeSeeds++;
        } else {
          playInTeams++;
        }
      });

      document.getElementById('clinched').textContent = lockedSeeds;
      document.getElementById('byeSeeds').textContent = byeSeeds;
      document.getElementById('playInTeams').textContent = playInTeams;
      document.getElementById('gamesRemaining').textContent = upcomingGames.length;
    }

    function updateSeedingTable(standings, upcomingGames) {
      const tbody = document.getElementById('clinchingTableBody');
      tbody.innerHTML = '';

      // Only show top 10 teams (all make playoffs)
      standings.slice(0, TOTAL_TEAMS).forEach((team, index) => {
        const seed = index + 1;
        const gamesLeft = calculateRemainingGames(allGames, team.name);
        const range = calculateSeedRange(team, standings, allGames);
        const statusInfo = getSeedStatus(seed);
        const scenario = generateSeedingScenario(team, seed, standings);

        // Display seed range in magic # column
        let magicDisplay;
        if (range.bestSeed === range.worstSeed) {
          magicDisplay = `#${range.bestSeed}`;
        } else {
          magicDisplay = `#${range.bestSeed}-${range.worstSeed}`;
        }

        const row = document.createElement('tr');
        row.innerHTML = `
          <td><strong>#${seed}</strong></td>
          <td class="team-name">${team.name}</td>
          <td>${team.wins}-${team.losses}${team.ties > 0 ? `-${team.ties}` : ''}</td>
          <td>${(team.winPct * 100).toFixed(1)}%</td>
          <td><span class="status-badge ${statusInfo.badge}">${statusInfo.text}</span></td>
          <td><span class="magic-number">${magicDisplay}</span></td>
          <td>${gamesLeft}</td>
          <td class="scenario-text">${scenario}</td>
        `;
        tbody.appendChild(row);
      });
    }

    function updateKeyMatchups(standings, upcomingGames) {
      const container = document.getElementById('keyMatchupsContent');
      container.classList.remove('loading');

      // Find matchups between teams within 3 seeds of each other
      const keyGames = upcomingGames.filter(g => {
        const homeRank = standings.findIndex(t => t.name === g['home team']) + 1;
        const awayRank = standings.findIndex(t => t.name === g['away team']) + 1;
        return Math.abs(homeRank - awayRank) <= 3 && homeRank <= 10 && awayRank <= 10;
      }).slice(0, 10);

      if (keyGames.length === 0) {
        container.innerHTML = '<div class="no-data">No key seeding matchups remaining.</div>';
        return;
      }

      const html = `
        <table class="clinching-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Matchup</th>
              <th>Seeding Impact</th>
            </tr>
          </thead>
          <tbody>
            ${keyGames.map(game => {
              const homeRank = standings.findIndex(t => t.name === game['home team']) + 1;
              const awayRank = standings.findIndex(t => t.name === game['away team']) + 1;
              
              let impact = '';
              if (homeRank <= 2 && awayRank <= 2) {
                impact = 'üèÜ Top Seed Battle';
              } else if (homeRank === 6 || awayRank === 6 || homeRank === 7 || awayRank === 7) {
                impact = '‚ö†Ô∏è Play-In Line';
              } else if (Math.abs(homeRank - awayRank) === 1) {
                impact = 'üîÑ Direct Swap Possible';
              } else {
                impact = 'üìä Seeding Impact';
              }
              
              return `
                <tr>
                  <td>${game.date}</td>
                  <td>
                    <strong>#${homeRank} ${game['home team']}</strong> vs <strong>#${awayRank} ${game['away team']}</strong>
                  </td>
                  <td>${impact}</td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      `;

      container.innerHTML = html;
    }

    function updateSeedingBattles(standings, upcomingGames) {
      const container = document.getElementById('bubbleContent');
      container.classList.remove('loading');

      // Focus on three key battles:
      // 1. Top seed battle (seeds 1-3)
      // 2. Play-in avoidance (seeds 5-7)
      // 3. Play-in seeding (seeds 8-10)

      const topSeeds = standings.slice(0, 3);
      const playInBattle = standings.slice(4, 7);
      const playInSeeding = standings.slice(7, 10);

      const html = `
        <div style="margin-bottom: 2rem;">
          <h4 style="margin-bottom: 1rem; color: var(--primary-color);">üèÜ Top Seed Battle (Seeds 1-3)</h4>
          <p style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
            These teams will face play-in winners. Fighting for #1 seed and home field advantage.
          </p>
          <table class="clinching-table">
            <thead>
              <tr>
                <th>Seed</th>
                <th>Team</th>
                <th>Record</th>
                <th>Win%</th>
                <th>Games Left</th>
                <th>Path Forward</th>
              </tr>
            </thead>
            <tbody>
              ${topSeeds.map((team, index) => {
                const seed = index + 1;
                const gamesLeft = calculateRemainingGames(allGames, team.name);
                const range = calculateSeedRange(team, standings, allGames);
                const magicFor1 = calculateMagicNumberForSeed(team, 1, standings);
                
                let path = '';
                if (seed === 1) {
                  if (range.bestSeed === range.worstSeed && range.bestSeed === 1) {
                    path = 'Clinched #1 seed! üèÜ';
                  } else if (magicFor1 > 0 && magicFor1 <= gamesLeft) {
                    path = `${magicFor1} win${magicFor1 > 1 ? 's' : ''} clinches #1`;
                  } else {
                    path = 'Controls destiny for #1';
                  }
                } else {
                  const gamesBack = ((standings[0].winPct - team.winPct) * team.gamesPlayed).toFixed(1);
                  if (range.bestSeed === 1) {
                    path = `${gamesBack} GB from #1 (can catch with wins)`;
                  } else {
                    path = `${gamesBack} GB from #1 seed`;
                  }
                }

                return `
                  <tr>
                    <td><strong>#${seed}</strong></td>
                    <td class="team-name">${team.name}</td>
                    <td>${team.wins}-${team.losses}${team.ties > 0 ? `-${team.ties}` : ''}</td>
                    <td>${(team.winPct * 100).toFixed(1)}%</td>
                    <td>${gamesLeft}</td>
                    <td class="scenario-text">${path}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>

        <div style="margin-bottom: 2rem;">
          <h4 style="margin-bottom: 1rem; color: var(--warning-yellow);">‚ö†Ô∏è Play-In Avoidance (Seeds 5-7)</h4>
          <p style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
            Seeds 1-6 go directly to Round 1. Seeds 7-10 must win play-in games. This is the critical line!
          </p>
          <table class="clinching-table">
            <thead>
              <tr>
                <th>Seed</th>
                <th>Team</th>
                <th>Record</th>
                <th>Win%</th>
                <th>Games Left</th>
                <th>Battle Status</th>
              </tr>
            </thead>
            <tbody>
              ${playInBattle.map((team, index) => {
                const seed = index + 5;
                const gamesLeft = calculateRemainingGames(allGames, team.name);
                const range = calculateSeedRange(team, standings, allGames);
                
                let status = '';
                if (seed === 6) {
                  if (range.worstSeed === 6) {
                    status = 'Locked in last direct Round 1 spot';
                  } else if (range.worstSeed >= 7) {
                    status = 'Last direct spot - at risk of play-in';
                  } else {
                    status = 'Secure in direct Round 1 position';
                  }
                } else if (seed === 7) {
                  if (range.bestSeed <= 6) {
                    const gamesBack = ((standings[5].winPct - team.winPct) * team.gamesPlayed).toFixed(1);
                    status = `${gamesBack} GB from avoiding play-in (can reach #6)`;
                  } else {
                    status = 'Locked into play-in games';
                  }
                } else {
                  if (range.bestSeed <= 6) {
                    const gamesBack = ((standings[5].winPct - team.winPct) * team.gamesPlayed).toFixed(1);
                    status = `${gamesBack} GB from top 6 (can avoid play-in)`;
                  } else {
                    status = 'Locked into play-in games';
                  }
                }

                return `
                  <tr>
                    <td><strong>#${seed}</strong></td>
                    <td class="team-name">${team.name}</td>
                    <td>${team.wins}-${team.losses}${team.ties > 0 ? `-${team.ties}` : ''}</td>
                    <td>${(team.winPct * 100).toFixed(1)}%</td>
                    <td>${gamesLeft}</td>
                    <td class="scenario-text">${status}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>

        <div>
          <h4 style="margin-bottom: 1rem; color: var(--danger-red);">üé± Play-In Seeding (Seeds 8-10)</h4>
          <p style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
            These teams will play play-in games. #7 vs #10, #8 vs #9. Winners face #2 and #1 respectively.
          </p>
          <table class="clinching-table">
            <thead>
              <tr>
                <th>Seed</th>
                <th>Team</th>
                <th>Record</th>
                <th>Win%</th>
                <th>Games Left</th>
                <th>Play-In Matchup</th>
              </tr>
            </thead>
            <tbody>
              ${playInSeeding.map((team, index) => {
                const seed = index + 8;
                const gamesLeft = calculateRemainingGames(allGames, team.name);
                const range = calculateSeedRange(team, standings, allGames);
                
                let matchup = '';
                if (seed === 8) {
                  if (range.bestSeed === range.worstSeed && range.bestSeed === 8) {
                    matchup = 'Locked - will face #9 seed';
                  } else {
                    matchup = `Could finish #${range.bestSeed}-${range.worstSeed} (currently vs #9)`;
                  }
                } else if (seed === 9) {
                  if (range.bestSeed === range.worstSeed && range.bestSeed === 9) {
                    matchup = 'Locked - will face #8 seed';
                  } else {
                    matchup = `Could finish #${range.bestSeed}-${range.worstSeed} (currently vs #8)`;
                  }
                } else if (seed === 10) {
                  if (range.bestSeed === range.worstSeed && range.bestSeed === 10) {
                    matchup = 'Locked - will face #7 seed';
                  } else {
                    matchup = `Could finish #${range.bestSeed}-${range.worstSeed} (currently vs #7)`;
                  }
                }

                return `
                  <tr>
                    <td><strong>#${seed}</strong></td>
                    <td class="team-name">${team.name}</td>
                    <td>${team.wins}-${team.losses}${team.ties > 0 ? `-${team.ties}` : ''}</td>
                    <td>${(team.winPct * 100).toFixed(1)}%</td>
                    <td>${gamesLeft}</td>
                    <td class="scenario-text">${matchup}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;

      container.innerHTML = html;
    }

    function showError() {
      const errorHtml = '<div class="no-data">Error loading data. Please try again later.</div>';
      document.getElementById('summaryGrid').innerHTML = errorHtml;
      document.getElementById('clinchingTableBody').innerHTML = `<tr><td colspan="8">${errorHtml}</td></tr>`;
      document.getElementById('keyMatchupsContent').innerHTML = errorHtml;
      document.getElementById('bubbleContent').innerHTML = errorHtml;
    }

    document.addEventListener('DOMContentLoaded', loadData);
  </script>
  <script src="team-colors.js"></script>
<!-- Load navigation -->
<script type="module">
  import { NavigationComponent } from './nav-component.js';
  // Navigation auto-initializes on load!
</script>
<script src="mobile-enhancements.js"></script>
</body>
</html>

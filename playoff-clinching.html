<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Mountainside Aces">
<title>Playoff Seeding Scenarios - Mountainside Aces</title>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="mobile-enhancements.css">
<style>
  :root {
    --primary-color: #2d5016;
    --secondary-color: #1a6b4a;
    --accent-color: #ffd700;
    --card-bg: #ffffff;
    --text-dark: #2d3748;
    --text-light: #718096;
    --border-color: #e2e8f0;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
    --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
    --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
    --clinched-green: #10b981;
    --danger-red: #ef4444;
    --warning-yellow: #f59e0b;
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    min-height: 100vh;
    color: var(--text-dark);
  }

  /* Loading Spinner */
  .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 0.5s ease;
  }

  .loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .softball-spinner {
    width: 80px;
    height: 80px;
    position: relative;
    animation: spin 1.5s ease-in-out infinite;
  }

  .softball-spinner::before {
    content: '‚öæ';
    font-size: 80px;
    position: absolute;
    top: 0;
    left: 0;
  }

  @keyframes spin {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
  }

  /* Header - Pumpkin theme for playoff scenarios */
  .header {
    background: linear-gradient(135deg, #ff6347 0%, #ff8c42 100%);
    color: white;
    text-align: center;
    padding: 4rem 2rem;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
  }

  .header::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -10%;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }

  .header::after {
    content: 'üé±';
    position: absolute;
    bottom: -30px;
    left: 10%;
    font-size: 120px;
    opacity: 0.15;
    transform: rotate(-15deg);
  }
  
  .header h1 {
    margin: 0;
    font-size: 3.5rem;
    font-weight: 800;
    text-shadow: 2px 4px 8px rgba(0,0,0,0.2);
    letter-spacing: -0.5px;
    position: relative;
    z-index: 1;
  }
  
  .header p {
    margin: 1rem 0 0 0;
    font-size: 1.3rem;
    opacity: 0.95;
    font-weight: 300;
    position: relative;
    z-index: 1;
  }

  .container {
    max-width: 1400px;
    margin: 3rem auto;
    padding: 0 2rem;
  }

  /* Modern Section Styling */
  .section {
    background: var(--card-bg);
    border-radius: 16px;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-sm);
    border: 1px solid var(--border-color);
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .section:hover {
    box-shadow: var(--shadow-md);
  }

  .section-header {
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    color: white;
    padding: 1.5rem 2rem;
    font-size: 1.5rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 0.8rem;
    position: relative;
  }

  .section-header::after {
    content: '‚öæ';
    position: absolute;
    right: 2rem;
    font-size: 2rem;
    opacity: 0.2;
  }

  .section-content {
    padding: 2rem;
  }

  /* Summary Cards */
  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .summary-card {
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
    border-radius: 12px;
    padding: 1.5rem;
    text-align: center;
    border-left: 4px solid var(--primary-color);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
  }

  .summary-card.clinched {
    border-left-color: var(--clinched-green);
  }

  .summary-card.danger {
    border-left-color: var(--danger-red);
  }

  .summary-card.warning {
    border-left-color: var(--warning-yellow);
  }

  .summary-card::before {
    content: '‚öæ';
    position: absolute;
    bottom: -10px;
    right: -10px;
    font-size: 60px;
    opacity: 0.05;
  }

  .summary-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-md);
  }

  .summary-number {
    font-size: 2rem;
    font-weight: 800;
    color: var(--text-dark);
    margin-bottom: 0.5rem;
  }

  .summary-label {
    font-size: 0.9rem;
    color: var(--text-light);
    font-weight: 500;
  }

  /* Clinching Table */
  .clinching-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1rem;
    font-size: 0.9rem;
  }

  .clinching-table th,
  .clinching-table td {
    padding: 12px 10px;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
  }

  .clinching-table th {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    font-weight: 600;
    color: var(--text-dark);
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .clinching-table tbody tr {
    transition: background-color 0.2s ease;
  }

  .clinching-table tbody tr:hover {
    background-color: #f8fafc;
  }

  .team-name {
    font-weight: 600;
    color: var(--text-dark);
  }

  .status-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .status-clinched {
    background-color: #d1fae5;
    color: #065f46;
  }

  .status-eliminated {
    background-color: #fee2e2;
    color: #991b1b;
  }

  .status-safe {
    background-color: #dbeafe;
    color: #1e40af;
  }

  .status-danger {
    background-color: #fef3c7;
    color: #92400e;
  }

  .status-contention {
    background-color: #e0e7ff;
    color: #3730a3;
  }

  .magic-number {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--primary-color);
  }

  .magic-number.low {
    color: var(--clinched-green);
  }

  .magic-number.high {
    color: var(--danger-red);
  }

  .scenario-text {
    font-size: 0.85rem;
    color: var(--text-light);
    line-height: 1.4;
  }

  .no-data {
    text-align: center;
    padding: 3rem;
    color: var(--text-light);
  }

  .no-data h4 {
    margin: 0 0 0.5rem 0;
    color: var(--text-dark);
  }

  /* Legend */
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    padding: 1rem;
    background: #f8f9fa;
    border-radius: 8px;
    margin-top: 1rem;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
  }

  .legend-color {
    width: 20px;
    height: 20px;
    border-radius: 4px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .header h1 {
      font-size: 2.5rem;
    }

    .header p {
      font-size: 1.1rem;
    }

    .summary-grid {
      grid-template-columns: 1fr;
    }

    .clinching-table {
      font-size: 0.8rem;
    }

    .clinching-table th,
    .clinching-table td {
      padding: 8px 6px;
    }
  }
</style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="softball-spinner"></div>
  </div>

  <!-- Header -->
  <div class="header">
    <h1>üé± Playoff Seeding Scenarios</h1>
    <p>All 10 teams make playoffs - Fight for your seed!</p>
  </div>

  <!-- Main Content -->
  <div class="container">
    <!-- Summary Section -->
    <div class="section">
      <div class="section-header">üìä Playoff Seeding Summary</div>
      <div class="section-content">
        <div class="summary-grid" id="summaryGrid">
          <div class="summary-card clinched">
            <div class="summary-number" id="clinched">-</div>
            <div class="summary-label">Seeds Locked</div>
          </div>
          <div class="summary-card">
            <div class="summary-number" id="byeSeeds">-</div>
            <div class="summary-label">Direct to Round 1</div>
          </div>
          <div class="summary-card warning">
            <div class="summary-number" id="playInTeams">-</div>
            <div class="summary-label">Play-In Games</div>
          </div>
          <div class="summary-card">
            <div class="summary-number" id="gamesRemaining">-</div>
            <div class="summary-label">Total Games Remaining</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Seeding Scenarios -->
    <div class="section">
      <div class="section-header">üèÜ Team-by-Team Seeding Scenarios</div>
      <div class="section-content">
        <div style="overflow-x: auto;">
          <table class="clinching-table">
            <thead>
              <tr>
                <th>Seed</th>
                <th>Team</th>
                <th>Record</th>
                <th>Win%</th>
                <th>Status</th>
                <th>Seed Range</th>
                <th>Games Left</th>
                <th>Seeding Scenario</th>
              </tr>
            </thead>
            <tbody id="clinchingTableBody">
              <tr>
                <td colspan="8" class="loading">Loading seeding scenarios...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Legend -->
        <div class="legend">
          <div class="legend-item">
            <span class="status-badge status-safe">Top Seed</span>
            <span>Seeds 1-2 (vs play-in winners)</span>
          </div>
          <div class="legend-item">
            <span class="status-badge status-contention">Mid Seed</span>
            <span>Seeds 3-6 (direct to round 1)</span>
          </div>
          <div class="legend-item">
            <span class="status-badge status-danger">Play-In</span>
            <span>Seeds 7-10 (must win play-in)</span>
          </div>
        </div>
        <div style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; font-size: 0.85rem; color: #666;">
          <strong>Seed Range:</strong> Shows possible final seeds based on all remaining games. 
          <strong>#3</strong> = locked into that seed | 
          <strong>#2-4</strong> = can finish anywhere in that range
        </div>
      </div>
    </div>

    <!-- Key Matchups -->
    <div class="section">
      <div class="section-header">‚öîÔ∏è Key Remaining Matchups</div>
      <div class="section-content">
        <div id="keyMatchupsContent" class="loading">Loading key matchups...</div>
      </div>
    </div>

    <!-- Seeding Battles -->
    <div class="section">
      <div class="section-header">‚öîÔ∏è Key Seeding Battles</div>
      <div class="section-content">
        <div id="bubbleContent" class="loading">Loading seeding battles...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { db, getDocs, collection, query, where } from './firebase-config.js';

    // Wait for page load
    window.addEventListener('load', function() {
      setTimeout(function() {
        document.getElementById('loadingOverlay').classList.add('hidden');
      }, 800);
    });

    const TOTAL_TEAMS = 10; // All 10 teams make playoffs
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    /**
     * Parse game date - dates are already transformed to strings in loadData
     * @param {string} dateValue - Date as string "M/D/YYYY"
     * @returns {Date} JavaScript Date object
     */
    function parseGameDate(dateValue) {
      return new Date(dateValue);
    }

    /**
     * Get the current active season
     * @returns {Promise<Object>} Active season object
     */
    async function getCurrentSeason() {
      try {
        const q = query(
          collection(db, 'seasons'),
          where('isActive', '==', true)
        );
        const seasonsSnapshot = await getDocs(q);
        
        if (seasonsSnapshot.empty) {
          return null;
        }
        
        const seasonDoc = seasonsSnapshot.docs[0];
        return {
          id: seasonDoc.id,
          ...seasonDoc.data()
        };
      } catch (error) {
        console.error('Error fetching current season:', error);
        return null;
      }
    }

    /**
     * Get all games for a season
     * @param {string} seasonId - Season ID (e.g., "2025-fall")
     * @returns {Promise<Array>} Array of game objects
     */
    async function getSeasonGames(seasonId) {
      try {
        const gamesSnapshot = await getDocs(
          collection(db, 'seasons', seasonId, 'games')
        );
        return gamesSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
      } catch (error) {
        console.error('Error fetching season games:', error);
        return [];
      }
    }

    function calculateStandings(games) {
      const teamStats = {};
      
      games.forEach(game => {
        const homeTeam = game['home team'];
        const awayTeam = game['away team'];
        const winner = game.winner;
        const homeScore = parseInt(game['home score']) || 0;
        const awayScore = parseInt(game['away score']) || 0;
        
        if (!teamStats[homeTeam]) {
          teamStats[homeTeam] = { 
            name: homeTeam, 
            wins: 0, 
            losses: 0, 
            ties: 0, 
            gamesPlayed: 0, 
            runsFor: 0, 
            runsAgainst: 0,
            h2h: {} // Head-to-head records
          };
        }
        if (!teamStats[awayTeam]) {
          teamStats[awayTeam] = { 
            name: awayTeam, 
            wins: 0, 
            losses: 0, 
            ties: 0, 
            gamesPlayed: 0, 
            runsFor: 0, 
            runsAgainst: 0,
            h2h: {}
          };
        }
        
        teamStats[homeTeam].gamesPlayed++;
        teamStats[awayTeam].gamesPlayed++;
        teamStats[homeTeam].runsFor += homeScore;
        teamStats[homeTeam].runsAgainst += awayScore;
        teamStats[awayTeam].runsFor += awayScore;
        teamStats[awayTeam].runsAgainst += homeScore;
        
        // Initialize h2h records
        if (!teamStats[homeTeam].h2h[awayTeam]) {
          teamStats[homeTeam].h2h[awayTeam] = { wins: 0, losses: 0, ties: 0 };
        }
        if (!teamStats[awayTeam].h2h[homeTeam]) {
          teamStats[awayTeam].h2h[homeTeam] = { wins: 0, losses: 0, ties: 0 };
        }
        
        if (winner === "Tie") {
          teamStats[homeTeam].ties++;
          teamStats[awayTeam].ties++;
          teamStats[homeTeam].h2h[awayTeam].ties++;
          teamStats[awayTeam].h2h[homeTeam].ties++;
        } else if (winner === homeTeam) {
          teamStats[homeTeam].wins++;
          teamStats[awayTeam].losses++;
          teamStats[homeTeam].h2h[awayTeam].wins++;
          teamStats[awayTeam].h2h[homeTeam].losses++;
        } else if (winner === awayTeam) {
          teamStats[awayTeam].wins++;
          teamStats[homeTeam].losses++;
          teamStats[awayTeam].h2h[homeTeam].wins++;
          teamStats[homeTeam].h2h[awayTeam].losses++;
        }
      });
      
      const standings = Object.values(teamStats).map(team => {
        const totalDecided = team.wins + team.losses;
        return {
          ...team,
          winPct: totalDecided > 0 ? (team.wins / totalDecided) : 0,
          runDifferential: team.runsFor - team.runsAgainst
        };
      });
      
      // Sort with proper tiebreakers that handle 3+ team ties correctly
      return sortWithTiebreakers(standings);
    }
    
    function compareHeadToHead(teamA, teamB) {
      const aVsB = teamA.h2h[teamB.name];
      const bVsA = teamB.h2h[teamA.name];
      
      // No head-to-head data or 3+ team tie (can't use h2h)
      if (!aVsB || !bVsA) return 0;
      
      const aH2HWinPct = (aVsB.wins + aVsB.losses) > 0 ? aVsB.wins / (aVsB.wins + aVsB.losses) : 0;
      const bH2HWinPct = (bVsA.wins + bVsA.losses) > 0 ? bVsA.wins / (bVsA.wins + bVsA.losses) : 0;
      
      // Only return if there's a clear winner in h2h
      if (aH2HWinPct !== bH2HWinPct) {
        return bH2HWinPct - aH2HWinPct;
      }
      
      return 0; // H2H is tied, move to next tiebreaker
    }

    function calculateRemainingGames(games, teamName) {
      return games.filter(g => {
        const isFuture = parseGameDate(g.date) >= today;
        const noWinner = !g.winner || g.winner.trim() === "";
        const isRegularSeason = g.game_type === 'Regular';
        const involvesTeam = g['home team'] === teamName || g['away team'] === teamName;
        return isFuture && noWinner && isRegularSeason && involvesTeam;
      }).length;
    }

    /**
     * Calculate best and worst possible seeds for a team by simulating outcomes
     */
    function calculateSeedRange(team, standings, upcomingGames) {
      const teamName = team.name;
      const currentWins = team.wins;
      const gamesLeft = calculateRemainingGames(allGames, teamName);
      
      // Best case: team wins all remaining games (or current record if done)
      const bestWins = currentWins + gamesLeft;
      const bestLosses = team.losses;
      
      // Worst case: team loses all remaining games (or current record if done)
      const worstWins = currentWins;
      const worstLosses = team.losses + gamesLeft;
      
      // Simulate best case scenario (other teams lose)
      let bestSeed = simulateFinalStandings(teamName, bestWins, bestLosses, standings, true);
      
      // Simulate worst case scenario (other teams win)
      let worstSeed = simulateFinalStandings(teamName, worstWins, worstLosses, standings, false);
      
      return { bestSeed, worstSeed, bestWins, worstWins, gamesLeft };
    }
    
    /**
     * Sort teams with proper tiebreaker handling for 3+ team ties
     * Tiebreaker order:
     * 1. Win Percentage
     * 2. Head-to-Head (2-team ties ONLY)
     * 3. Runs Allowed (fewer is better)
     * 4. Run Differential (higher is better)
     */
    function sortWithTiebreakers(teams) {
      // First sort by win percentage
      const sorted = [...teams].sort((a, b) => b.winPct - a.winPct);
      
      // Find groups of teams with identical win percentages
      const winPctGroups = [];
      let currentGroup = [sorted[0]];
      
      for (let i = 1; i < sorted.length; i++) {
        if (Math.abs(sorted[i].winPct - sorted[i-1].winPct) < 0.0001) {
          // Same win percentage (accounting for floating point)
          currentGroup.push(sorted[i]);
        } else {
          // Different win percentage - save current group and start new one
          winPctGroups.push(currentGroup);
          currentGroup = [sorted[i]];
        }
      }
      winPctGroups.push(currentGroup); // Don't forget the last group
      
      // Apply appropriate tiebreakers to each group
      const brokenTies = winPctGroups.map(group => {
        if (group.length === 1) {
          // No tie to break
          return group;
        } else if (group.length === 2) {
          // 2-team tie: Use Head-to-Head
          const [a, b] = group;
          const h2hComp = compareHeadToHead(a, b);
          
          if (h2hComp !== 0) {
            return h2hComp > 0 ? [b, a] : [a, b];
          } else {
            // H2H tied, use Runs Allowed
            return breakTieByRunsAllowed(group);
          }
        } else {
          // 3+ team tie: Skip H2H, use Runs Allowed directly
          return breakTieByRunsAllowed(group);
        }
      });
      
      // Flatten the groups back into a single array
      return brokenTies.flat();
    }
    
    /**
     * Break ties using Runs Allowed (fewer is better), then Run Differential
     */
    function breakTieByRunsAllowed(teams) {
      return [...teams].sort((a, b) => {
        // Runs Allowed (fewer is better)
        if (a.runsAgainst !== b.runsAgainst) {
          return a.runsAgainst - b.runsAgainst;
        }
        // Run Differential (higher is better)
        return b.runDifferential - a.runDifferential;
      });
    }
    
    /**
     * Simulate final standings with team at specified record
     * favorableForTeam: true = assume favorable outcomes for other games, false = unfavorable
     */
    function simulateFinalStandings(targetTeam, targetWins, targetLosses, currentStandings, favorableForTeam) {
      // Build hypothetical final standings
      const hypotheticalStandings = currentStandings.map(team => {
        if (team.name === targetTeam) {
          // Use the target team's hypothetical record
          const totalDecided = targetWins + targetLosses;
          return {
            ...team,
            wins: targetWins,
            losses: targetLosses,
            gamesPlayed: totalDecided + team.ties,
            winPct: totalDecided > 0 ? (targetWins / totalDecided) : 0
          };
        } else {
          // For other teams, calculate their potential final record
          const otherGamesLeft = calculateRemainingGames(allGames, team.name);
          
          let finalWins, finalLosses;
          if (favorableForTeam) {
            // Favorable case for target team: others lose their remaining games
            finalWins = team.wins;
            finalLosses = team.losses + otherGamesLeft;
          } else {
            // Unfavorable case for target team: others win their remaining games
            finalWins = team.wins + otherGamesLeft;
            finalLosses = team.losses;
          }
          
          const totalDecided = finalWins + finalLosses;
          return {
            ...team,
            wins: finalWins,
            losses: finalLosses,
            gamesPlayed: totalDecided + team.ties,
            winPct: totalDecided > 0 ? (finalWins / totalDecided) : 0
          };
        }
      });
      
      // Sort with proper tiebreakers that handle 3+ team ties correctly
      const sortedStandings = sortWithTiebreakers(hypotheticalStandings);
      
      // Find the target team's seed
      const seed = sortedStandings.findIndex(t => t.name === targetTeam) + 1;
      return seed;
    }

    /**
     * Calculate magic number to clinch a specific seed
     */
    function calculateMagicNumberForSeed(team, targetSeed, standings) {
      const teamName = team.name;
      const gamesLeft = calculateRemainingGames(allGames, teamName);
      
      if (gamesLeft === 0) return 0; // No games left
      
      // Find the team that could prevent us from getting targetSeed
      // That's the team at position targetSeed (if we want #1, it's current #2, etc.)
      let threateningTeams = standings.filter((t, idx) => {
        if (t.name === teamName) return false;
        const seed = idx + 1;
        return seed >= targetSeed; // Teams at or below our target seed
      });
      
      if (threateningTeams.length === 0) return 0;
      
      // Find the highest win total any threatening team could achieve
      let highestThreat = 0;
      threateningTeams.forEach(otherTeam => {
        const otherGamesLeft = calculateRemainingGames(allGames, otherTeam.name);
        const maxWins = otherTeam.wins + otherGamesLeft;
        highestThreat = Math.max(highestThreat, maxWins);
      });
      
      // Magic number = wins needed to guarantee we're ahead of highest threat
      const magicNumber = Math.max(0, highestThreat - team.wins + 1);
      
      // If impossible, return -1
      if (magicNumber > gamesLeft) return -1;
      
      return magicNumber;
    }

    /**
     * Generate detailed seeding scenario text
     */
    function generateSeedingScenario(team, seed, standings) {
      const range = calculateSeedRange(team, standings, allGames);
      const teamName = team.name;
      const gamesLeft = range.gamesLeft;
      
      // If this team has no games left but seed is locked (best = worst)
      if (gamesLeft === 0 && range.bestSeed === range.worstSeed) {
        return `Season complete. Locked into #${range.bestSeed} seed`;
      }
      
      // If this team has no games left but seed can still change based on other results
      if (gamesLeft === 0) {
        const seedRangeText = `Season complete. Can finish #${range.bestSeed} to #${range.worstSeed}`;
        let scenarios = [seedRangeText];
        
        // Explain what determines final position
        if (range.worstSeed - range.bestSeed === 1) {
          scenarios.push(`Final position depends on other results and tiebreakers`);
        } else {
          scenarios.push(`Multiple teams can catch up - final position depends on other results`);
        }
        
        return scenarios.join('. ') + '.';
      }
      
      // Build scenario text with specific details
      let scenarios = [];
      
      // Check if #1 seed is clinched
      const magicFor1 = calculateMagicNumberForSeed(team, 1, standings);
      if (magicFor1 === 0) {
        return `üèÜ Clinched #1 seed!`;
      }
      
      // Can clinch #1?
      if (magicFor1 > 0 && range.bestSeed === 1) {
        const secondPlace = standings[1];
        const secondGamesLeft = calculateRemainingGames(allGames, secondPlace.name);
        
        if (magicFor1 === 1 && gamesLeft >= 1) {
          // Only mention second place loss if they have games left
          if (secondGamesLeft > 0) {
            scenarios.push(`Clinches #1 with 1 win or ${secondPlace.name} loss`);
          } else {
            scenarios.push(`Clinches #1 with 1 win`);
          }
        } else if (magicFor1 <= gamesLeft) {
          scenarios.push(`Clinches #1 with ${magicFor1} wins`);
        }
      }
      
      // If seed is locked
      if (range.bestSeed === range.worstSeed) {
        if (scenarios.length === 0) {
          return `Locked into #${range.bestSeed} seed`;
        } else {
          return scenarios.join('. ') + '.';
        }
      }
      
      // Show seed range with specific scenarios
      const seedRangeText = `Can finish #${range.bestSeed} to #${range.worstSeed}`;
      
      // Best case - what would get them to best seed
      if (range.bestSeed < seed && gamesLeft > 0) {
        const teamsToPass = standings.slice(range.bestSeed - 1, seed - 1);
        if (teamsToPass.length > 0) {
          const closestTeam = teamsToPass[teamsToPass.length - 1];
          const closestGamesLeft = calculateRemainingGames(allGames, closestTeam.name);
          
          if (gamesLeft === 1) {
            // Only mention their loss if they have games left
            if (closestGamesLeft > 0) {
              scenarios.push(`${seedRangeText} (rises with win and ${closestTeam.name} loss)`);
            } else {
              scenarios.push(`${seedRangeText} (rises with win)`);
            }
          } else {
            scenarios.push(`${seedRangeText} (rises with ${gamesLeft} wins and help)`);
          }
        }
      } else {
        scenarios.push(seedRangeText);
      }
      
      // Worst case - what would drop them
      if (range.worstSeed > seed) {
        const teamsBehind = standings.slice(seed, range.worstSeed);
        const closestThreat = teamsBehind[0];
        
        if (closestThreat) {
          const threatGamesLeft = calculateRemainingGames(allGames, closestThreat.name);
          
          // Only show fall scenarios if the threat has games to actually catch us
          if (threatGamesLeft > 0) {
            if (gamesLeft === 1 && threatGamesLeft > 0) {
              scenarios.push(`Falls to #${range.worstSeed} with loss and ${closestThreat.name} win`);
            } else if (gamesLeft > 1) {
              scenarios.push(`Falls to #${range.worstSeed} with ${gamesLeft} losses and ${closestThreat.name} wins`);
            }
          }
        }
      }
      
      // Highlight play-in line (6/7 cutoff)
      if (seed === 6 && range.worstSeed >= 7) {
        scenarios.push(`‚ö†Ô∏è At risk of play-in with losses`);
      } else if (seed === 7 && range.bestSeed <= 6) {
        scenarios.push(`‚ö†Ô∏è Can avoid play-in with wins`);
      }
      
      if (scenarios.length === 0) {
        scenarios.push(seedRangeText);
      }
      
      return scenarios.join('. ') + '.';
    }

    function getSeedStatus(seed, magicNumber) {
      // Status based on current seed position, not magic number
      if (seed <= 2) {
        return { status: 'safe', badge: 'status-safe', text: 'TOP SEED' };
      } else if (seed <= 6) {
        return { status: 'contention', badge: 'status-contention', text: 'MID SEED' };
      } else {
        return { status: 'danger', badge: 'status-danger', text: 'PLAY-IN' };
      }
    }

    let allGames = [];

    async function loadData() {
      try {
        console.log('üîÑ Loading playoff seeding data...');
        
        const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
        
        const season = await getCurrentSeason();
        console.log('üìÖ Current season:', season);
        
        if (!season) {
          console.error('‚ùå No active season found');
          showError();
          return;
        }

        const gamesRaw = await getSeasonGames(season.id);
        console.log(`üìä Loaded ${gamesRaw.length} total games (raw)`);
        console.log('Sample raw game:', gamesRaw[0]);
        
        // Transform data to match current-season.html format
        allGames = (gamesRaw || []).map(g => {
          let dateString = "";
          if (g.date && g.date.seconds) {
            const dateObj = new Date(g.date.seconds * 1000);
            dateString = dateObj.toLocaleDateString('en-US');
          } else if (g.date) {
            dateString = g.date;
          }
          
          return {
            "home team": g.homeTeamName || capitalize(g.homeTeamId) || "",
            "away team": g.awayTeamName || capitalize(g.awayTeamId) || "",
            "home score": g.homeScore !== undefined ? g.homeScore : null,
            "away score": g.awayScore !== undefined ? g.awayScore : null,
            winner: capitalize(g.winner),
            game_type: g.gameType === "regular" ? "Regular" :
                       g.gameType === "playoff" ? "Playoff" :
                       capitalize(g.gameType) || "Regular",
            date: dateString,
            forfeit: g.forfeit ? "Yes" : "No",
            status: g.status || "",
            id: g.id || ""
          };
        });
        
        console.log(`‚úÖ Transformed ${allGames.length} games`);
        console.log('Sample transformed game:', allGames[0]);
        
        const completedGames = allGames.filter(g => {
          const gameDate = parseGameDate(g.date);
          const isPast = gameDate < today;
          const hasWinner = g.winner && g.winner.trim() !== "";
          const isRegular = g.game_type === 'Regular';
          return isPast && hasWinner && isRegular;
        });
        console.log(`‚úÖ ${completedGames.length} completed regular season games`);

        const upcomingGames = allGames.filter(g => {
          const gameDate = parseGameDate(g.date);
          const isFuture = gameDate >= today;
          const noWinner = !g.winner || g.winner.trim() === "";
          const isRegularSeason = g.game_type === 'Regular';
          return isFuture && noWinner && isRegularSeason;
        });
        console.log(`‚è∞ ${upcomingGames.length} upcoming regular season games`);

        const standings = calculateStandings(completedGames);
        console.log(`üèÜ Calculated standings for ${standings.length} teams:`, standings);
        
        if (standings.length === 0) {
          console.warn('‚ö†Ô∏è No standings data - no completed games yet?');
          document.getElementById('clinchingTableBody').innerHTML = `
            <tr><td colspan="8" class="no-data">No standings data yet. Games need to be played and completed first.</td></tr>
          `;
          return;
        }
        
        updateSummary(standings, upcomingGames);
        updateSeedingTable(standings, upcomingGames);
        updateKeyMatchups(standings, upcomingGames);
        updateSeedingBattles(standings, upcomingGames);
        
        console.log('‚úÖ All data loaded and displayed successfully!');

      } catch (error) {
        console.error('‚ùå Error loading data:', error);
        console.error('Error stack:', error.stack);
        showError();
      }
    }

    function updateSummary(standings, upcomingGames) {
      let lockedSeeds = 0;
      let byeSeeds = 0; // Seeds 1-6 (direct to round 1)
      let playInTeams = 0; // Seeds 7-10

      standings.slice(0, TOTAL_TEAMS).forEach((team, index) => {
        const seed = index + 1;
        const range = calculateSeedRange(team, standings, allGames);
        
        // Count locked seeds
        if (range.bestSeed === range.worstSeed) {
          lockedSeeds++;
        }
        
        // Count current positioning
        if (seed <= 6) {
          byeSeeds++;
        } else {
          playInTeams++;
        }
      });

      document.getElementById('clinched').textContent = lockedSeeds;
      document.getElementById('byeSeeds').textContent = byeSeeds;
      document.getElementById('playInTeams').textContent = playInTeams;
      document.getElementById('gamesRemaining').textContent = upcomingGames.length;
    }

    function updateSeedingTable(standings, upcomingGames) {
      const tbody = document.getElementById('clinchingTableBody');
      tbody.innerHTML = '';

      // Only show top 10 teams (all make playoffs)
      standings.slice(0, TOTAL_TEAMS).forEach((team, index) => {
        const seed = index + 1;
        const gamesLeft = calculateRemainingGames(allGames, team.name);
        const range = calculateSeedRange(team, standings, allGames);
        const statusInfo = getSeedStatus(seed);
        const scenario = generateSeedingScenario(team, seed, standings);

        // Display seed range in magic # column
        let magicDisplay;
        if (range.bestSeed === range.worstSeed) {
          magicDisplay = `#${range.bestSeed}`;
        } else {
          magicDisplay = `#${range.bestSeed}-${range.worstSeed}`;
        }

        const row = document.createElement('tr');
        row.innerHTML = `
          <td><strong>#${seed}</strong></td>
          <td class="team-name">${team.name}</td>
          <td>${team.wins}-${team.losses}${team.ties > 0 ? `-${team.ties}` : ''}</td>
          <td>${(team.winPct * 100).toFixed(1)}%</td>
          <td><span class="status-badge ${statusInfo.badge}">${statusInfo.text}</span></td>
          <td><span class="magic-number">${magicDisplay}</span></td>
          <td>${gamesLeft}</td>
          <td class="scenario-text">${scenario}</td>
        `;
        tbody.appendChild(row);
      });
    }

    function updateKeyMatchups(standings, upcomingGames) {
      const container = document.getElementById('keyMatchupsContent');
      container.classList.remove('loading');

      // Find matchups between teams within 3 seeds of each other
      const keyGames = upcomingGames.filter(g => {
        const homeRank = standings.findIndex(t => t.name === g['home team']) + 1;
        const awayRank = standings.findIndex(t => t.name === g['away team']) + 1;
        return Math.abs(homeRank - awayRank) <= 3 && homeRank <= 10 && awayRank <= 10;
      }).slice(0, 10);

      if (keyGames.length === 0) {
        container.innerHTML = '<div class="no-data">No key seeding matchups remaining.</div>';
        return;
      }

      const html = `
        <table class="clinching-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Matchup</th>
              <th>Seeding Impact</th>
            </tr>
          </thead>
          <tbody>
            ${keyGames.map(game => {
              const homeRank = standings.findIndex(t => t.name === game['home team']) + 1;
              const awayRank = standings.findIndex(t => t.name === game['away team']) + 1;
              
              let impact = '';
              if (homeRank <= 2 && awayRank <= 2) {
                impact = 'üèÜ Top Seed Battle';
              } else if (homeRank === 6 || awayRank === 6 || homeRank === 7 || awayRank === 7) {
                impact = '‚ö†Ô∏è Play-In Line';
              } else if (Math.abs(homeRank - awayRank) === 1) {
                impact = 'üîÑ Direct Swap Possible';
              } else {
                impact = 'üìä Seeding Impact';
              }
              
              return `
                <tr>
                  <td>${game.date}</td>
                  <td>
                    <strong>#${homeRank} ${game['home team']}</strong> vs <strong>#${awayRank} ${game['away team']}</strong>
                  </td>
                  <td>${impact}</td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      `;

      container.innerHTML = html;
    }

    function updateSeedingBattles(standings, upcomingGames) {
      const container = document.getElementById('bubbleContent');
      container.classList.remove('loading');

      // Focus on three key battles:
      // 1. Top seed battle (seeds 1-3)
      // 2. Play-in avoidance (seeds 5-7)
      // 3. Play-in seeding (seeds 8-10)

      const topSeeds = standings.slice(0, 3);
      const playInBattle = standings.slice(4, 7);
      const playInSeeding = standings.slice(7, 10);

      const html = `
        <div style="margin-bottom: 2rem;">
          <h4 style="margin-bottom: 1rem; color: var(--primary-color);">üèÜ Top Seed Battle (Seeds 1-3)</h4>
          <p style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
            These teams will face play-in winners. Fighting for #1 seed and home field advantage.
          </p>
          <table class="clinching-table">
            <thead>
              <tr>
                <th>Seed</th>
                <th>Team</th>
                <th>Record</th>
                <th>Win%</th>
                <th>Games Left</th>
                <th>Path Forward</th>
              </tr>
            </thead>
            <tbody>
              ${topSeeds.map((team, index) => {
                const seed = index + 1;
                const gamesLeft = calculateRemainingGames(allGames, team.name);
                const range = calculateSeedRange(team, standings, allGames);
                const magicFor1 = calculateMagicNumberForSeed(team, 1, standings);
                
                let path = '';
                if (seed === 1) {
                  if (range.bestSeed === range.worstSeed && range.bestSeed === 1) {
                    path = 'Clinched #1 seed! üèÜ';
                  } else if (magicFor1 > 0 && magicFor1 <= gamesLeft) {
                    path = `${magicFor1} win${magicFor1 > 1 ? 's' : ''} clinches #1`;
                  } else {
                    path = 'Controls destiny for #1';
                  }
                } else {
                  const gamesBack = ((standings[0].winPct - team.winPct) * team.gamesPlayed).toFixed(1);
                  if (range.bestSeed === 1) {
                    path = `${gamesBack} GB from #1 (can catch with wins)`;
                  } else {
                    path = `${gamesBack} GB from #1 seed`;
                  }
                }

                return `
                  <tr>
                    <td><strong>#${seed}</strong></td>
                    <td class="team-name">${team.name}</td>
                    <td>${team.wins}-${team.losses}${team.ties > 0 ? `-${team.ties}` : ''}</td>
                    <td>${(team.winPct * 100).toFixed(1)}%</td>
                    <td>${gamesLeft}</td>
                    <td class="scenario-text">${path}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>

        <div style="margin-bottom: 2rem;">
          <h4 style="margin-bottom: 1rem; color: var(--warning-yellow);">‚ö†Ô∏è Play-In Avoidance (Seeds 5-7)</h4>
          <p style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
            Seeds 1-6 go directly to Round 1. Seeds 7-10 must win play-in games. This is the critical line!
          </p>
          <table class="clinching-table">
            <thead>
              <tr>
                <th>Seed</th>
                <th>Team</th>
                <th>Record</th>
                <th>Win%</th>
                <th>Games Left</th>
                <th>Battle Status</th>
              </tr>
            </thead>
            <tbody>
              ${playInBattle.map((team, index) => {
                const seed = index + 5;
                const gamesLeft = calculateRemainingGames(allGames, team.name);
                const range = calculateSeedRange(team, standings, allGames);
                
                let status = '';
                if (seed === 6) {
                  if (range.worstSeed === 6) {
                    status = 'Locked in last direct Round 1 spot';
                  } else if (range.worstSeed >= 7) {
                    status = 'Last direct spot - at risk of play-in';
                  } else {
                    status = 'Secure in direct Round 1 position';
                  }
                } else if (seed === 7) {
                  if (range.bestSeed <= 6) {
                    const gamesBack = ((standings[5].winPct - team.winPct) * team.gamesPlayed).toFixed(1);
                    status = `${gamesBack} GB from avoiding play-in (can reach #6)`;
                  } else {
                    status = 'Locked into play-in games';
                  }
                } else {
                  if (range.bestSeed <= 6) {
                    const gamesBack = ((standings[5].winPct - team.winPct) * team.gamesPlayed).toFixed(1);
                    status = `${gamesBack} GB from top 6 (can avoid play-in)`;
                  } else {
                    status = 'Locked into play-in games';
                  }
                }

                return `
                  <tr>
                    <td><strong>#${seed}</strong></td>
                    <td class="team-name">${team.name}</td>
                    <td>${team.wins}-${team.losses}${team.ties > 0 ? `-${team.ties}` : ''}</td>
                    <td>${(team.winPct * 100).toFixed(1)}%</td>
                    <td>${gamesLeft}</td>
                    <td class="scenario-text">${status}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>

        <div>
          <h4 style="margin-bottom: 1rem; color: var(--danger-red);">üé± Play-In Seeding (Seeds 8-10)</h4>
          <p style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
            These teams will play play-in games. #7 vs #10, #8 vs #9. Winners face #2 and #1 respectively.
          </p>
          <table class="clinching-table">
            <thead>
              <tr>
                <th>Seed</th>
                <th>Team</th>
                <th>Record</th>
                <th>Win%</th>
                <th>Games Left</th>
                <th>Play-In Matchup</th>
              </tr>
            </thead>
            <tbody>
              ${playInSeeding.map((team, index) => {
                const seed = index + 8;
                const gamesLeft = calculateRemainingGames(allGames, team.name);
                const range = calculateSeedRange(team, standings, allGames);
                
                let matchup = '';
                if (seed === 8) {
                  if (range.bestSeed === range.worstSeed && range.bestSeed === 8) {
                    matchup = 'Locked - will face #9 seed';
                  } else {
                    matchup = `Could finish #${range.bestSeed}-${range.worstSeed} (currently vs #9)`;
                  }
                } else if (seed === 9) {
                  if (range.bestSeed === range.worstSeed && range.bestSeed === 9) {
                    matchup = 'Locked - will face #8 seed';
                  } else {
                    matchup = `Could finish #${range.bestSeed}-${range.worstSeed} (currently vs #8)`;
                  }
                } else if (seed === 10) {
                  if (range.bestSeed === range.worstSeed && range.bestSeed === 10) {
                    matchup = 'Locked - will face #7 seed';
                  } else {
                    matchup = `Could finish #${range.bestSeed}-${range.worstSeed} (currently vs #7)`;
                  }
                }

                return `
                  <tr>
                    <td><strong>#${seed}</strong></td>
                    <td class="team-name">${team.name}</td>
                    <td>${team.wins}-${team.losses}${team.ties > 0 ? `-${team.ties}` : ''}</td>
                    <td>${(team.winPct * 100).toFixed(1)}%</td>
                    <td>${gamesLeft}</td>
                    <td class="scenario-text">${matchup}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;

      container.innerHTML = html;
    }

    function showError() {
      const errorHtml = '<div class="no-data">Error loading data. Please try again later.</div>';
      document.getElementById('summaryGrid').innerHTML = errorHtml;
      document.getElementById('clinchingTableBody').innerHTML = `<tr><td colspan="8">${errorHtml}</td></tr>`;
      document.getElementById('keyMatchupsContent').innerHTML = errorHtml;
      document.getElementById('bubbleContent').innerHTML = errorHtml;
    }

    document.addEventListener('DOMContentLoaded', loadData);
  </script>
  <script src="team-colors.js"></script>
  <script src="mobile-enhancements.js"></script>
</body>
</html>

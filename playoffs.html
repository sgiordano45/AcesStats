<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playoffs - Mountainside Aces</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #bf360c 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(191, 54, 12, 0.3);
            border-radius: 15px;
            border: 2px solid #ff5722;
        }

        .playoff-logo {
            max-width: 300px;
            width: 100%;
            height: auto;
            margin-bottom: 20px;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
        }

        h1 {
            font-size: 2.5em;
            color: #ff7043;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .season-info {
            font-size: 1.2em;
            color: #ffccbc;
            margin-top: 10px;
        }

        .bracket-status {
            font-size: 1em;
            text-align: center;
        }

        .bracket-status.projected {
            background: rgba(255, 138, 80, 0.2);
            border: 2px solid #ff8a50;
            color: #ffb74d;
        }

        .bracket-status.locked {
            background: rgba(255, 87, 34, 0.3);
            border: 2px solid #ff5722;
            color: #ffccbc;
        }

        .bracket-container {
            display: flex;
            flex-direction: column;
            gap: 60px;
            margin-top: 30px;
        }

        .bracket-section {
            background: rgba(255, 87, 34, 0.1);
            border: 2px solid #ff5722;
            border-radius: 15px;
            padding: 30px;
        }

        .bracket-title {
            font-size: 2em;
            color: #ff7043;
            text-align: center;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 3px solid #bf360c;
            padding-bottom: 15px;
        }

        .bracket-grid {
            display: flex;
            justify-content: flex-start;
            gap: 60px;
            overflow-x: auto;
            padding: 20px 0;
            align-items: center;
        }

        .round {
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 280px;
            position: relative;
        }

        /* Specific spacing for winners bracket rounds */
        .winners-bracket .round {
            gap: 20px;
        }

        .winners-bracket .round.play-in {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 800px; /* Increased to match full bracket height */
        }

        /* Position play-in games at extreme top and bottom */
        .winners-bracket .round.play-in .matchup:last-child {
            margin-top: auto;
        }

        .winners-bracket .round.round-1 {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 800px; /* Match play-in height */
        }

        .winners-bracket .round.semifinals {
            justify-content: space-around;
            height: 400px;
        }

        .winners-bracket .round.finals {
            justify-content: center;
            height: 200px;
        }

        /* Remove individual positioning since we're using flex spacing */
        .matchup.position-top {
            /* Top position handled by flex */
        }

        .matchup.position-middle-top {
            /* Middle-top position handled by flex */
        }

        .matchup.position-middle-bottom {
            /* Middle-bottom position handled by flex */
        }

        .matchup.position-bottom {
            /* Bottom position handled by flex */
        }

        .round-title {
            text-align: center;
            font-size: 1.1em;
            color: #ffccbc;
            margin-bottom: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .matchup {
            background: rgba(191, 54, 12, 0.4);
            border: 2px solid #bf360c;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 40px;
            position: relative;
            transition: all 0.3s ease;
        }

        .matchup:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 87, 34, 0.4);
            border-color: #ff5722;
        }

        .game-link {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 87, 34, 0.9);
            border: 2px solid #ff5722;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            text-decoration: none;
        }

        .game-link:hover {
            background: #ff5722;
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 4px 12px rgba(255, 87, 34, 0.6);
        }

        .game-link-icon {
            font-size: 1.2em;
        }

        .matchup-date {
            text-align: center;
            font-size: 0.85em;
            color: #ffccbc;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .matchup-time {
            text-align: center;
            font-size: 0.8em;
            color: #ff8a65;
            margin-bottom: 15px;
        }

        .team {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .team:last-child {
            margin-bottom: 0;
        }

        .team:hover {
            background: rgba(26, 107, 74, 0.3);
        }

        .team.winner {
            background: rgba(26, 107, 74, 0.5);
            border: 2px solid #1a6b4a;
            font-weight: bold;
        }

        .team.loser {
            opacity: 0.6;
        }

        .seed {
            font-size: 0.85em;
            color: #ffccbc;
            font-weight: bold;
            min-width: 25px;
        }

        .team-name {
            flex: 1;
            margin: 0 15px;
            font-size: 1em;
        }

        .score {
            font-size: 1.3em;
            font-weight: bold;
            color: #ff7043;
            min-width: 35px;
            text-align: center;
        }

        .tbd {
            color: #666;
            font-style: italic;
        }

        /* Connector lines */
        .connector {
            position: absolute;
            border: 2px solid #bf360c;
        }

        /* Championship styling */
        .championship {
            background: linear-gradient(135deg, rgba(255, 87, 34, 0.3), rgba(191, 54, 12, 0.3));
            border: 3px solid #ff5722;
            box-shadow: 0 0 30px rgba(255, 87, 34, 0.5);
        }

        .championship .team {
            font-size: 1.1em;
            padding: 15px;
        }

        /* Elimination indicator */
        .elimination-round {
            position: relative;
        }

        .elimination-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #d32f2f;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* Loading and Edit states */
        .loading {
            text-align: center;
            padding: 40px;
            color: #ffccbc;
            font-size: 1.2em;
        }

        .edit-mode-toggle {
            text-align: center;
            margin: 20px 0;
        }

        .btn {
            background: #bf360c;
            color: white;
            border: 2px solid #ff5722;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #ff5722;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .bracket-grid {
                justify-content: flex-start;
            }

            .round {
                min-width: 240px;
            }

            h1 {
                font-size: 2em;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .bracket-section {
                padding: 15px;
            }

            .round {
                min-width: 200px;
            }

            .team-name {
                font-size: 0.9em;
            }

            .bracket-title {
                font-size: 1.5em;
            }
        }

        /* Modal for editing */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            border: 3px solid #ff5722;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }

        .modal-title {
            color: #ff7043;
            font-size: 1.5em;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            color: #ffccbc;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #bf360c;
            border-radius: 8px;
            background: rgba(191, 54, 12, 0.2);
            color: white;
            font-size: 1em;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #ff5722;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .btn-cancel {
            background: #666;
            border-color: #888;
        }

        .btn-cancel:hover {
            background: #555;
        }

        nav {
            background: rgba(191, 54, 12, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        nav a {
            color: #ffccbc;
            text-decoration: none;
            margin: 0 15px;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        nav a:hover {
            color: #ff7043;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="index.html">Home</a>
            <a href="current-season.html">Current Season</a>
            <a href="teams.html">Teams</a>
            <a href="players.html">Players</a>
        </nav>

        <header>
            <img src="photos/2025 Fall Playoff logo.png" alt="2025 Fall Playoffs" class="playoff-logo">
            <h1>üèÜ Playoff Bracket</h1>
            <div class="season-info" id="seasonInfo">Loading season information...</div>
            <div id="bracketStatus" class="bracket-status" style="margin-top: 15px; padding: 10px; border-radius: 8px; font-weight: 600;"></div>
        </header>

        <div class="edit-mode-toggle">
            <button class="btn" id="lockBracketBtn" onclick="lockBracket()" style="display: none;">
                üîí Lock Bracket for Playoffs
            </button>
            <button class="btn" id="editModeBtn" onclick="toggleEditMode()" style="display: none;">
                <span id="editModeText">Enable Edit Mode</span>
            </button>
            <button class="btn" id="createGamesBtn" onclick="createNextPlayoffGames()" style="display: none;">
                üìÖ Create Next Playoff Games
            </button>
        </div>

        <div id="bracketsContainer">
            <div class="loading">Loading playoff bracket...</div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">Edit Matchup</h2>
            <div class="form-group">
                <label for="gameDate">Game Date:</label>
                <input type="date" id="gameDate">
            </div>
            <div class="form-group">
                <label for="gameTime">Game Time:</label>
                <input type="time" id="gameTime">
            </div>
            <div class="form-group">
                <label for="team1Score">Team 1 Score:</label>
                <input type="number" id="team1Score" min="0">
            </div>
            <div class="form-group">
                <label for="team2Score">Team 2 Score:</label>
                <input type="number" id="team2Score" min="0">
            </div>
            <div class="modal-buttons">
                <button class="btn btn-cancel" onclick="closeModal()">Cancel</button>
                <button class="btn" onclick="saveMatchup()">Save</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { db, collection, query, where, getDocs, doc, getDoc } from './firebase-config.js';
        import { getCurrentSeason, getSeasonGames } from './firebase-data.js';
        import { getCurrentUser, getUserProfile, USER_ROLES, onAuthChange } from './firebase-auth.js';
        import { setDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        let currentSeason = null;
        let playoffData = null;
        let editMode = false;
        let currentEditMatchup = null;
        let teams = [];
        let isProjected = true; // True until bracket is locked in
        let currentUser = null;
        let userProfile = null;
        let userCanManagePlayoffs = false; // True if user is Admin or League-Staff
        let authReady = false;

        // Wait for auth state to be ready before loading playoff data
        onAuthChange(async (user) => {
            if (!authReady) {
                authReady = true;
                currentUser = user;
                
                if (currentUser) {
                    const profileResult = await getUserProfile(currentUser.uid);
                    if (profileResult.success) {
                        userProfile = profileResult.data;
                        // Check if user is Admin or League-Staff
                        userCanManagePlayoffs = (
                            userProfile.userRole === USER_ROLES.ADMIN || 
                            userProfile.userRole === USER_ROLES.LEAGUE_STAFF
                        );
                        console.log('üë§ User role:', userProfile.userRole, '| Can manage playoffs:', userCanManagePlayoffs);
                    }
                } else {
                    console.log('üë§ No user logged in');
                }
                
                // Now load the playoff bracket
                loadPlayoffBracket();
            }
        });

        // Load current season and playoff data
        async function loadPlayoffBracket() {
            try {
                // Get current season using the same method as current-season.html
                currentSeason = await getCurrentSeason();
                
                if (!currentSeason) {
                    document.getElementById('bracketsContainer').innerHTML = 
                        '<div class="loading">No active season found</div>';
                    return;
                }

                console.log('‚úÖ Current season:', currentSeason);

                // Update header
                document.getElementById('seasonInfo').textContent = 
                    `${currentSeason.year} ${currentSeason.season.charAt(0).toUpperCase() + currentSeason.season.slice(1)} Season - Playoffs`;

                // Load teams with their seeds
                await loadTeams();

                // Load or initialize playoff data
                const playoffRef = doc(db, 'seasons', currentSeason.id, 'playoffs', 'bracket');
                let playoffDoc;
                
                try {
                    playoffDoc = await getDoc(playoffRef);
                } catch (error) {
                    console.log('‚ö†Ô∏è Could not access playoff bracket document');
                    playoffDoc = null;
                }

                if (playoffDoc && playoffDoc.exists()) {
                    playoffData = playoffDoc.data();
                    isProjected = playoffData.isProjected !== false; // Default to projected if not set
                    console.log('‚úÖ Loaded existing playoff data', isProjected ? '(PROJECTED)' : '(LOCKED)');
                } else {
                    // Initialize new playoff bracket (just in memory, won't save without permission)
                    playoffData = initializePlayoffBracket();
                    isProjected = true;
                    console.log('üìã Initialized projected playoff bracket');
                }

                renderBracket();
                updateLockButton();
            } catch (error) {
                console.error('Error loading playoff bracket:', error);
                document.getElementById('bracketsContainer').innerHTML = 
                    '<div class="loading">Error loading playoff bracket: ' + error.message + '</div>';
            }
        }

        async function loadTeams() {
            // Just calculate standings - teams array will have name, wins, losses from standings
            console.log('üìä Calculating standings to determine playoff seeds...');
            teams = await calculateStandings();
        }

        async function calculateStandings() {
            // Get all games for this season using getSeasonGames (same as current-season.html)
            const allGames = await getSeasonGames(currentSeason.id);
            console.log(`üìä Found ${allGames.length} total games for season`);
            
            // Map games to the format expected (same as current-season.html does)
            const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
            
            const games = allGames.map(g => {
                const dateObj = g.date && g.date.seconds ? 
                    new Date(g.date.seconds * 1000) : 
                    new Date(g.date || Date.now());
                const dateString = dateObj.toLocaleDateString('en-US');
                
                return {
                    "home team": g.homeTeamName || capitalize(g.homeTeamId) || "",
                    "away team": g.awayTeamName || capitalize(g.awayTeamId) || "",
                    "home score": g.homeScore !== undefined ? g.homeScore : null,
                    "away score": g.awayScore !== undefined ? g.awayScore : null,
                    winner: capitalize(g.winner),
                    game_type: g.gameType === "regular" ? "Regular" :
                               g.gameType === "playoff" ? "Playoff" :
                               capitalize(g.gameType) || "Regular",
                    date: dateString
                };
            });
            
            // Filter to completed regular season games
            const today = new Date();
            const parseGameDate = (dateStr) => {
                const [month, day, year] = dateStr.split('/').map(Number);
                return new Date(year, month - 1, day);
            };
            
            const completedGames = games.filter(g =>
                g.winner && g.winner.trim() !== "" && parseGameDate(g.date) < today
            );
            
            const regularGames = completedGames.filter(g => g.game_type === 'Regular');
            
            console.log(`üìä Processing ${regularGames.length} completed regular season games`);
            
            if (regularGames.length === 0) {
                console.log('‚ö†Ô∏è No completed games yet - returning empty standings');
                return [];
            }

            // Use the EXACT calculateStandings logic from current-season.html
            const teamStats = {};

            regularGames.forEach(game => {
                const homeTeam = game["home team"];
                const awayTeam = game["away team"];
                const winner = game.winner;
                const homeScore = parseInt(game["home score"]) || 0;
                const awayScore = parseInt(game["away score"]) || 0;

                if (!teamStats[homeTeam]) {
                    teamStats[homeTeam] = {
                        name: homeTeam, wins: 0, losses: 0, ties: 0,
                        runsFor: 0, runsAgainst: 0, h2h: {}
                    };
                }
                if (!teamStats[awayTeam]) {
                    teamStats[awayTeam] = {
                        name: awayTeam, wins: 0, losses: 0, ties: 0,
                        runsFor: 0, runsAgainst: 0, h2h: {}
                    };
                }

                teamStats[homeTeam].runsFor += homeScore;
                teamStats[homeTeam].runsAgainst += awayScore;
                teamStats[awayTeam].runsFor += awayScore;
                teamStats[awayTeam].runsAgainst += homeScore;

                if (!teamStats[homeTeam].h2h[awayTeam]) {
                    teamStats[homeTeam].h2h[awayTeam] = { wins: 0, losses: 0, ties: 0 };
                }
                if (!teamStats[awayTeam].h2h[homeTeam]) {
                    teamStats[awayTeam].h2h[homeTeam] = { wins: 0, losses: 0, ties: 0 };
                }

                if (winner === "Tie") {
                    teamStats[homeTeam].ties++;
                    teamStats[awayTeam].ties++;
                    teamStats[homeTeam].h2h[awayTeam].ties++;
                    teamStats[awayTeam].h2h[homeTeam].ties++;
                } else if (winner === homeTeam) {
                    teamStats[homeTeam].wins++;
                    teamStats[awayTeam].losses++;
                    teamStats[homeTeam].h2h[awayTeam].wins++;
                    teamStats[awayTeam].h2h[homeTeam].losses++;
                } else if (winner === awayTeam) {
                    teamStats[awayTeam].wins++;
                    teamStats[homeTeam].losses++;
                    teamStats[awayTeam].h2h[homeTeam].wins++;
                    teamStats[homeTeam].h2h[awayTeam].losses++;
                }
            });

            const preliminaryStandings = Object.values(teamStats)
                .map(team => {
                    const totalDecided = team.wins + team.losses;
                    team.winPct = totalDecided > 0 ? (team.wins / totalDecided) : 0;
                    team.runDifferential = team.runsFor - team.runsAgainst;
                    return team;
                });

            const standings = preliminaryStandings.sort((a, b) => {
                if (a.winPct !== b.winPct) return b.winPct - a.winPct;
                const h2hComp = compareHeadToHead(a, b);
                if (h2hComp !== 0) return h2hComp;
                if (a.runsAgainst !== b.runsAgainst) return a.runsAgainst - b.runsAgainst;
                return b.runDifferential - a.runDifferential;
            });

            // Take top 10 and add seed numbers (exactly like current-season.html)
            const playoffTeams = standings.slice(0, 10).map((team, index) => ({
                ...team,
                seed: index + 1,
                teamName: team.name // Add teamName for compatibility
            }));

            console.log('‚úÖ Calculated playoff seeds:', playoffTeams.map(t => `${t.seed}. ${t.name} (${t.wins}-${t.losses})`));

            return playoffTeams;
        }

        function compareHeadToHead(teamA, teamB) {
            const aVsB = teamA.h2h[teamB.name];
            const bVsA = teamB.h2h[teamA.name];
            
            if (!aVsB || !bVsA) return 0;
            
            const aH2HWinPct = (aVsB.wins + aVsB.losses) > 0 ? aVsB.wins / (aVsB.wins + aVsB.losses) : 0;
            const bH2HWinPct = (bVsA.wins + bVsA.losses) > 0 ? bVsA.wins / (bVsA.wins + bVsA.losses) : 0;
            
            return bH2HWinPct - aH2HWinPct;
        }

        function updateLockButton() {
            const lockBtn = document.getElementById('lockBracketBtn');
            const editBtn = document.getElementById('editModeBtn');
            const createGamesBtn = document.getElementById('createGamesBtn');
            
            // Only show lock button if user has permission, bracket is projected, and we have enough teams
            if (userCanManagePlayoffs && isProjected && teams.length >= 10) {
                lockBtn.style.display = 'inline-block';
            } else {
                lockBtn.style.display = 'none';
            }
            
            // Only show edit mode button if user has permission and bracket is locked
            if (userCanManagePlayoffs && !isProjected) {
                editBtn.style.display = 'inline-block';
            } else {
                editBtn.style.display = 'none';
            }
            
            // Only show create games button if user is ADMIN (not just staff) and bracket is locked
            if (userProfile && userProfile.userRole === USER_ROLES.ADMIN && !isProjected) {
                createGamesBtn.style.display = 'inline-block';
            } else {
                createGamesBtn.style.display = 'none';
            }
        }

        window.lockBracket = async function() {
            if (!confirm(`Lock in the current playoff bracket?\n\nThis will:\n‚Ä¢ Set the playoff seeds based on current standings\n‚Ä¢ Create playoff game IDs\n‚Ä¢ Make the bracket official\n\nThis cannot be undone. Continue?`)) {
                return;
            }

            try {
                console.log('üîí Locking playoff bracket...');

                // Update playoff data to mark as locked
                playoffData.isProjected = false;
                playoffData.lockedAt = new Date().toISOString();
                playoffData.lockedSeeds = teams.map(t => ({
                    seed: t.seed,
                    teamName: t.teamName,
                    teamId: t.id,
                    record: `${t.wins}-${t.losses}`
                }));

                // Save to Firebase
                const playoffRef = doc(db, 'seasons', currentSeason.id, 'playoffs', 'bracket');
                await setDoc(playoffRef, playoffData);

                // Create playoff game IDs in the games collection
                await createPlayoffGames();

                isProjected = false;
                console.log('‚úÖ Bracket locked successfully!');
                alert('Playoff bracket has been locked! You can now set game dates and enter scores.');
                
                updateLockButton();
                renderBracket();
            } catch (error) {
                console.error('Error locking bracket:', error);
                alert('Error locking bracket: ' + error.message);
            }
        };

        async function createPlayoffGames() {
            console.log('üìÖ Creating playoff game IDs...');
            
            const gamesCollection = collection(db, 'seasons', currentSeason.id, 'games');
            
            // Helper function to convert YYYY-MM-DD to MM_D_YYYY
            const formatDateForId = (dateStr) => {
                const [year, month, day] = dateStr.split('-');
                return `${month}_${parseInt(day)}_${year}`;
            };
            
            // Get dates from the playoff data structure
            const pi1 = playoffData.winnersBracket.playIn[0]; // Game 1: 8 vs 9
            const pi2 = playoffData.winnersBracket.playIn[1]; // Game 3: 7 vs 10
            const w1_1 = playoffData.winnersBracket.round1[0]; // Game 2: 1 vs winner pi1
            const w1_2 = playoffData.winnersBracket.round1[1]; // Game 6: 2 vs winner pi2
            const w1_3 = playoffData.winnersBracket.round1[2]; // Game 5: 3 vs 6
            const w1_4 = playoffData.winnersBracket.round1[3]; // Game 4: 4 vs 5
            
            // Play-in games
            const playInGames = [
                {
                    id: `${formatDateForId(pi1.gameDate)}_${teams[7].teamName}_vs_${teams[8].teamName}`,
                    homeTeamName: teams[7].teamName,
                    awayTeamName: teams[8].teamName,
                    gameType: 'playoff',
                    playoffRound: pi1.round,
                    playoffGameNumber: pi1.gameNumber,
                    date: pi1.gameDate,
                    time: pi1.gameTime,
                    homeScore: null,
                    awayScore: null,
                    winner: null
                },
                {
                    id: `${formatDateForId(pi2.gameDate)}_${teams[6].teamName}_vs_${teams[9].teamName}`,
                    homeTeamName: teams[6].teamName,
                    awayTeamName: teams[9].teamName,
                    gameType: 'playoff',
                    playoffRound: pi2.round,
                    playoffGameNumber: pi2.gameNumber,
                    date: pi2.gameDate,
                    time: pi2.gameTime,
                    homeScore: null,
                    awayScore: null,
                    winner: null
                }
            ];

            // Round 1 games (only ones with known opponents)
            const round1Games = [
                {
                    id: `${formatDateForId(w1_1.gameDate)}_${teams[0].teamName}_vs_TBD`,
                    homeTeamName: teams[0].teamName,
                    awayTeamName: 'Winner PI1',
                    gameType: 'playoff',
                    playoffRound: w1_1.round,
                    playoffGameNumber: w1_1.gameNumber,
                    date: w1_1.gameDate,
                    time: w1_1.gameTime,
                    homeScore: null,
                    awayScore: null,
                    winner: null
                },
                {
                    id: `${formatDateForId(w1_2.gameDate)}_${teams[1].teamName}_vs_TBD`,
                    homeTeamName: teams[1].teamName,
                    awayTeamName: 'Winner PI2',
                    gameType: 'playoff',
                    playoffRound: w1_2.round,
                    playoffGameNumber: w1_2.gameNumber,
                    date: w1_2.gameDate,
                    time: w1_2.gameTime,
                    homeScore: null,
                    awayScore: null,
                    winner: null
                },
                {
                    id: `${formatDateForId(w1_3.gameDate)}_${teams[2].teamName}_vs_${teams[5].teamName}`,
                    homeTeamName: teams[2].teamName,
                    awayTeamName: teams[5].teamName,
                    gameType: 'playoff',
                    playoffRound: w1_3.round,
                    playoffGameNumber: w1_3.gameNumber,
                    date: w1_3.gameDate,
                    time: w1_3.gameTime,
                    homeScore: null,
                    awayScore: null,
                    winner: null
                },
                {
                    id: `${formatDateForId(w1_4.gameDate)}_${teams[3].teamName}_vs_${teams[4].teamName}`,
                    homeTeamName: teams[3].teamName,
                    awayTeamName: teams[4].teamName,
                    gameType: 'playoff',
                    playoffRound: w1_4.round,
                    playoffGameNumber: w1_4.gameNumber,
                    date: w1_4.gameDate,
                    time: w1_4.gameTime,
                    homeScore: null,
                    awayScore: null,
                    winner: null
                }
            ];

            // Save all initial games
            const allGames = [...playInGames, ...round1Games];
            
            for (const game of allGames) {
                try {
                    await setDoc(doc(gamesCollection, game.id), game);
                    console.log(`‚úÖ Created game: ${game.id}`);
                } catch (error) {
                    console.error(`Error creating game ${game.id}:`, error);
                }
            }

            console.log(`‚úÖ Created ${allGames.length} playoff games`);
        }

        window.createNextPlayoffGames = async function() {
            if (!userProfile || userProfile.userRole !== USER_ROLES.ADMIN) {
                alert('Only Admins can create playoff games.');
                return;
            }

            if (!confirm('Create playoff games for all matchups with known opponents?\n\nThis will scan the bracket and create games in Firestore for any matchups where both teams are determined.')) {
                return;
            }

            try {
                console.log('üìÖ Scanning bracket for games to create...');
                
                const gamesCollection = collection(db, 'seasons', currentSeason.id, 'games');
                
                // Helper function to convert YYYY-MM-DD to MM_D_YYYY
                const formatDateForId = (dateStr) => {
                    const [year, month, day] = dateStr.split('-');
                    return `${month}_${parseInt(day)}_${year}`;
                };
                
                // Helper function to check if team name is known (not TBD or conditional)
                const isKnownTeam = (teamName) => {
                    if (!teamName) return false;
                    if (teamName === 'TBD') return false;
                    if (teamName.startsWith('Winner of')) return false;
                    if (teamName.startsWith('Loser of')) return false;
                    if (teamName.includes('Winner')) return false;
                    if (teamName.includes('Loser')) return false;
                    return true;
                };
                
                // Collect all matchups from the bracket
                const allMatchups = [
                    ...playoffData.winnersBracket.playIn,
                    ...playoffData.winnersBracket.round1,
                    ...playoffData.winnersBracket.semifinals,
                    ...playoffData.winnersBracket.finals,
                    ...playoffData.losersBracket.round1,
                    ...playoffData.losersBracket.round2,
                    ...playoffData.losersBracket.round3,
                    ...playoffData.losersBracket.semifinals,
                    ...playoffData.losersBracket.finals,
                    ...playoffData.championship
                ];
                
                // Get existing games to avoid duplicates
                const existingGamesQuery = query(
                    gamesCollection,
                    where('gameType', '==', 'playoff')
                );
                const existingGamesSnapshot = await getDocs(existingGamesQuery);
                const existingGameIds = new Set(existingGamesSnapshot.docs.map(doc => doc.id));
                
                console.log(`üìä Found ${existingGameIds.size} existing playoff games`);
                
                let createdCount = 0;
                const gamesToCreate = [];
                
                // Check each matchup
                for (const matchup of allMatchups) {
                    if (!matchup.gameDate) continue; // Skip if no date set
                    
                    const team1 = getTeamDisplay(matchup.team1, matchup);
                    const team2 = getTeamDisplay(matchup.team2, matchup);
                    
                    // Check if both teams are known
                    if (isKnownTeam(team1.name) && isKnownTeam(team2.name)) {
                        const gameId = `${formatDateForId(matchup.gameDate)}_${team1.name}_vs_${team2.name}`;
                        
                        // Check if game already exists
                        if (!existingGameIds.has(gameId)) {
                            gamesToCreate.push({
                                id: gameId,
                                homeTeamName: team1.name,
                                awayTeamName: team2.name,
                                gameType: 'playoff',
                                playoffRound: matchup.round,
                                playoffGameNumber: matchup.gameNumber || null,
                                date: matchup.gameDate,
                                time: matchup.gameTime || null,
                                homeScore: matchup.team1Score !== undefined ? matchup.team1Score : null,
                                awayScore: matchup.team2Score !== undefined ? matchup.team2Score : null,
                                winner: matchup.winner ? (matchup.winner === 1 ? team1.name : team2.name) : null
                            });
                            console.log(`‚úÖ Will create: ${gameId}`);
                        }
                    }
                }
                
                if (gamesToCreate.length === 0) {
                    alert('No new playoff games to create. Either all games with known opponents already exist, or opponents are not yet determined.');
                    return;
                }
                
                console.log(`üìù Creating ${gamesToCreate.length} new playoff games...`);
                
                // Create all games
                for (const game of gamesToCreate) {
                    try {
                        await setDoc(doc(gamesCollection, game.id), game);
                        console.log(`‚úÖ Created game: ${game.id}`);
                        createdCount++;
                    } catch (error) {
                        console.error(`‚ùå Error creating game ${game.id}:`, error);
                    }
                }
                
                alert(`Successfully created ${createdCount} playoff game(s)!`);
                console.log(`‚úÖ Successfully created ${createdCount} playoff games`);
                
            } catch (error) {
                console.error('Error creating playoff games:', error);
                alert('Error creating playoff games: ' + error.message);
            }
        };

        function initializePlayoffBracket() {
            return {
                winnersBracket: {
                    playIn: [
                        { id: 'pi-1', team1: { seed: 8 }, team2: { seed: 9 }, round: 'Play-In', gameDate: '2025-11-16', gameTime: '8:00 AM', gameNumber: 1 },
                        { id: 'pi-2', team1: { seed: 7 }, team2: { seed: 10 }, round: 'Play-In', gameDate: '2025-11-16', gameTime: '10:00 AM', gameNumber: 3 }
                    ],
                    round1: [
                        { id: 'w1-1', team1: { seed: 1 }, team2: { seed: null, from: 'pi-1' }, round: 'Round 1', gameDate: '2025-11-16', gameTime: '9:00 AM', gameNumber: 2 },
                        { id: 'w1-2', team1: { seed: 2 }, team2: { seed: null, from: 'pi-2' }, round: 'Round 1', gameDate: '2025-11-23', gameTime: '9:00 AM', gameNumber: 6 },
                        { id: 'w1-3', team1: { seed: 3 }, team2: { seed: 6 }, round: 'Round 1', gameDate: '2025-11-16', gameTime: '12:00 PM', gameNumber: 5 },
                        { id: 'w1-4', team1: { seed: 4 }, team2: { seed: 5 }, round: 'Round 1', gameDate: '2025-11-16', gameTime: '11:00 AM', gameNumber: 4 }
                    ],
                    semifinals: [
                        { id: 'w2-1', team1: { from: 'w1-1' }, team2: { from: 'w1-4' }, round: 'Semifinals', gameDate: '2025-11-30', gameTime: '10:00 AM', gameNumber: 11 },
                        { id: 'w2-2', team1: { from: 'w1-2' }, team2: { from: 'w1-3' }, round: 'Semifinals', gameDate: '2025-11-30', gameTime: '11:00 AM', gameNumber: 12 }
                    ],
                    finals: [
                        { id: 'w3-1', team1: { from: 'w2-1' }, team2: { from: 'w2-2' }, round: 'Winners Final', gameDate: '2025-12-01', gameTime: '8:00 PM', gameNumber: 15 }
                    ]
                },
                losersBracket: {
                    round1: [
                        // First elimination games - play-in losers play immediately
                        { id: 'l1-1', team1: { loserFrom: 'w1-2' }, team2: { loserFrom: 'pi-1' }, round: 'Elimination Round 1', gameDate: '2025-11-23', gameTime: '10:00 AM', gameNumber: 7 }, // Game 7: Loser of 2 vs Loser of 8/9
                        { id: 'l1-2', team1: { loserFrom: 'w1-1' }, team2: { loserFrom: 'pi-2' }, round: 'Elimination Round 1', gameDate: '2025-11-23', gameTime: '11:00 AM', gameNumber: 8 }  // Game 8: Loser of 1 vs Loser of 7/10
                    ],
                    round2: [
                        // Second elimination games - Round 1 winners face first-round losers from winners bracket
                        { id: 'l2-1', team1: { loserFrom: 'w1-4' }, team2: { from: 'l1-2' }, round: 'Elimination Round 2', gameDate: '2025-11-23', gameTime: '12:00 PM', gameNumber: 9 }, // Game 9: Loser of 4/5 vs Winner of Game 8
                        { id: 'l2-2', team1: { loserFrom: 'w1-3' }, team2: { from: 'l1-1' }, round: 'Elimination Round 2', gameDate: '2025-11-30', gameTime: '9:00 AM', gameNumber: 10 }  // Game 10: Loser of 3/6 vs Winner of Game 7
                    ],
                    round3: [
                        // Third elimination games - semifinal losers enter
                        { id: 'l3-1', team1: { loserFrom: 'w2-2' }, team2: { from: 'l2-1' }, round: 'Elimination Round 3', gameDate: '2025-11-30', gameTime: '12:00 PM', gameNumber: 13 }, // Game 13: Loser of Game 12 vs Winner of Game 9
                        { id: 'l3-2', team1: { loserFrom: 'w2-1' }, team2: { from: 'l2-2' }, round: 'Elimination Round 3', gameDate: '2025-12-01', gameTime: '7:00 PM', gameNumber: 14 }  // Game 14: Loser of Game 11 vs Winner of Game 10
                    ],
                    semifinals: [
                        { id: 'l4-1', team1: { from: 'l3-1' }, team2: { from: 'l3-2' }, round: 'Elimination Semifinals', gameDate: '2025-12-02', gameTime: '7:00 PM', gameNumber: 16 } // Game 16: Winner of Game 13 vs Winner of Game 14
                    ],
                    finals: [
                        { id: 'l5-1', team1: { loserFrom: 'w3-1' }, team2: { from: 'l4-1' }, round: 'Losers Final', gameDate: '2025-12-02', gameTime: '8:00 PM', gameNumber: 17 } // Game 17: Loser of Winners Final vs Winner of Game 16
                    ]
                },
                championship: [
                    { id: 'champ', team1: { from: 'w3-1' }, team2: { from: 'l5-1' }, round: 'Championship', gameDate: '2025-12-07', gameTime: '10:00 AM', gameNumber: 18 },
                    { id: 'champ-if-necessary', team1: { from: 'champ' }, team2: { loserFrom: 'champ' }, round: 'Championship (If Necessary)', gameDate: '2025-12-07', gameTime: '11:00 AM', gameNumber: 19 }
                ]
            };
        }

        function renderBracket() {
            const container = document.getElementById('bracketsContainer');
            
            // Update status banner
            const statusEl = document.getElementById('bracketStatus');
            if (isProjected) {
                statusEl.className = 'bracket-status projected';
                // Only show "Click Lock Bracket" message to admins/staff
                if (userCanManagePlayoffs) {
                    statusEl.innerHTML = 'üìä PROJECTED BRACKET - Based on current standings. Click "Lock Bracket" when ready to start playoffs.';
                } else {
                    statusEl.innerHTML = 'üìä PROJECTED BRACKET - Based on current standings.';
                }
            } else {
                statusEl.className = 'bracket-status locked';
                statusEl.innerHTML = 'üîí OFFICIAL PLAYOFF BRACKET - Locked on ' + (playoffData.lockedAt ? new Date(playoffData.lockedAt).toLocaleDateString() : 'N/A');
            }
            
            container.innerHTML = `
                ${renderWinnersBracket()}
                ${renderLosersBracket()}
                ${renderChampionship()}
            `;

            // Add click handlers if in edit mode
            if (editMode && !isProjected) {
                document.querySelectorAll('.matchup').forEach(matchup => {
                    matchup.style.cursor = 'pointer';
                    matchup.addEventListener('click', function(e) {
                        // Don't open edit modal if clicking the game link
                        if (e.target.closest('.game-link')) {
                            return;
                        }
                        const matchupId = this.dataset.matchupId;
                        openEditModal(matchupId);
                    });
                });
            }
        }

        function renderWinnersBracket() {
            const wb = playoffData.winnersBracket;
            
            // Reorder Round 1 matchups for proper bracket display
            // Top to bottom: 1 vs 8/9, 4 vs 5, 3 vs 6, 2 vs 7/10
            const round1Reordered = [
                wb.round1[0], // 1 vs 8/9 winner (top)
                wb.round1[3], // 4 vs 5 (middle-top)
                wb.round1[2], // 3 vs 6 (middle-bottom)
                wb.round1[1]  // 2 vs 7/10 winner (bottom)
            ];
            
            return `
                <div class="bracket-section winners-bracket">
                    <div class="bracket-title">üèÜ Winners Bracket</div>
                    <div class="bracket-grid">
                        ${renderRoundWithClass(wb.playIn, 'Play-In Games', 'play-in')}
                        ${renderRoundCustom(round1Reordered, 'Round 1', 'round-1')}
                        ${renderRoundWithClass(wb.semifinals, 'Semifinals', 'semifinals')}
                        ${renderRoundWithClass(wb.finals, 'Winners Final', 'finals')}
                    </div>
                </div>
            `;
        }

        function renderLosersBracket() {
            const lb = playoffData.losersBracket;
            return `
                <div class="bracket-section">
                    <div class="bracket-title">‚ö†Ô∏è Elimination Bracket</div>
                    <div class="bracket-grid">
                        ${renderRound(lb.round1, 'Elimination Round 1')}
                        ${renderRound(lb.round2, 'Elimination Round 2')}
                        ${renderRound(lb.round3, 'Elimination Round 3')}
                        ${renderRound(lb.semifinals, 'Elimination Semifinals')}
                        ${renderRound(lb.finals, 'Losers Final')}
                    </div>
                </div>
            `;
        }

        function renderChampionship() {
            return `
                <div class="bracket-section">
                    <div class="bracket-title">üèÜ Championship</div>
                    <div class="bracket-grid" style="justify-content: center;">
                        ${renderRound(playoffData.championship, 'Championship')}
                    </div>
                </div>
            `;
        }

        function renderRound(matchups, title) {
            return `
                <div class="round">
                    <div class="round-title">${title}</div>
                    ${matchups.map(m => renderMatchup(m)).join('')}
                </div>
            `;
        }

        function renderRoundWithClass(matchups, title, cssClass) {
            return `
                <div class="round ${cssClass}">
                    <div class="round-title">${title}</div>
                    ${matchups.map(m => renderMatchup(m)).join('')}
                </div>
            `;
        }

        function renderRoundCustom(matchups, title, cssClass) {
            const positions = ['position-top', 'position-middle-top', 'position-middle-bottom', 'position-bottom'];
            return `
                <div class="round ${cssClass}">
                    <div class="round-title">${title}</div>
                    ${matchups.map((m, idx) => renderMatchup(m, positions[idx])).join('')}
                </div>
            `;
        }

        function renderMatchup(matchup, positionClass = '') {
            const isChampionship = matchup.id === 'champ';
            const team1 = getTeamDisplay(matchup.team1, matchup);
            const team2 = getTeamDisplay(matchup.team2, matchup);
            
            const winner = matchup.winner;
            const team1Class = winner === 1 ? 'winner' : (winner === 2 ? 'loser' : '');
            const team2Class = winner === 2 ? 'winner' : (winner === 1 ? 'loser' : '');

            // Check if we can link to game preview (need both team names and a date)
            const canLinkToPreview = team1.name !== 'TBD' && team2.name !== 'TBD' && matchup.gameDate;
            const previewLink = canLinkToPreview 
                ? `game-preview.html?home=${encodeURIComponent(team1.name)}&away=${encodeURIComponent(team2.name)}&date=${matchup.gameDate}&gameType=playoff&round=${encodeURIComponent(matchup.round)}&gameNumber=${matchup.gameNumber}`
                : null;

            return `
                <div class="matchup ${isChampionship ? 'championship' : ''} ${positionClass}" 
                     data-matchup-id="${matchup.id}">
                    ${matchup.gameDate ? `<div class="matchup-date">${formatDate(matchup.gameDate)}</div>` : ''}
                    ${matchup.gameTime ? `<div class="matchup-time">${matchup.gameTime}</div>` : ''}
                    ${canLinkToPreview ? `
                        <a href="${previewLink}" class="game-link" title="View Game Preview">
                            <div class="game-link-icon">üìä</div>
                        </a>
                    ` : ''}
                    <div class="team ${team1Class}">
                        <span class="seed">${team1.seed || ''}</span>
                        <span class="team-name">${team1.name} ${isProjected && team1.record ? `<span style="opacity: 0.7; font-size: 0.85em;">${team1.record}</span>` : ''}</span>
                        <span class="score ${matchup.team1Score === undefined ? 'tbd' : ''}">
                            ${matchup.team1Score !== undefined ? matchup.team1Score : '-'}
                        </span>
                    </div>
                    <div class="team ${team2Class}">
                        <span class="seed">${team2.seed || ''}</span>
                        <span class="team-name">${team2.name} ${isProjected && team2.record ? `<span style="opacity: 0.7; font-size: 0.85em;">${team2.record}</span>` : ''}</span>
                        <span class="score ${matchup.team2Score === undefined ? 'tbd' : ''}">
                            ${matchup.team2Score !== undefined ? matchup.team2Score : '-'}
                        </span>
                    </div>
                </div>
            `;
        }

        function getTeamDisplay(teamData, matchup = null) {
            if (!teamData) return { name: 'TBD', seed: '', record: '' };
            
            // Special handling for championship game
            if (matchup && matchup.id === 'champ') {
                if (teamData.from === 'w3-1') {
                    return { name: 'Winners Bracket Winner', seed: '', record: '' };
                }
                if (teamData.from === 'l5-1') {
                    return { name: 'Losers Bracket Winner', seed: '', record: '' };
                }
            }
            
            if (teamData.seed) {
                const team = teams.find(t => t.seed === teamData.seed);
                return {
                    seed: teamData.seed,
                    name: team ? (team.name || team.teamName) : `Seed ${teamData.seed}`,
                    teamId: team?.id,
                    record: team && (team.wins !== undefined) ? `(${team.wins}-${team.losses})` : ''
                };
            }
            
            if (teamData.from) {
                // This team comes from winning a previous game
                const sourceGame = findMatchup(teamData.from);
                if (sourceGame) {
                    const team1Display = getSourceTeamName(sourceGame.team1);
                    const team2Display = getSourceTeamName(sourceGame.team2);
                    return {
                        name: `Winner of ${team1Display} vs ${team2Display}`,
                        seed: '',
                        record: ''
                    };
                }
                return {
                    name: `Winner of ${teamData.from}`,
                    seed: '',
                    record: ''
                };
            }
            
            if (teamData.loserFrom) {
                // This team comes from losing a previous game
                const sourceGame = findMatchup(teamData.loserFrom);
                if (sourceGame) {
                    const team1Display = getSourceTeamName(sourceGame.team1);
                    const team2Display = getSourceTeamName(sourceGame.team2);
                    return {
                        name: `Loser of ${team1Display} vs ${team2Display}`,
                        seed: '',
                        record: ''
                    };
                }
                return {
                    name: `Loser of ${teamData.loserFrom}`,
                    seed: '',
                    record: ''
                };
            }
            
            return { name: 'TBD', seed: '', record: '' };
        }

        function getSourceTeamName(teamData) {
            // Helper function to get a concise team identifier for display in "Winner of X vs Y"
            if (!teamData) return 'TBD';
            
            if (teamData.seed) {
                return `${teamData.seed}`;
            }
            
            if (teamData.from) {
                // Recursively get the description for this source
                const sourceGame = findMatchup(teamData.from);
                if (sourceGame) {
                    const t1 = getSourceTeamName(sourceGame.team1);
                    const t2 = getSourceTeamName(sourceGame.team2);
                    return `${t1}/${t2} Winner`;
                }
                return `Winner ${teamData.from}`;
            }
            
            if (teamData.loserFrom) {
                // Recursively get the description for losers
                const sourceGame = findMatchup(teamData.loserFrom);
                if (sourceGame) {
                    const t1 = getSourceTeamName(sourceGame.team1);
                    const t2 = getSourceTeamName(sourceGame.team2);
                    return `${t1}/${t2} Loser`;
                }
                return `Loser ${teamData.loserFrom}`;
            }
            
            return 'TBD';
        }

        function formatDate(dateStr) {
            // Parse the date string as local time to avoid timezone offset issues
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day); // month is 0-indexed
            return date.toLocaleDateString('en-US', { 
                weekday: 'short', 
                month: 'short', 
                day: 'numeric' 
            });
        }

        function findMatchup(matchupId) {
            // Search all brackets for the matchup
            const allMatchups = [
                ...playoffData.winnersBracket.playIn,
                ...playoffData.winnersBracket.round1,
                ...playoffData.winnersBracket.semifinals,
                ...playoffData.winnersBracket.finals,
                ...playoffData.losersBracket.round1,
                ...playoffData.losersBracket.round2,
                ...playoffData.losersBracket.round3,
                ...playoffData.losersBracket.semifinals,
                ...playoffData.losersBracket.finals,
                ...playoffData.championship
            ];
            
            return allMatchups.find(m => m.id === matchupId);
        }

        window.toggleEditMode = function() {
            if (!userCanManagePlayoffs) {
                alert('Only League Staff and Admins can edit playoff brackets.');
                return;
            }
            
            if (isProjected) {
                alert('Cannot edit projected bracket. Please lock the bracket first to set official playoff matchups.');
                return;
            }
            
            editMode = !editMode;
            document.getElementById('editModeText').textContent = 
                editMode ? 'Disable Edit Mode' : 'Enable Edit Mode';
            renderBracket();
        };

        window.openEditModal = function(matchupId) {
            if (!editMode) return;
            
            currentEditMatchup = findMatchup(matchupId);
            if (!currentEditMatchup) return;

            document.getElementById('gameDate').value = currentEditMatchup.gameDate || '';
            document.getElementById('gameTime').value = currentEditMatchup.gameTime || '';
            document.getElementById('team1Score').value = currentEditMatchup.team1Score !== undefined ? currentEditMatchup.team1Score : '';
            document.getElementById('team2Score').value = currentEditMatchup.team2Score !== undefined ? currentEditMatchup.team2Score : '';

            document.getElementById('editModal').classList.add('active');
        };

        window.closeModal = function() {
            document.getElementById('editModal').classList.remove('active');
            currentEditMatchup = null;
        };

        window.saveMatchup = async function() {
            if (!currentEditMatchup) return;

            const gameDate = document.getElementById('gameDate').value;
            const gameTime = document.getElementById('gameTime').value;
            const team1Score = document.getElementById('team1Score').value;
            const team2Score = document.getElementById('team2Score').value;

            // Update the matchup
            currentEditMatchup.gameDate = gameDate || null;
            currentEditMatchup.gameTime = gameTime || null;
            currentEditMatchup.team1Score = team1Score !== '' ? parseInt(team1Score) : undefined;
            currentEditMatchup.team2Score = team2Score !== '' ? parseInt(team2Score) : undefined;

            // Determine winner if both scores are entered
            if (team1Score !== '' && team2Score !== '') {
                currentEditMatchup.winner = parseInt(team1Score) > parseInt(team2Score) ? 1 : 2;
            } else {
                currentEditMatchup.winner = null;
            }

            // Save to Firebase
            try {
                const playoffRef = doc(db, 'seasons', currentSeason.id, 'playoffs', 'bracket');
                await updateDoc(playoffRef, playoffData);
                closeModal();
                renderBracket();
            } catch (error) {
                console.error('Error saving matchup:', error);
                alert('Error saving matchup. Please try again.');
            }
        };

        // Initialize - auth state change handler will call loadPlayoffBracket()
    </script>
</body>
</html>

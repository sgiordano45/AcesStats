<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playoffs - Mountainside Aces</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #bf360c 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(191, 54, 12, 0.3);
            border-radius: 15px;
            border: 2px solid #ff5722;
        }

        .playoff-logo {
            max-width: 300px;
            width: 100%;
            height: auto;
            margin-bottom: 20px;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
        }

        h1 {
            font-size: 2.5em;
            color: #ff7043;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .season-info {
            font-size: 1.2em;
            color: #ffccbc;
            margin-top: 10px;
        }

        .bracket-status {
            font-size: 1em;
            text-align: center;
        }

        .bracket-status.projected {
            background: rgba(255, 138, 80, 0.2);
            border: 2px solid #ff8a50;
            color: #ffb74d;
        }

        .bracket-status.locked {
            background: rgba(255, 87, 34, 0.3);
            border: 2px solid #ff5722;
            color: #ffccbc;
        }

        .bracket-container {
            display: flex;
            flex-direction: column;
            gap: 60px;
            margin-top: 30px;
        }

        .bracket-section {
            background: rgba(255, 87, 34, 0.1);
            border: 2px solid #ff5722;
            border-radius: 15px;
            padding: 30px;
        }

        .bracket-title {
            font-size: 2em;
            color: #ff7043;
            text-align: center;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 3px solid #bf360c;
            padding-bottom: 15px;
        }

        .bracket-grid {
            display: flex;
            justify-content: flex-start;
            gap: 60px;
            overflow-x: auto;
            padding: 20px 0;
            align-items: center;
        }

        .round {
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 280px;
            position: relative;
        }

        /* Specific spacing for winners bracket rounds */
        .winners-bracket .round {
            gap: 20px;
        }

        .winners-bracket .round.play-in {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 800px; /* Increased to match full bracket height */
        }

        /* Position play-in games at extreme top and bottom */
        .winners-bracket .round.play-in .matchup:last-child {
            margin-top: auto;
        }

        .winners-bracket .round.round-1 {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 800px; /* Match play-in height */
        }

        .winners-bracket .round.semifinals {
            justify-content: space-around;
            height: 400px;
        }

        .winners-bracket .round.finals {
            justify-content: center;
            height: 200px;
        }

        /* Remove individual positioning since we're using flex spacing */
        .matchup.position-top {
            /* Top position handled by flex */
        }

        .matchup.position-middle-top {
            /* Middle-top position handled by flex */
        }

        .matchup.position-middle-bottom {
            /* Middle-bottom position handled by flex */
        }

        .matchup.position-bottom {
            /* Bottom position handled by flex */
        }

        .round-title {
            text-align: center;
            font-size: 1.1em;
            color: #ffccbc;
            margin-bottom: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .matchup {
            background: rgba(191, 54, 12, 0.4);
            border: 2px solid #bf360c;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 40px;
            position: relative;
            transition: all 0.3s ease;
        }

        .matchup:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 87, 34, 0.4);
            border-color: #ff5722;
        }

        .game-link {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 87, 34, 0.9);
            border: 2px solid #ff5722;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            text-decoration: none;
        }

        .game-link:hover {
            background: #ff5722;
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 4px 12px rgba(255, 87, 34, 0.6);
        }

        .game-link-icon {
            font-size: 1.2em;
        }

        .matchup-date {
            text-align: center;
            font-size: 0.85em;
            color: #ffccbc;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .matchup-time {
            text-align: center;
            font-size: 0.8em;
            color: #ff8a65;
            margin-bottom: 15px;
        }

        .team {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .team:last-child {
            margin-bottom: 0;
        }

        .team:hover {
            background: rgba(26, 107, 74, 0.3);
        }

        .team.winner {
            background: rgba(26, 107, 74, 0.5);
            border: 2px solid #1a6b4a;
            font-weight: bold;
        }

        .team.loser {
            opacity: 0.6;
        }

        .seed {
            font-size: 0.85em;
            color: #ffccbc;
            font-weight: bold;
            min-width: 25px;
        }

        .team-name {
            flex: 1;
            margin: 0 15px;
            font-size: 1em;
        }

        .score {
            font-size: 1.3em;
            font-weight: bold;
            color: #ff7043;
            min-width: 35px;
            text-align: center;
        }

        .tbd {
            color: #666;
            font-style: italic;
        }

        /* Connector lines */
        .connector {
            position: absolute;
            border: 2px solid #bf360c;
        }

        /* Championship styling */
        .championship {
            background: linear-gradient(135deg, rgba(255, 87, 34, 0.3), rgba(191, 54, 12, 0.3));
            border: 3px solid #ff5722;
            box-shadow: 0 0 30px rgba(255, 87, 34, 0.5);
        }

        .championship .team {
            font-size: 1.1em;
            padding: 15px;
        }

        /* Elimination indicator */
        .elimination-round {
            position: relative;
        }

        .elimination-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #d32f2f;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* Loading and Edit states */
        .loading {
            text-align: center;
            padding: 40px;
            color: #ffccbc;
            font-size: 1.2em;
        }

        .edit-mode-toggle {
            text-align: center;
            margin: 20px 0;
        }

        .btn {
            background: #bf360c;
            color: white;
            border: 2px solid #ff5722;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #ff5722;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .bracket-grid {
                justify-content: flex-start;
            }

            .round {
                min-width: 240px;
            }

            h1 {
                font-size: 2em;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .bracket-section {
                padding: 15px;
            }

            .round {
                min-width: 200px;
            }

            .team-name {
                font-size: 0.9em;
            }

            .bracket-title {
                font-size: 1.5em;
            }
        }

        /* Modal for editing */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            border: 3px solid #ff5722;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }

        .modal-title {
            color: #ff7043;
            font-size: 1.5em;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            color: #ffccbc;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #bf360c;
            border-radius: 8px;
            background: rgba(191, 54, 12, 0.2);
            color: white;
            font-size: 1em;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #ff5722;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .btn-cancel {
            background: #666;
            border-color: #888;
        }

        .btn-cancel:hover {
            background: #555;
        }

        nav {
            background: rgba(191, 54, 12, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        nav a {
            color: #ffccbc;
            text-decoration: none;
            margin: 0 15px;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        nav a:hover {
            color: #ff7043;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="index.html">Home</a>
            <a href="current-season.html">Current Season</a>
            <a href="teams.html">Teams</a>
            <a href="players.html">Players</a>
        </nav>

        <header>
            <img src="photos/2025 Fall Playoff logo.png" alt="2025 Fall Playoffs" class="playoff-logo">
            <h1>üèÜPlayoff Bracket</h1>
            <div class="season-info" id="seasonInfo">Loading season information...</div>
            <div id="bracketStatus" class="bracket-status" style="margin-top: 15px; padding: 10px; border-radius: 8px; font-weight: 600;"></div>
        </header>

        <div class="edit-mode-toggle">
            <button class="btn" id="lockBracketBtn" onclick="lockBracket()" style="display: none;">
                üîí Lock Bracket for Playoffs
            </button>
            <button class="btn" id="editModeBtn" onclick="toggleEditMode()" style="display: none;">
                <span id="editModeText">Enable Edit Mode</span>
            </button>
        </div>

        <div id="bracketsContainer">
            <div class="loading">Loading playoff bracket...</div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">Edit Matchup</h2>
            <div class="form-group">
                <label for="gameDate">Game Date:</label>
                <input type="date" id="gameDate">
            </div>
            <div class="form-group">
                <label for="gameTime">Game Time:</label>
                <input type="time" id="gameTime">
            </div>
            <div class="form-group">
                <label for="team1Score">Team 1 Score:</label>
                <input type="number" id="team1Score" min="0">
            </div>
            <div class="form-group">
                <label for="team2Score">Team 2 Score:</label>
                <input type="number" id="team2Score" min="0">
            </div>
            <div class="modal-buttons">
                <button class="btn btn-cancel" onclick="closeModal()">Cancel</button>
                <button class="btn" onclick="saveMatchup()">Save</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { db, collection, query, where, getDocs, doc, getDoc } from './firebase-config.js';
        import { getCurrentSeason, getSeasonGames } from './firebase-data.js';
        import { getCurrentUser, getUserProfile, USER_ROLES, onAuthChange } from './firebase-auth.js';
        import { setDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        let currentSeason = null;
        let playoffData = null;
        let editMode = false;
        let currentEditMatchup = null;
        let teams = [];
        let isProjected = true; // True until bracket is locked in
        let currentUser = null;
        let userProfile = null;
        let userCanManagePlayoffs = false; // True if user is Admin or League-Staff
        let authReady = false;

        // Wait for auth state to be ready before loading playoff data
        onAuthChange(async (user) => {
            if (!authReady) {
                authReady = true;
                currentUser = user;
                
                if (currentUser) {
                    const profileResult = await getUserProfile(currentUser.uid);
                    if (profileResult.success) {
                        userProfile = profileResult.data;
                        // Check if user is Admin or League-Staff
                        userCanManagePlayoffs = (
                            userProfile.userRole === USER_ROLES.ADMIN || 
                            userProfile.userRole === USER_ROLES.LEAGUE_STAFF
                        );
                        console.log('üë§ User role:', userProfile.userRole, '| Can manage playoffs:', userCanManagePlayoffs);
                    }
                } else {
                    console.log('üë§ No user logged in');
                }
                
                // Now load the playoff bracket
                loadPlayoffBracket();
            }
        });

        // Load current season and playoff data
        async function loadPlayoffBracket() {
            try {
                // Get current season using the same method as current-season.html
                currentSeason = await getCurrentSeason();
                
                if (!currentSeason) {
                    document.getElementById('bracketsContainer').innerHTML = 
                        '<div class="loading">No active season found</div>';
                    return;
                }

                console.log('√¢≈ì‚Ä¶ Current season:', currentSeason);

                // Update header
                document.getElementById('seasonInfo').textContent = 
                    `${currentSeason.year} ${currentSeason.season.charAt(0).toUpperCase() + currentSeason.season.slice(1)} Season - Playoffs`;

                // Load teams with their seeds
                await loadTeams();

                // Load or initialize playoff data
                const playoffRef = doc(db, 'seasons', currentSeason.id, 'playoffs', 'bracket');
                let playoffDoc;
                
                try {
                    playoffDoc = await getDoc(playoffRef);
                } catch (error) {
                    console.log('‚ö†Ô∏è Could not access playoff bracket document');
                    playoffDoc = null;
                }

                if (playoffDoc && playoffDoc.exists()) {
                    playoffData = playoffDoc.data();
                    isProjected = playoffData.isProjected !== false; // Default to projected if not set
                    console.log('‚úÖ Loaded existing playoff data', isProjected ? '(PROJECTED)' : '(LOCKED)');
                } else {
                    // Initialize new playoff bracket (just in memory, won't save without permission)
                    playoffData = initializePlayoffBracket();
                    isProjected = true;
                    console.log('üìã Initialized projected playoff bracket');
                }

                renderBracket();
                updateLockButton();
            } catch (error) {
                console.error('Error loading playoff bracket:', error);
                document.getElementById('bracketsContainer').innerHTML = 
                    '<div class="loading">Error loading playoff bracket: ' + error.message + '</div>';
            }
        }

        async function loadTeams() {
            // Just calculate standings - teams array will have name, wins, losses from standings
            console.log('üìä Calculating standings to determine playoff seeds...');
            teams = await calculateStandings();
        }

        async function calculateStandings() {
            // Get all games for this season using getSeasonGames (same as current-season.html)
            const allGames = await getSeasonGames(currentSeason.id);
            console.log(`üìä Found ${allGames.length} total games for season`);
            
            // Map games to the format expected (same as current-season.html does)
            const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
            
            const games = allGames.map(g => {
                const dateObj = g.date && g.date.seconds ? 
                    new Date(g.date.seconds * 1000) : 
                    new Date(g.date || Date.now());
                const dateString = dateObj.toLocaleDateString('en-US');
                
                return {
                    "home team": g.homeTeamName || capitalize(g.homeTeamId) || "",
                    "away team": g.awayTeamName || capitalize(g.awayTeamId) || "",
                    "home score": g.homeScore !== undefined ? g.homeScore : null,
                    "away score": g.awayScore !== undefined ? g.awayScore : null,
                    winner: capitalize(g.winner),
                    game_type: g.gameType === "regular" ? "Regular" :
                               g.gameType === "playoff" ? "Playoff" :
                               capitalize(g.gameType) || "Regular",
                    date: dateString
                };
            });
            
            // Filter to completed regular season games
            const today = new Date();
            const parseGameDate = (dateStr) => {
                const [month, day, year] = dateStr.split('/').map(Number);
                return new Date(year, month - 1, day);
            };
            
            const completedGames = games.filter(g =>
                g.winner && g.winner.trim() !== "" && parseGameDate(g.date) < today
            );
            
            const regularGames = completedGames.filter(g => g.game_type === 'Regular');
            
            console.log(`üìä Processing ${regularGames.length} completed regular season games`);
            
            if (regularGames.length === 0) {
                console.log('‚ö†Ô∏è No completed games yet - returning empty standings');
                return [];
            }

            // Use the EXACT calculateStandings logic from current-season.html
            const teamStats = {};

            regularGames.forEach(game => {
                const homeTeam = game["home team"];
                const awayTeam = game["away team"];
                const winner = game.winner;
                const homeScore = parseInt(game["home score"]) || 0;
                const awayScore = parseInt(game["away score"]) || 0;

                if (!teamStats[homeTeam]) {
                    teamStats[homeTeam] = {
                        name: homeTeam, wins: 0, losses: 0, ties: 0,
                        runsFor: 0, runsAgainst: 0, h2h: {}
                    };
                }
                if (!teamStats[awayTeam]) {
                    teamStats[awayTeam] = {
                        name: awayTeam, wins: 0, losses: 0, ties: 0,
                        runsFor: 0, runsAgainst: 0, h2h: {}
                    };
                }

                teamStats[homeTeam].runsFor += homeScore;
                teamStats[homeTeam].runsAgainst += awayScore;
                teamStats[awayTeam].runsFor += awayScore;
                teamStats[awayTeam].runsAgainst += homeScore;

                if (!teamStats[homeTeam].h2h[awayTeam]) {
                    teamStats[homeTeam].h2h[awayTeam] = { wins: 0, losses: 0, ties: 0 };
                }
                if (!teamStats[awayTeam].h2h[homeTeam]) {
                    teamStats[awayTeam].h2h[homeTeam] = { wins: 0, losses: 0, ties: 0 };
                }

                if (winner === "Tie") {
                    teamStats[homeTeam].ties++;
                    teamStats[awayTeam].ties++;
                    teamStats[homeTeam].h2h[awayTeam].ties++;
                    teamStats[awayTeam].h2h[homeTeam].ties++;
                } else if (winner === homeTeam) {
                    teamStats[homeTeam].wins++;
                    teamStats[awayTeam].losses++;
                    teamStats[homeTeam].h2h[awayTeam].wins++;
                    teamStats[awayTeam].h2h[homeTeam].losses++;
                } else if (winner === awayTeam) {
                    teamStats[awayTeam].wins++;
                    teamStats[homeTeam].losses++;
                    teamStats[awayTeam].h2h[homeTeam].wins++;
                    teamStats[homeTeam].h2h[awayTeam].losses++;
                }
            });

            const preliminaryStandings = Object.values(teamStats)
                .map(team => {
                    const totalDecided = team.wins + team.losses;
                    team.winPct = totalDecided > 0 ? (team.wins / totalDecided) : 0;
                    team.runDifferential = team.runsFor - team.runsAgainst;
                    return team;
                });

            const standings = preliminaryStandings.sort((a, b) => {
                // First tiebreaker: Win percentage
                if (a.winPct !== b.winPct) return b.winPct - a.winPct;
                
                // Check if there are 3+ teams tied at this win percentage
                const teamsAtSameWinPct = preliminaryStandings.filter(t => t.winPct === a.winPct);
                
                // Second tiebreaker: Only use H2H if EXACTLY 2 teams are tied
                if (teamsAtSameWinPct.length === 2) {
                    const h2hComp = compareHeadToHead(a, b);
                    if (h2hComp !== 0) return h2hComp;
                }
                
                // Third tiebreaker: Runs Against (for 3+ teams tied, or if H2H didn't resolve)
                if (a.runsAgainst !== b.runsAgainst) return a.runsAgainst - b.runsAgainst;
                
                // Fourth tiebreaker: Run Differential
                return b.runDifferential - a.runDifferential;
            });

            // Take top 10 and add seed numbers (exactly like current-season.html)
            const playoffTeams = standings.slice(0, 10).map((team, index) => ({
                ...team,
                seed: index + 1,
                teamName: team.name // Add teamName for compatibility
            }));

            console.log('‚úÖ Calculated playoff seeds:', playoffTeams.map(t => `${t.seed}. ${t.name} (${t.wins}-${t.losses})`));

            return playoffTeams;
        }

        function compareHeadToHead(teamA, teamB) {
            const aVsB = teamA.h2h[teamB.name];
            const bVsA = teamB.h2h[teamA.name];
            
            if (!aVsB || !bVsA) return 0;
            
            const aH2HWinPct = (aVsB.wins + aVsB.losses) > 0 ? aVsB.wins / (aVsB.wins + aVsB.losses) : 0;
            const bH2HWinPct = (bVsA.wins + bVsA.losses) > 0 ? bVsA.wins / (bVsA.wins + bVsA.losses) : 0;
            
            if (aH2HWinPct !== bH2HWinPct) {
                return bH2HWinPct - aH2HWinPct;
            }
            
            return 0;
        }

        function updateLockButton() {
            const lockBtn = document.getElementById('lockBracketBtn');
            const editBtn = document.getElementById('editModeBtn');
            
            // Only show lock button if user has permission, bracket is projected, and we have enough teams
            if (userCanManagePlayoffs && isProjected && teams.length >= 10) {
                lockBtn.style.display = 'inline-block';
            } else {
                lockBtn.style.display = 'none';
            }
            
            // Only show edit mode button if user has permission and bracket is locked
            if (userCanManagePlayoffs && !isProjected) {
                editBtn.style.display = 'inline-block';
            } else {
                editBtn.style.display = 'none';
            }
        }

        window.lockBracket = async function() {
            if (!confirm(`Lock in the current playoff bracket?\n\nThis will:\n√¢‚Ç¨¬¢ Set the playoff seeds based on current standings\n√¢‚Ç¨¬¢ Create playoff game IDs\n√¢‚Ç¨¬¢ Make the bracket official\n\nThis cannot be undone. Continue?`)) {
                return;
            }

            try {
                console.log('üîí Locking playoff bracket...');

                // Update playoff data to mark as locked
                playoffData.isProjected = false;
                playoffData.lockedAt = new Date().toISOString();
                playoffData.lockedSeeds = teams.map(t => ({
                    seed: t.seed,
                    teamName: t.teamName,
                    teamId: t.id,
                    record: `${t.wins}-${t.losses}`
                }));

                // Save to Firebase
                const playoffRef = doc(db, 'seasons', currentSeason.id, 'playoffs', 'bracket');
                await setDoc(playoffRef, playoffData);

                // Create playoff game IDs in the games collection
                await createPlayoffGames();

                isProjected = false;
                console.log('√¢≈ì‚Ä¶ Bracket locked successfully!');
                alert('Playoff bracket has been locked! You can now set game dates and enter scores.');
                
                updateLockButton();
                renderBracket();
            } catch (error) {
                console.error('Error locking bracket:', error);
                alert('Error locking bracket: ' + error.message);
            }
        };

        async function createPlayoffGames() {
            console.log('üìÖ Creating playoff game IDs...');
            
            const gamesCollection = collection(db, 'seasons', currentSeason.id, 'games');
            
            // Play-in games
            const playInGames = [
                {
                    id: 'playoff_pi1_seed8_vs_seed9',
                    'home team': teams[7].teamName, // Seed 8
                    'away team': teams[8].teamName, // Seed 9
                    game_type: 'Playoff',
                    round: 'Play-In',
                    date: '',
                    time: '',
                    'home score': '',
                    'away score': '',
                    winner: ''
                },
                {
                    id: 'playoff_pi2_seed7_vs_seed10',
                    'home team': teams[6].teamName, // Seed 7
                    'away team': teams[9].teamName, // Seed 10
                    game_type: 'Playoff',
                    round: 'Play-In',
                    date: '',
                    time: '',
                    'home score': '',
                    'away score': '',
                    winner: ''
                }
            ];

            // Round 1 games
            const round1Games = [
                {
                    id: 'playoff_r1g1_seed1_vs_winner_pi1',
                    'home team': teams[0].teamName, // Seed 1
                    'away team': 'Winner PI1', // Will be updated after play-in
                    game_type: 'Playoff',
                    round: 'Round 1',
                    date: '',
                    time: '',
                    'home score': '',
                    'away score': '',
                    winner: ''
                },
                {
                    id: 'playoff_r1g2_seed2_vs_winner_pi2',
                    'home team': teams[1].teamName, // Seed 2
                    'away team': 'Winner PI2',
                    game_type: 'Playoff',
                    round: 'Round 1',
                    date: '',
                    time: '',
                    'home score': '',
                    'away score': '',
                    winner: ''
                },
                {
                    id: 'playoff_r1g3_seed3_vs_seed6',
                    'home team': teams[2].teamName, // Seed 3
                    'away team': teams[5].teamName, // Seed 6
                    game_type: 'Playoff',
                    round: 'Round 1',
                    date: '',
                    time: '',
                    'home score': '',
                    'away score': '',
                    winner: ''
                },
                {
                    id: 'playoff_r1g4_seed4_vs_seed5',
                    'home team': teams[3].teamName, // Seed 4
                    'away team': teams[4].teamName, // Seed 5
                    game_type: 'Playoff',
                    round: 'Round 1',
                    date: '',
                    time: '',
                    'home score': '',
                    'away score': '',
                    winner: ''
                }
            ];

            // Save all initial games
            const allGames = [...playInGames, ...round1Games];
            
            for (const game of allGames) {
                try {
                    await setDoc(doc(gamesCollection, game.id), game);
                    console.log(`√¢≈ì‚Ä¶ Created game: ${game.id}`);
                } catch (error) {
                    console.error(`Error creating game ${game.id}:`, error);
                }
            }

            console.log(`‚úÖ Created ${allGames.length} playoff games`);
        }

        function initializePlayoffBracket() {
            return {
                winnersBracket: {
                    playIn: [
                        { id: 'pi-1', team1: { seed: 8 }, team2: { seed: 9 }, round: 'Play-In' },
                        { id: 'pi-2', team1: { seed: 7 }, team2: { seed: 10 }, round: 'Play-In' }
                    ],
                    round1: [
                        { id: 'w1-1', team1: { seed: 1 }, team2: { seed: null, from: 'pi-1' }, round: 'Round 1' },
                        { id: 'w1-2', team1: { seed: 2 }, team2: { seed: null, from: 'pi-2' }, round: 'Round 1' },
                        { id: 'w1-3', team1: { seed: 3 }, team2: { seed: 6 }, round: 'Round 1' },
                        { id: 'w1-4', team1: { seed: 4 }, team2: { seed: 5 }, round: 'Round 1' }
                    ],
                    semifinals: [
                        { id: 'w2-1', team1: { from: 'w1-1' }, team2: { from: 'w1-4' }, round: 'Semifinals' },
                        { id: 'w2-2', team1: { from: 'w1-2' }, team2: { from: 'w1-3' }, round: 'Semifinals' }
                    ],
                    finals: [
                        { id: 'w3-1', team1: { from: 'w2-1' }, team2: { from: 'w2-2' }, round: 'Winners Final' }
                    ]
                },
                losersBracket: {
                    round1: [
                        // First elimination games - play-in losers play immediately
                        { id: 'l1-1', team1: { loserFrom: 'w1-2' }, team2: { loserFrom: 'pi-1' }, round: 'Elimination Round 1' }, // Game 7: Loser of 2 vs Loser of 8/9
                        { id: 'l1-2', team1: { loserFrom: 'w1-1' }, team2: { loserFrom: 'pi-2' }, round: 'Elimination Round 1' }  // Game 8: Loser of 1 vs Loser of 7/10
                    ],
                    round2: [
                        // Second elimination games - Round 1 winners face first-round losers from winners bracket
                        { id: 'l2-1', team1: { loserFrom: 'w1-4' }, team2: { from: 'l1-2' }, round: 'Elimination Round 2' }, // Game 9: Loser of 4/5 vs Winner of Game 8
                        { id: 'l2-2', team1: { loserFrom: 'w1-3' }, team2: { from: 'l1-1' }, round: 'Elimination Round 2' }  // Game 10: Loser of 3/6 vs Winner of Game 7
                    ],
                    round3: [
                        // Third elimination games - semifinal losers enter (crossed over)
                        { id: 'l3-1', team1: { from: 'l2-1' }, team2: { loserFrom: 'w2-2' }, round: 'Elimination Round 3' }, // Game 13: Winner of Game 9 vs Loser of Game 12
                        { id: 'l3-2', team1: { from: 'l2-2' }, team2: { loserFrom: 'w2-1' }, round: 'Elimination Round 3' }  // Game 14: Winner of Game 10 vs Loser of Game 11
                    ],
                    semifinals: [
                        { id: 'l4-1', team1: { from: 'l3-1' }, team2: { from: 'l3-2' }, round: 'Elimination Semifinals' } // Game 15: Winner of Game 13 vs Winner of Game 14
                    ],
                    finals: [
                        { id: 'l5-1', team1: { from: 'l4-1' }, team2: { loserFrom: 'w3-1' }, round: 'Losers Final' } // Game 16: Winner of Game 15 vs Loser of Winners Final
                    ]
                },
                championship: [
                    { id: 'champ', team1: { from: 'w3-1' }, team2: { from: 'l5-1' }, round: 'Championship' }
                ]
            };
        }

        function renderBracket() {
            const container = document.getElementById('bracketsContainer');
            
            // Update status banner
            const statusEl = document.getElementById('bracketStatus');
            if (isProjected) {
                statusEl.className = 'bracket-status projected';
                // Only show "Click Lock Bracket" message to admins/staff
                if (userCanManagePlayoffs) {
                    statusEl.innerHTML = 'üìä PROJECTED BRACKET - Based on current standings. Click "Lock Bracket" when ready to start playoffs.';
                } else {
                    statusEl.innerHTML = 'üìä PROJECTED BRACKET - Based on current standings.';
                }
            } else {
                statusEl.className = 'bracket-status locked';
                statusEl.innerHTML = 'üîí OFFICIAL PLAYOFF BRACKET - Locked on ' + (playoffData.lockedAt ? new Date(playoffData.lockedAt).toLocaleDateString() : 'N/A');
            }
            
            container.innerHTML = `
                ${renderWinnersBracket()}
                ${renderLosersBracket()}
                ${renderChampionship()}
            `;

            // Add click handlers if in edit mode
            if (editMode && !isProjected) {
                document.querySelectorAll('.matchup').forEach(matchup => {
                    matchup.style.cursor = 'pointer';
                    matchup.addEventListener('click', function(e) {
                        // Don't open edit modal if clicking the game link
                        if (e.target.closest('.game-link')) {
                            return;
                        }
                        const matchupId = this.dataset.matchupId;
                        openEditModal(matchupId);
                    });
                });
            }
        }

        function renderWinnersBracket() {
            const wb = playoffData.winnersBracket;
            
            // Reorder Round 1 matchups for proper bracket display
            // Top to bottom: 1 vs 8/9, 4 vs 5, 3 vs 6, 2 vs 7/10
            const round1Reordered = [
                wb.round1[0], // 1 vs 8/9 winner (top)
                wb.round1[3], // 4 vs 5 (middle-top)
                wb.round1[2], // 3 vs 6 (middle-bottom)
                wb.round1[1]  // 2 vs 7/10 winner (bottom)
            ];
            
            return `
                <div class="bracket-section winners-bracket">
                    <div class="bracket-title">üèÜ Winners Bracket</div>
                    <div class="bracket-grid">
                        ${renderRoundWithClass(wb.playIn, 'Play-In Games', 'play-in')}
                        ${renderRoundCustom(round1Reordered, 'Round 1', 'round-1')}
                        ${renderRoundWithClass(wb.semifinals, 'Semifinals', 'semifinals')}
                        ${renderRoundWithClass(wb.finals, 'Winners Final', 'finals')}
                    </div>
                </div>
            `;
        }

        function renderLosersBracket() {
            const lb = playoffData.losersBracket;
            return `
                <div class="bracket-section">
                    <div class="bracket-title">Ô∏è‚ö†Ô∏è Elimination Bracket</div>
                    <div class="bracket-grid">
                        ${renderRound(lb.round1, 'Elimination Round 1')}
                        ${renderRound(lb.round2, 'Elimination Round 2')}
                        ${renderRound(lb.round3, 'Elimination Round 3')}
                        ${renderRound(lb.semifinals, 'Elimination Semifinals')}
                        ${renderRound(lb.finals, 'Losers Final')}
                    </div>
                </div>
            `;
        }

        function renderChampionship() {
            return `
                <div class="bracket-section">
                    <div class="bracket-title">üèÜChampionship</div>
                    <div class="bracket-grid" style="justify-content: center;">
                        ${renderRound(playoffData.championship, 'Championship')}
                    </div>
                </div>
            `;
        }

        function renderRound(matchups, title) {
            return `
                <div class="round">
                    <div class="round-title">${title}</div>
                    ${matchups.map(m => renderMatchup(m)).join('')}
                </div>
            `;
        }

        function renderRoundWithClass(matchups, title, cssClass) {
            return `
                <div class="round ${cssClass}">
                    <div class="round-title">${title}</div>
                    ${matchups.map(m => renderMatchup(m)).join('')}
                </div>
            `;
        }

        function renderRoundCustom(matchups, title, cssClass) {
            const positions = ['position-top', 'position-middle-top', 'position-middle-bottom', 'position-bottom'];
            return `
                <div class="round ${cssClass}">
                    <div class="round-title">${title}</div>
                    ${matchups.map((m, idx) => renderMatchup(m, positions[idx])).join('')}
                </div>
            `;
        }

        function renderMatchup(matchup, positionClass = '') {
            const isChampionship = matchup.id === 'champ';
            const team1 = getTeamDisplay(matchup.team1, matchup);
            const team2 = getTeamDisplay(matchup.team2, matchup);
            
            const winner = matchup.winner;
            const team1Class = winner === 1 ? 'winner' : (winner === 2 ? 'loser' : '');
            const team2Class = winner === 2 ? 'winner' : (winner === 1 ? 'loser' : '');

            // Check if we can link to game preview (need both team names and a date)
            const canLinkToPreview = team1.name !== 'TBD' && team2.name !== 'TBD' && matchup.gameDate;
            const previewLink = canLinkToPreview 
                ? `game-preview.html?home=${encodeURIComponent(team1.name)}&away=${encodeURIComponent(team2.name)}&date=${matchup.gameDate}`
                : null;

            return `
                <div class="matchup ${isChampionship ? 'championship' : ''} ${positionClass}" 
                     data-matchup-id="${matchup.id}">
                    ${matchup.gameDate ? `<div class="matchup-date">${formatDate(matchup.gameDate)}</div>` : ''}
                    ${matchup.gameTime ? `<div class="matchup-time">${matchup.gameTime}</div>` : ''}
                    ${canLinkToPreview ? `
                        <a href="${previewLink}" class="game-link" title="View Game Preview">
                            <div class="game-link-icon">üìä</div>
                        </a>
                    ` : ''}
                    <div class="team ${team1Class}">
                        <span class="seed">${team1.seed || ''}</span>
                        <span class="team-name">${team1.name} ${isProjected && team1.record ? `<span style="opacity: 0.7; font-size: 0.85em;">${team1.record}</span>` : ''}</span>
                        <span class="score ${matchup.team1Score === undefined ? 'tbd' : ''}">
                            ${matchup.team1Score !== undefined ? matchup.team1Score : '-'}
                        </span>
                    </div>
                    <div class="team ${team2Class}">
                        <span class="seed">${team2.seed || ''}</span>
                        <span class="team-name">${team2.name} ${isProjected && team2.record ? `<span style="opacity: 0.7; font-size: 0.85em;">${team2.record}</span>` : ''}</span>
                        <span class="score ${matchup.team2Score === undefined ? 'tbd' : ''}">
                            ${matchup.team2Score !== undefined ? matchup.team2Score : '-'}
                        </span>
                    </div>
                </div>
            `;
        }

        // Helper function to get team by seed - uses lockedSeeds when bracket is locked
        function getTeamBySeed(seed) {
            // When bracket is locked, ALWAYS use lockedSeeds (frozen at lock time)
            if (!isProjected && playoffData && playoffData.lockedSeeds) {
                const lockedTeam = playoffData.lockedSeeds.find(t => t.seed === seed);
                if (lockedTeam) {
                    return {
                        seed: lockedTeam.seed,
                        name: lockedTeam.teamName,
                        teamId: lockedTeam.teamId,
                        record: lockedTeam.record ? `(${lockedTeam.record})` : ''
                    };
                }
            }
            // Fallback to dynamically calculated teams (for projected brackets)
            const team = teams.find(t => t.seed === seed);
            if (team) {
                return {
                    seed: team.seed,
                    name: team.name || team.teamName,
                    teamId: team.id,
                    record: (team.wins !== undefined) ? `(${team.wins}-${team.losses})` : ''
                };
            }
            return null;
        }

        function getTeamDisplay(teamData, matchup = null) {
            if (!teamData) return { name: 'TBD', seed: '', record: '' };
            
            // Special handling for championship game
            if (matchup && matchup.id === 'champ') {
                if (teamData.from === 'w3-1') {
                    return { name: 'Winners Bracket Winner', seed: '', record: '' };
                }
                if (teamData.from === 'l5-1') {
                    return { name: 'Losers Bracket Winner', seed: '', record: '' };
                }
            }
            
            if (teamData.seed) {
                const team = getTeamBySeed(teamData.seed);
                return {
                    seed: teamData.seed,
                    name: team ? team.name : `Seed ${teamData.seed}`,
                    teamId: team?.teamId,
                    record: team ? team.record : ''
                };
            }
            
            if (teamData.from) {
                // This team comes from winning a previous game
                const sourceGame = findMatchup(teamData.from);
                if (sourceGame && sourceGame.winner) {
                    // Game has been decided - show the actual winner
                    const winningTeam = sourceGame.winner === 1 ? sourceGame.team1 : sourceGame.team2;
                    return getTeamDisplay(winningTeam); // Recursively resolve the team
                }
                if (sourceGame) {
                    const team1Display = getSourceTeamName(sourceGame.team1);
                    const team2Display = getSourceTeamName(sourceGame.team2);
                    return {
                        name: `Winner of ${team1Display} vs ${team2Display}`,
                        seed: '',
                        record: ''
                    };
                }
                return {
                    name: `Winner of ${teamData.from}`,
                    seed: '',
                    record: ''
                };
            }
            
            if (teamData.loserFrom) {
                // This team comes from losing a previous game
                const sourceGame = findMatchup(teamData.loserFrom);
                if (sourceGame && sourceGame.winner) {
                    // Game has been decided - show the actual loser
                    const losingTeam = sourceGame.winner === 1 ? sourceGame.team2 : sourceGame.team1;
                    return getTeamDisplay(losingTeam); // Recursively resolve the team
                }
                if (sourceGame) {
                    const team1Display = getSourceTeamName(sourceGame.team1);
                    const team2Display = getSourceTeamName(sourceGame.team2);
                    return {
                        name: `Loser of ${team1Display} vs ${team2Display}`,
                        seed: '',
                        record: ''
                    };
                }
                return {
                    name: `Loser of ${teamData.loserFrom}`,
                    seed: '',
                    record: ''
                };
            }
            
            return { name: 'TBD', seed: '', record: '' };
        }

        function getSourceTeamName(teamData) {
            // Helper function to get a concise team identifier for display in "Winner of X vs Y"
            if (!teamData) return 'TBD';
            
            if (teamData.seed) {
                // Use the helper function that respects lockedSeeds
                const team = getTeamBySeed(teamData.seed);
                if (team) {
                    return team.name || `Seed ${teamData.seed}`;
                }
                return `Seed ${teamData.seed}`;
            }
            
            if (teamData.from) {
                // Check if source game has a winner - if so, return that team's name
                const sourceGame = findMatchup(teamData.from);
                if (sourceGame && sourceGame.winner) {
                    const winningTeam = sourceGame.winner === 1 ? sourceGame.team1 : sourceGame.team2;
                    return getSourceTeamName(winningTeam); // Recursively resolve the actual team
                }
                
                // Game not decided yet - build descriptive text
                if (sourceGame) {
                    const t1 = getSourceTeamName(sourceGame.team1);
                    const t2 = getSourceTeamName(sourceGame.team2);
                    return `${t1}/${t2} Winner`;
                }
                return `Winner ${teamData.from}`;
            }
            
            if (teamData.loserFrom) {
                // Check if source game has a winner - if so, return the loser's name
                const sourceGame = findMatchup(teamData.loserFrom);
                if (sourceGame && sourceGame.winner) {
                    const losingTeam = sourceGame.winner === 1 ? sourceGame.team2 : sourceGame.team1;
                    return getSourceTeamName(losingTeam); // Recursively resolve the actual team
                }
                
                // Game not decided yet - build descriptive text
                if (sourceGame) {
                    const t1 = getSourceTeamName(sourceGame.team1);
                    const t2 = getSourceTeamName(sourceGame.team2);
                    return `${t1}/${t2} Loser`;
                }
                return `Loser ${teamData.loserFrom}`;
            }
            
            return 'TBD';
        }

        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            // Date input returns YYYY-MM-DD format
            // Parse it as local date to avoid UTC conversion
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day); // month is 0-indexed
            
            return date.toLocaleDateString('en-US', { 
                weekday: 'short', 
                month: 'short', 
                day: 'numeric',
                timeZone: 'America/New_York' // Force Eastern Time
            });
        }

        function findMatchup(matchupId) {
            // Search all brackets for the matchup
            const allMatchups = [
                ...playoffData.winnersBracket.playIn,
                ...playoffData.winnersBracket.round1,
                ...playoffData.winnersBracket.semifinals,
                ...playoffData.winnersBracket.finals,
                ...playoffData.losersBracket.round1,
                ...playoffData.losersBracket.round2,
                ...playoffData.losersBracket.round3,
                ...playoffData.losersBracket.semifinals,
                ...playoffData.losersBracket.finals,
                ...playoffData.championship
            ];
            
            return allMatchups.find(m => m.id === matchupId);
        }

        window.toggleEditMode = function() {
            if (!userCanManagePlayoffs) {
                alert('Only League Staff and Admins can edit playoff brackets.');
                return;
            }
            
            if (isProjected) {
                alert('Cannot edit projected bracket. Please lock the bracket first to set official playoff matchups.');
                return;
            }
            
            editMode = !editMode;
            document.getElementById('editModeText').textContent = 
                editMode ? 'Disable Edit Mode' : 'Enable Edit Mode';
            renderBracket();
        };

        window.openEditModal = function(matchupId) {
            if (!editMode) return;
            
            currentEditMatchup = findMatchup(matchupId);
            if (!currentEditMatchup) return;

            document.getElementById('gameDate').value = currentEditMatchup.gameDate || '';
            document.getElementById('gameTime').value = currentEditMatchup.gameTime || '';
            document.getElementById('team1Score').value = currentEditMatchup.team1Score !== undefined ? currentEditMatchup.team1Score : '';
            document.getElementById('team2Score').value = currentEditMatchup.team2Score !== undefined ? currentEditMatchup.team2Score : '';

            document.getElementById('editModal').classList.add('active');
        };

        window.closeModal = function() {
            document.getElementById('editModal').classList.remove('active');
            currentEditMatchup = null;
        };

        window.saveMatchup = async function() {
            if (!currentEditMatchup) return;

            const gameDate = document.getElementById('gameDate').value;
            const gameTime = document.getElementById('gameTime').value;
            const team1Score = document.getElementById('team1Score').value;
            const team2Score = document.getElementById('team2Score').value;

            // Update the matchup
            currentEditMatchup.gameDate = gameDate || null;
            currentEditMatchup.gameTime = gameTime || null;
            currentEditMatchup.team1Score = team1Score !== '' ? parseInt(team1Score) : undefined;
            currentEditMatchup.team2Score = team2Score !== '' ? parseInt(team2Score) : undefined;

            // Determine winner if both scores are entered
            if (team1Score !== '' && team2Score !== '') {
                currentEditMatchup.winner = parseInt(team1Score) > parseInt(team2Score) ? 1 : 2;
            } else {
                currentEditMatchup.winner = null;
            }

            // Save to Firebase
            try {
                const playoffRef = doc(db, 'seasons', currentSeason.id, 'playoffs', 'bracket');
                await updateDoc(playoffRef, playoffData);
                
                // If a winner was determined, create dependent games
                if (currentEditMatchup.winner) {
                    await createDependentGames(currentEditMatchup.id);
                }
                
                closeModal();
                renderBracket();
            } catch (error) {
                console.error('Error saving matchup:', error);
                alert('Error saving matchup. Please try again.');
            }
        };

        async function createDependentGames(completedMatchupId) {
            console.log(`üéÆ Checking for dependent games after ${completedMatchupId} completion...`);
            
            const gamesCollection = collection(db, 'seasons', currentSeason.id, 'games');
            
            // Map matchup IDs to the games they unlock
            const dependencyMap = {
                // Play-in games unlock Round 1 games (already created but need team updates)
                'pi-1': ['playoff_r1g1_seed1_vs_winner_pi1'],
                'pi-2': ['playoff_r1g2_seed2_vs_winner_pi2'],
                
                // Round 1 games unlock Winners Semifinals and Losers Round 1
                'w1-1': ['playoff_w2g1_semifinal', 'playoff_l1g2_elimination'],
                'w1-2': ['playoff_w2g2_semifinal', 'playoff_l1g1_elimination'],
                'w1-3': ['playoff_w2g2_semifinal', 'playoff_l2g2_elimination'],
                'w1-4': ['playoff_w2g1_semifinal', 'playoff_l2g1_elimination'],
                
                // Losers Round 1 games unlock Losers Round 2
                'l1-1': ['playoff_l2g2_elimination'],
                'l1-2': ['playoff_l2g1_elimination'],
                
                // Winners Semifinals unlock Winners Finals and Losers Round 3
                'w2-1': ['playoff_w3g1_winners_final', 'playoff_l3g2_elimination'],
                'w2-2': ['playoff_w3g1_winners_final', 'playoff_l3g1_elimination'],
                
                // Losers Round 2 unlocks Losers Round 3
                'l2-1': ['playoff_l3g1_elimination'],
                'l2-2': ['playoff_l3g2_elimination'],
                
                // Losers Round 3 unlocks Losers Semifinals
                'l3-1': ['playoff_l4g1_losers_semi'],
                'l3-2': ['playoff_l4g1_losers_semi'],
                
                // Losers Semifinals unlocks Losers Finals
                'l4-1': ['playoff_l5g1_losers_final'],
                
                // Winners Finals unlocks Championship and Losers Finals
                'w3-1': ['playoff_championship', 'playoff_l5g1_losers_final'],
                
                // Losers Finals unlocks Championship
                'l5-1': ['playoff_championship'],
                
                // Championship might unlock If Necessary game
                'champ': ['playoff_if_necessary']
            };

            const gamesToCreate = dependencyMap[completedMatchupId] || [];
            
            for (const gameId of gamesToCreate) {
                try {
                    // Check if game already exists
                    const gameRef = doc(gamesCollection, gameId);
                    const gameDoc = await getDoc(gameRef);
                    
                    if (gameDoc.exists()) {
                        console.log(`‚úÖ Game ${gameId} already exists, updating teams if needed`);
                        await updateGameTeams(gameId, completedMatchupId);
                    } else {
                        console.log(`üìù Creating new game: ${gameId}`);
                        await createNewGame(gameId, completedMatchupId);
                    }
                } catch (error) {
                    console.error(`Error processing game ${gameId}:`, error);
                }
            }
        }

        async function updateGameTeams(gameId, sourceMatchupId) {
            // Update existing game with actual team names after play-in or other games complete
            const gamesCollection = collection(db, 'seasons', currentSeason.id, 'games');
            const gameRef = doc(gamesCollection, gameId);
            const sourceMatchup = findMatchup(sourceMatchupId);
            
            if (!sourceMatchup || !sourceMatchup.winner) return;
            
            const winningTeam = sourceMatchup.winner === 1 ? sourceMatchup.team1 : sourceMatchup.team2;
            const losingTeam = sourceMatchup.winner === 1 ? sourceMatchup.team2 : sourceMatchup.team1;
            
            const winnerDisplay = getTeamDisplay(winningTeam);
            const loserDisplay = getTeamDisplay(losingTeam);
            
            // Update the appropriate team field based on game structure
            const updates = {};
            
            // For play-in winners updating Round 1 games
            if (gameId.includes('winner_pi1') && winnerDisplay.name) {
                updates['away team'] = winnerDisplay.name;
            } else if (gameId.includes('winner_pi2') && winnerDisplay.name) {
                updates['away team'] = winnerDisplay.name;
            }
            
            if (Object.keys(updates).length > 0) {
                await updateDoc(gameRef, updates);
                console.log(`‚úÖ Updated teams in ${gameId}`);
            }
        }

        async function createNewGame(gameId, sourceMatchupId) {
            const gamesCollection = collection(db, 'seasons', currentSeason.id, 'games');
            
            // Determine game details based on gameId
            const gameData = buildGameData(gameId);
            
            if (gameData) {
                await setDoc(doc(gamesCollection, gameId), gameData);
                console.log(`‚úÖ Created game: ${gameId}`);
            }
        }

        function buildGameData(gameId) {
            // Build game data structure based on game ID
            const gameMap = {
                'playoff_w2g1_semifinal': {
                    round: 'Winners Semifinals',
                    description: 'Game 11: Winner R1G1 vs Winner R1G4',
                    team1Source: 'w1-1',
                    team2Source: 'w1-4'
                },
                'playoff_w2g2_semifinal': {
                    round: 'Winners Semifinals',
                    description: 'Game 12: Winner R1G2 vs Winner R1G3',
                    team1Source: 'w1-2',
                    team2Source: 'w1-3'
                },
                'playoff_l1g1_elimination': {
                    round: 'Losers Round 1',
                    description: 'Game 7: Loser R1G2 vs Loser PI1',
                    team1Source: 'w1-2',
                    team2Source: 'pi-1',
                    useLoser: true
                },
                'playoff_l1g2_elimination': {
                    round: 'Losers Round 1',
                    description: 'Game 8: Loser R1G1 vs Loser PI2',
                    team1Source: 'w1-1',
                    team2Source: 'pi-2',
                    useLoser: true
                },
                'playoff_l2g1_elimination': {
                    round: 'Losers Round 2',
                    description: 'Game 9: Loser R1G4 vs Winner L1G2',
                    team1Source: 'w1-4',
                    team2Source: 'l1-2',
                    team1Loser: true
                },
                'playoff_l2g2_elimination': {
                    round: 'Losers Round 2',
                    description: 'Game 10: Loser R1G3 vs Winner L1G1',
                    team1Source: 'w1-3',
                    team2Source: 'l1-1',
                    team1Loser: true
                },
                'playoff_w3g1_winners_final': {
                    round: 'Winners Finals',
                    description: 'Game 15: Winner W2G1 vs Winner W2G2',
                    team1Source: 'w2-1',
                    team2Source: 'w2-2'
                },
                'playoff_l3g1_elimination': {
                    round: 'Losers Round 3',
                    description: 'Game 13: Winner L2G1 vs Loser W2G2',
                    team1Source: 'l2-1',
                    team2Source: 'w2-2',
                    team2Loser: true
                },
                'playoff_l3g2_elimination': {
                    round: 'Losers Round 3',
                    description: 'Game 14: Winner L2G2 vs Loser W2G1',
                    team1Source: 'l2-2',
                    team2Source: 'w2-1',
                    team2Loser: true
                },
                'playoff_l4g1_losers_semi': {
                    round: 'Losers Semifinals',
                    description: 'Game 16: Winner L3G1 vs Winner L3G2',
                    team1Source: 'l3-1',
                    team2Source: 'l3-2'
                },
                'playoff_l5g1_losers_final': {
                    round: 'Losers Finals',
                    description: 'Game 17: Winner L4G1 vs Loser W3G1',
                    team1Source: 'l4-1',
                    team2Source: 'w3-1',
                    team2Loser: true
                },
                'playoff_championship': {
                    round: 'Championship',
                    description: 'Game 18: Winner W3G1 vs Winner L5G1',
                    team1Source: 'w3-1',
                    team2Source: 'l5-1'
                },
                'playoff_if_necessary': {
                    round: 'Championship (If Necessary)',
                    description: 'Game 19: Rematch if needed',
                    team1Source: 'champ',
                    team2Source: 'champ',
                    isRematch: true
                }
            };

            const gameConfig = gameMap[gameId];
            if (!gameConfig) return null;

            // Get team names from source matchups
            const team1Matchup = findMatchup(gameConfig.team1Source);
            const team2Matchup = findMatchup(gameConfig.team2Source);

            let team1Name = 'TBD';
            let team2Name = 'TBD';

            if (team1Matchup && team1Matchup.winner) {
                const team = (gameConfig.team1Loser || gameConfig.useLoser) ? 
                    (team1Matchup.winner === 1 ? team1Matchup.team2 : team1Matchup.team1) :
                    (team1Matchup.winner === 1 ? team1Matchup.team1 : team1Matchup.team2);
                const teamDisplay = getTeamDisplay(team);
                team1Name = teamDisplay.name;
            }

            if (team2Matchup && team2Matchup.winner) {
                const team = (gameConfig.team2Loser || gameConfig.useLoser) ? 
                    (team2Matchup.winner === 1 ? team2Matchup.team2 : team2Matchup.team1) :
                    (team2Matchup.winner === 1 ? team2Matchup.team1 : team2Matchup.team2);
                const teamDisplay = getTeamDisplay(team);
                team2Name = teamDisplay.name;
            }

            return {
                id: gameId,
                'home team': team1Name,
                'away team': team2Name,
                game_type: 'Playoff',
                round: gameConfig.round,
                description: gameConfig.description,
                date: '',
                time: '',
                'home score': '',
                'away score': '',
                winner: ''
            };
        }

        // Initialize - auth state change handler will call loadPlayoffBracket()
    </script>
</body>
</html>

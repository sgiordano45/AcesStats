<!DOCTYPE html>
<html lang="en">
<head>
<link rel="manifest" href="/manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Tracker - Mountainside Aces</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
	
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .drag-cursor {
            cursor: move;
        }
        .pointer-cursor {
            cursor: pointer;
        }
        svg text {
            user-select: none;
        }
/* Connection Status Indicator */
.connection-status {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #ffc107;
  color: #856404;
  padding: 10px 16px;
  border-radius: 25px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  z-index: 9999;
  font-size: 0.85rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.3s ease;
}

.connection-status.hidden {
  display: none;
}

.connection-status.online {
  background: #28a745;
  color: white;
}

.connection-status .status-icon {
  font-size: 1rem;
}

/* Notification slide-in animation */
@keyframes slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.animate-slide-in {
  animation: slide-in 0.3s ease-out;
}
    </style>
</head>
<body>
<div id="connectionStatus" class="connection-status hidden">
  <span class="status-icon">ðŸ“¡</span>
  <span class="status-text">You're offline</span>
</div>
    <div id="root"></div>

    <!-- Firebase Integration Module -->
    <script type="module">
        import { getCurrentUser, onAuthChange, getUserProfile } from './firebase-auth.js';
        import { getCurrentSeason, getAllTeams, getSeasonPlayerStatsOptimized } from './firebase-data.js';
        import { getUpcomingTeamGames, getBattingOrder } from './firebase-roster.js';
        import { doc, setDoc, getDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { db } from './firebase-data.js';
		
		import { 
    subscribeToGameState,
    subscribeToGameMetadata,
    updateGameMetadata,
    updateGameState,
    updatePresence,
    removePresence,
    canUserTrackTeam,
    getGameTrackingPermissions,
    subscribeToPresence,
    loadGameState as loadGameStateSync,
    clearGameState as clearGameStateSync
} from './firebase-game-sync.js';




        // Save game state to Firebase
async function saveGameState(gameId, teamId, teamName, gameState, battingOrder, currentUserInfo, seasonId = null, gameObj = null) {
    const { userId, userName } = currentUserInfo;
    
    if (!seasonId) {
        console.error('âŒ Cannot save game state: seasonId is required');
        return;
    }
    
    // OFFLINE CHECK
    if (!navigator.onLine) {
        console.log('ðŸ“¡ Offline - queuing game state update');
        
        try {
            await window.offlineQueue.addToQueue('SCORE_UPDATE', {
                gameId: gameId,
                teamId: teamId,
                teamName: teamName,
                score: gameState.score.yourTeam,
                inning: gameState.inning,
                outs: gameState.outs,
                bases: gameState.bases,
                playHistory: gameState.playHistory,
                battingOrder: battingOrder.map(p => p.id),
                timestamp: Date.now()
            });
            console.log('âœ… Game state queued');
        } catch (error) {
            console.error('Failed to queue game state:', error);
        }
        return; // Exit early - don't try Firebase
    }
    
    // ONLINE - Save with new structure
    try {
        // Save team game state
        await updateGameState(seasonId, gameId, teamId, {
            teamId,
            teamName,
            atBats: gameState.atBats || [],
            plays: gameState.playHistory || [],
            battingOrder: battingOrder.map(p => p.id),
            currentBatter: gameState.currentBatter ?? 0,
            inning: gameState.inning,
            outs: gameState.outs,
            bases: gameState.bases,
            score: gameState.score.yourTeam,
            isYourTeamBatting: gameState.isYourTeamBatting,
            gameActive: gameState.gameActive,
            metadata: {
                lastUpdatedBy: userId,
                lastUpdatedByName: userName
            }
        });
        
        // Also update shared game metadata with current scores/inning/outs
        // This keeps the metadata in sync for both teams
        try {
            // Determine home and away scores based on which team this is
            const isHome = gameObj ? (gameObj.homeTeam?.toLowerCase() === teamName.toLowerCase()) : false;
            await updateGameMetadata(seasonId, gameId, {
                inning: gameState.inning,
                outs: gameState.outs,
                currentBattingTeam: gameState.isYourTeamBatting ? teamId : null
            });
        } catch (metadataError) {
            console.warn('Could not update game metadata:', metadataError);
        }
        
        console.log('ðŸ’¾ Game state saved');
    } catch (error) {
        console.error('Error saving game state:', error);
    }
}

// Helper function for ordinal suffixes
function getOrdinalSuffix(num) {
    const j = num % 10;
    const k = num % 100;
    if (j === 1 && k !== 11) return "st";
    if (j === 2 && k !== 12) return "nd";
    if (j === 3 && k !== 13) return "rd";
    return "th";
}


        // Wrapper for loadGameState that requires seasonId
        async function loadGameState(gameId, teamId, seasonId) {
            if (!seasonId) {
                console.error('âŒ loadGameState requires seasonId');
                return null;
            }
            
            try {
                return await loadGameStateSync(seasonId, gameId, teamId);
            } catch (error) {
                console.error('Error loading game state:', error);
                return null;
            }
        }



        // Wrapper for clearGameState that requires seasonId
        async function clearGameState(gameId, teamId, seasonId) {
            if (!seasonId) {
                console.error('âŒ clearGameState requires seasonId');
                return;
            }
            
            try {
                await clearGameStateSync(seasonId, gameId, teamId);
                console.log('ðŸ—‘ï¸ Game state cleared');
            } catch (error) {
                console.error('Error clearing game state:', error);
            }
        }


        // Calculate batting stats from play history
        function calculateBattingStats(playHistory, battingOrder) {
            const playerStats = {};
            
            // Initialize stats for all players in the batting order
            battingOrder.forEach(player => {
                playerStats[player.id] = {
                    playerId: player.id,
                    playerName: player.name,
                    atBats: 0,
                    hits: 0,
                    singles: 0,
                    doubles: 0,
                    triples: 0,
                    homeRuns: 0,
                    walks: 0,
                    strikeouts: 0,
                    rbi: 0,
                    runs: 0,
                    battingAverage: 0,
                    onBasePercentage: 0,
                    sluggingPercentage: 0
                };
            });
            
            // Process each play
            playHistory.forEach(play => {
                const playerId = battingOrder.find(p => p.name === play.batter)?.id;
                if (!playerId || !playerStats[playerId]) return;
                
                const stats = playerStats[playerId];
                
                // Count at-bats (everything except walks and sac flies)
                if (play.playType !== 'walk' && play.playType !== 'sacfly') {
                    stats.atBats++;
                }
                
                // Count hits
                if (play.playType === 'single') {
                    stats.hits++;
                    stats.singles++;
                } else if (play.playType === 'double') {
                    stats.hits++;
                    stats.doubles++;
                } else if (play.playType === 'triple') {
                    stats.hits++;
                    stats.triples++;
                } else if (play.playType === 'homerun') {
                    stats.hits++;
                    stats.homeRuns++;
                } else if (play.playType === 'walk') {
                    stats.walks++;
                } else if (play.playType === 'strikeout') {
                    stats.strikeouts++;
                }
                
                // Count RBIs (runs scored on this play)
                if (play.runsScored > 0) {
                    stats.rbi += play.runsScored;
                }
            });
            
            // Calculate derived stats
            Object.values(playerStats).forEach(stats => {
                // Batting Average
                if (stats.atBats > 0) {
                    stats.battingAverage = stats.hits / stats.atBats;
                }
                
                // On-Base Percentage
                const plateAppearances = stats.atBats + stats.walks;
                if (plateAppearances > 0) {
                    stats.onBasePercentage = (stats.hits + stats.walks) / plateAppearances;
                }
                
                // Slugging Percentage
                if (stats.atBats > 0) {
                    const totalBases = stats.singles + (stats.doubles * 2) + (stats.triples * 3) + (stats.homeRuns * 4);
                    stats.sluggingPercentage = totalBases / stats.atBats;
                }
            });
            
            return Object.values(playerStats);
        }

        // Save game results to Firebase
        async function saveGameResults(gameId, teamId, seasonId, gameState, battingOrder, isHome, opponentName) {
            try {
                // Calculate batting stats
                const battingStats = calculateBattingStats(gameState.playHistory, battingOrder);
                
                // Save to gameResults collection
                const resultsRef = doc(db, 'gameResults', `${gameId}_${teamId}`);
                await setDoc(resultsRef, {
                    gameId,
                    teamId,
                    seasonId,
                    opponentName,
                    isHome,
                    finalScore: {
                        yourTeam: gameState.score.yourTeam,
                        opponent: gameState.score.opponent
                    },
                    innings: gameState.inning,
                    battingStats,
                    playByPlay: gameState.playHistory,
                    completedAt: serverTimestamp()
                });
                
                console.log('âœ… Game results saved with batting stats');
                return { success: true, battingStats };
            } catch (error) {
                console.error('Error saving game results:', error);
                return { success: false, error };
            }
        }

        // Make functions available globally for React component
        window.FirebaseGameTracker = {
            getCurrentUser,
            onAuthChange,
            getUserProfile,
            getCurrentSeason,
            getAllTeams,
            getSeasonPlayerStatsOptimized,
            getUpcomingTeamGames,
            getBattingOrder,
            saveGameState: (gameId, teamId, teamName, gameState, battingOrder, userInfo, seasonId, gameObj) => 
                saveGameState(gameId, teamId, teamName, gameState, battingOrder, userInfo, seasonId, gameObj),
            loadGameState,
            clearGameState,
            saveGameResults,
            // Add firebase-game-sync functions
            subscribeToGameState,
            subscribeToGameMetadata,
            updateGameMetadata,
            updateGameState,
            updatePresence,
            removePresence,
            canUserTrackTeam,
            getGameTrackingPermissions,
            subscribeToPresence,
            loadGameStateSync,
            clearGameStateSync
        };

        // Wait for auth state to be determined before signaling ready
        let authResolved = false;
        let currentAuthUser = null;
        
        onAuthChange((user) => {
            currentAuthUser = user;
            if (!authResolved) {
                authResolved = true;
                console.log('ðŸ” Auth state resolved:', user ? user.displayName : 'Not signed in');
                window.firebaseReady = true;
                window.dispatchEvent(new Event('firebaseready'));
            }
        });
        
        // Store the current user for immediate access
        window.getCurrentFirebaseUser = () => currentAuthUser;
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Lucide React icons as inline SVG components
        const Undo2 = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M9 14 4 9l5-5"/>
                <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/>
            </svg>
        );

        const Save = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
            </svg>
        );

        const PlayCircle = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <polygon points="10 8 16 12 10 16 10 8"/>
            </svg>
        );

        const AlertCircle = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
        );

        const PLAY_TYPES = [
            { label: '1B', value: 'single', bases: 1, isHit: true },
            { label: '2B', value: 'double', bases: 2, isHit: true },
            { label: '3B', value: 'triple', bases: 3, isHit: true },
            { label: 'HR', value: 'homerun', bases: 4, isHit: true },
            { label: 'BB', value: 'walk', bases: 1, isHit: false },
            { label: 'K', value: 'strikeout', bases: 0, isOut: true, noAdjust: true },
            { label: 'GO', value: 'groundout', bases: 0, isOut: true },
            { label: 'FO', value: 'flyout', bases: 0, isOut: true },
            { label: 'SF', value: 'sacfly', bases: 0, isOut: true },
            { label: 'FC', value: 'fielders_choice', bases: 0, isOut: false },
            { label: 'DP', value: 'doubleplay', bases: 0, outs: 2 },
        ];

        function GameTracker() {
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [currentUser, setCurrentUser] = useState(null);
            const [currentSeason, setCurrentSeason] = useState(null);
            const [allTeams, setAllTeams] = useState([]);
            const [games, setGames] = useState([]);
            const [players, setPlayers] = useState([]);
            
            const [setupMode, setSetupMode] = useState(true);
            const [selectedTeam, setSelectedTeam] = useState('');
            const [selectedGame, setSelectedGame] = useState(null);
            const [isHome, setIsHome] = useState(false);
            const [lineupExists, setLineupExists] = useState(false);
            
            const [gameState, setGameState] = useState({
                inning: 1,
                outs: 0,
                bases: { first: null, second: null, third: null },
                score: { yourTeam: 0, opponent: 0 },
                currentBatter: 0,
                playHistory: [],
                gameActive: false,  // Start as false until game is initialized
                isYourTeamBatting: false  // Will be set correctly when game starts based on home/away
            });

            const [battingOrder, setBattingOrder] = useState([]);
            const [pendingPlay, setPendingPlay] = useState(null);
            const [tempBases, setTempBases] = useState(null);
            const [tempScore, setTempScore] = useState(0);
            const [tempOuts, setTempOuts] = useState(0);
            const [draggedRunner, setDraggedRunner] = useState(null);


			const [opponentTeamId, setOpponentTeamId] = useState(null);
			const [opponentTeamName, setOpponentTeamName] = useState('');
			const [opponentGameState, setOpponentGameState] = useState(null);
			const [gameMetadata, setGameMetadata] = useState(null);
			const [userCanTrack, setUserCanTrack] = useState(false);
			const [presenceUsers, setPresenceUsers] = useState([]);
			const [notifications, setNotifications] = useState([]);
			const [editingLineup, setEditingLineup] = useState(false);
			
			// Track whether the last state update came from Firebase to prevent save loops
			const isUpdatingFromFirebase = useRef(false);

            // Helper function to add notifications
            const addNotification = (notification) => {
                setNotifications(prev => [...prev, notification]);
                // Auto-dismiss after 5 seconds
                setTimeout(() => {
                    setNotifications(prev => prev.filter(n => n.id !== notification.id));
                }, 5000);
            };

            // Wait for Firebase to be ready, then load data
            useEffect(() => {
                const initializeApp = async () => {
                    if (window.firebaseReady) {
                        await loadInitialData();
                    } else {
                        window.addEventListener('firebaseready', loadInitialData);
                        return () => window.removeEventListener('firebaseready', loadInitialData);
                    }
                };
                initializeApp();
            }, []);

            // Load team-specific data when team changes
            useEffect(() => {
                if (selectedTeam && currentSeason) {
                    loadTeamData();
                }
            }, [selectedTeam, currentSeason]);

// Warn before leaving page with active game in progress
useEffect(() => {
    const handleBeforeUnload = (e) => {
        // Only warn if game is active and has plays recorded
        if (gameState.gameActive && gameState.playHistory.length > 0 && !setupMode) {
            e.preventDefault();
            // Modern browsers require returnValue to be set
            e.returnValue = '';
            return '';
        }
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [gameState.gameActive, gameState.playHistory.length, setupMode]);

// Auto-save game state whenever it changes
useEffect(() => {
    // Don't auto-save if this update came from Firebase
    if (isUpdatingFromFirebase.current) {
        isUpdatingFromFirebase.current = false; // Reset flag
        return;
    }
    
    if (!setupMode && selectedGame && selectedTeam && gameState.gameActive && currentUser) {
        const saveTimer = setTimeout(() => {
            window.FirebaseGameTracker.saveGameState(
                selectedGame.id,
                selectedTeam,
                selectedTeam, // team name
                gameState,
                battingOrder,
                {
                    userId: currentUser.uid,
                    userName: currentUser.displayName || currentUser.email
                },
                selectedGame.seasonId, // Pass the correct seasonId from the game object
                selectedGame // Pass the game object for home/away determination
            );
        }, 1000);
        
        return () => clearTimeout(saveTimer);
    }
}, [gameState, setupMode, selectedGame, selectedTeam, battingOrder, currentUser]);

useEffect(() => {
    let unsubscribeYourTeam = null;
    let unsubscribeOpponent = null;
    let unsubscribeMetadata = null;
    let unsubscribePresence = null;
    
    async function initializeGameSync() {
        // Only set up sync when game is selected and not in setup mode
        if (!selectedGame || setupMode || !selectedTeam || !currentUser) {
            return;
        }
        
        console.log('ðŸ”„ Initializing real-time game sync');
        
        try {
            // Get user profile to check permissions
            const profileResult = await window.FirebaseGameTracker.getUserProfile(currentUser.uid);
            const userProfile = profileResult.success ? profileResult.data : null;
            
            // Check if user can track this team
            const canTrack = window.FirebaseGameTracker.canUserTrackTeam(userProfile, selectedTeam);
            setUserCanTrack(canTrack);
            console.log('ðŸ” User can track:', canTrack);
            
            // Determine opponent team
            const isHomeTeam = isHome;
            const myTeamId = selectedTeam;
            const opponentId = isHomeTeam ? selectedGame.awayTeamId : selectedGame.homeTeamId;
            const opponentName = isHomeTeam ? selectedGame.awayTeam : selectedGame.homeTeam;
            
            setOpponentTeamId(opponentId);
            setOpponentTeamName(opponentName);
            console.log('ðŸŸï¸ My team:', myTeamId, 'vs Opponent:', opponentId);
            
            // Get seasonId for all subsequent calls
            const seasonId = selectedGame.seasonId;
            
            if (!seasonId) {
                console.error('âŒ Game missing seasonId - cannot sync');
                return;
            }
            
            // Update presence
            await window.FirebaseGameTracker.updatePresence(
                seasonId,
                selectedGame.id,
                currentUser.uid,
                myTeamId,
                currentUser.displayName || 'Unknown'
            );
            
            // Subscribe to YOUR team's game state
            unsubscribeYourTeam = window.FirebaseGameTracker.subscribeToGameState(
                seasonId,
                selectedGame.id,
                myTeamId,
                (data) => {
                    if (!data) return; // Guard against null data
                    
                    // Only update if it wasn't this user who made the change
                    if (data.metadata?.lastUpdatedBy !== currentUser.uid) {
                        console.log('ðŸ“¥ Your team updated by', data.metadata?.lastUpdatedByName);
                        
                        // Set flag to prevent auto-save loop
                        isUpdatingFromFirebase.current = true;
                        
                        // The data IS the game state (not data.gameState)
                        // Map the Firebase structure to our component's gameState structure
                        const mappedGameState = {
                            inning: data.inning || 1,
                            outs: data.outs || 0,
                            bases: data.bases || { first: null, second: null, third: null },
                            score: { yourTeam: data.score || 0, opponent: opponentGameState?.score || 0 },
                            currentBatter: data.currentBatter || 0,
                            playHistory: data.plays || [],
                            gameActive: data.gameActive !== false,
                            isYourTeamBatting: data.isYourTeamBatting !== false
                        };
                        
                        setGameState(mappedGameState);
                        
                        // Reconstruct batting order from IDs
                        if (data.battingOrder && battingOrder.length > 0) {
                            const reconstructed = data.battingOrder.map(id => 
                                battingOrder.find(p => p.id === id)
                            ).filter(p => p !== undefined);
                            if (reconstructed.length > 0) {
                                setBattingOrder(reconstructed);
                            }
                        }
                        
                        // Show notification
                        addNotification({
                            id: Date.now(),
                            message: `${data.metadata?.lastUpdatedByName || 'Teammate'} updated the game`,
                            type: 'update'
                        });
                    }
                }
            );
            
            // Subscribe to OPPONENT's game state
            if (opponentId) {
                unsubscribeOpponent = window.FirebaseGameTracker.subscribeToGameState(
                    seasonId,
                    selectedGame.id,
                    opponentId,
                    (data) => {
                        if (!data) return; // Guard against null data
                        
                        console.log('ðŸ“¥ Opponent game state updated');
                        
                        // The data IS the game state (not data.gameState)
                        const mappedOpponentState = {
                            score: data.score || 0,
                            inning: data.inning || 1,
                            outs: data.outs || 0
                        };
                        
                        setOpponentGameState(mappedOpponentState);
                        
                        // Show score change notification
                        if (data.score !== opponentGameState?.score) {
                            const opponentScore = data.score || 0;
                            const yourScore = gameState.score.yourTeam;
                            addNotification({
                                id: Date.now(),
                                message: `Score update: ${selectedTeam} ${yourScore} - ${opponentScore} ${opponentName}`,
                                type: 'score'
                            });
                        }
                    }
                );
            }
            
            // Subscribe to game metadata
            unsubscribeMetadata = window.FirebaseGameTracker.subscribeToGameMetadata(seasonId, selectedGame.id, (data) => {
                setGameMetadata(data);
                
                // Update local state based on shared metadata
                if (data) {
                    // Update opponent score from metadata
                    // If we're home, opponent is away; if we're away, opponent is home
                    const opponentScoreFromMetadata = isHomeTeam ? data.awayScore : data.homeScore;
                    if (opponentScoreFromMetadata !== undefined && opponentScoreFromMetadata !== null) {
                        setGameState(prev => {
                            if (prev.score.opponent !== opponentScoreFromMetadata) {
                                return {
                                    ...prev,
                                    score: {
                                        ...prev.score,
                                        opponent: opponentScoreFromMetadata
                                    }
                                };
                            }
                            return prev;
                        });
                    }
                    
                    // Update batting state
                    if (data.currentBattingTeam) {
                        const shouldWeBeBatting = (data.currentBattingTeam === myTeamId);
                        
                        // Only update if it changed
                        if (gameState.isYourTeamBatting !== shouldWeBeBatting) {
                            console.log(`ðŸ”„ Batting changed: ${shouldWeBeBatting ? 'Your team' : 'Opponent'} now batting`);
                            setGameState(prev => ({
                                ...prev,
                                isYourTeamBatting: shouldWeBeBatting,
                                inning: data.inning || prev.inning,
                                outs: data.outs || 0
                            }));
                        }
                    }
                }
            });
            
            // Subscribe to presence
            unsubscribePresence = window.FirebaseGameTracker.subscribeToPresence(seasonId, selectedGame.id, (users) => {
                setPresenceUsers(users);
            });
            
            console.log('âœ… Real-time sync initialized');
            
        } catch (error) {
            console.error('âŒ Error initializing game sync:', error);
        }
    }
    
    initializeGameSync();
    
    // Cleanup function
    return () => {
        if (unsubscribeYourTeam) unsubscribeYourTeam();
        if (unsubscribeOpponent) unsubscribeOpponent();
        if (unsubscribeMetadata) unsubscribeMetadata();
        if (unsubscribePresence) unsubscribePresence();
        
        // Remove presence on unmount
        if (selectedGame && selectedGame.seasonId && currentUser) {
            window.FirebaseGameTracker.removePresence(selectedGame.seasonId, selectedGame.id, currentUser.uid);
        }
    };
}, [selectedGame, setupMode, selectedTeam, currentUser, isHome]);

            const loadInitialData = async () => {
                try {
                    console.log('ðŸ“„ Loading initial data from Firebase...');
                    
                    const user = window.getCurrentFirebaseUser ? window.getCurrentFirebaseUser() : null;
                    setCurrentUser(user);
                    
                    if (user) {
                        console.log('âœ… Signed in as:', user.displayName || user.email);
                        
                        try {
                            const profileResult = await window.FirebaseGameTracker.getUserProfile(user.uid);
                            if (profileResult.success && profileResult.data?.linkedTeam) {
                                console.log('âœ… Auto-selecting team:', profileResult.data.linkedTeam);
                                setSelectedTeam(profileResult.data.linkedTeam);
                            }
                        } catch (profileError) {
                            console.warn('Could not load user profile:', profileError);
                        }
                    } else {
                        console.log('â„¹ï¸ Not signed in');
                    }
                    
                    const seasonData = await window.FirebaseGameTracker.getCurrentSeason();
                    setCurrentSeason(seasonData);
                    console.log('âœ… Current season:', seasonData);
                    
                    const teams = await window.FirebaseGameTracker.getAllTeams();
                    const teamNames = teams
                        .map(t => t.name || t.id)
                        .filter(name => name.toLowerCase() !== 'kings') // Remove inactive team
                        .sort();
                    setAllTeams(teamNames);
                    console.log('âœ… Teams loaded:', teamNames.length);
                    
                    setLoading(false);
                } catch (err) {
                    console.error('âŒ Error loading initial data:', err);
                    setError(err.message);
                    setLoading(false);
                }
            };

            const loadTeamData = async () => {
                try {
                    console.log('ðŸ“„ Loading team data for:', selectedTeam);
                    
                    const seasonPlayers = await window.FirebaseGameTracker.getSeasonPlayerStatsOptimized(
                        currentSeason.id
                    );
                    
                    const teamPlayers = seasonPlayers.filter(p => 
                        p.team?.toLowerCase() === selectedTeam.toLowerCase() && !p.migrated
                    );
                    
                    console.log('ðŸ“Š Team players:', teamPlayers.length);
                    
                    const formattedPlayersPromises = teamPlayers.map(async (player, index) => {
                        const name = player.name || player.playerName;
                        const nameParts = name.trim().split(' ');
                        const avatar = nameParts.length > 1
                            ? (nameParts[0][0] + nameParts[nameParts.length - 1][0]).toUpperCase()
                            : name.substring(0, 2).toUpperCase();
                        
                        let jerseyNum = player.number || (index + 1);
                        
                        // Try to get the player's profile for accurate jersey number
                        try {
                            const playerProfile = await window.FirebaseGameTracker.getUserProfile(player.playerId || player.id);
                            if (playerProfile.success && playerProfile.data?.number) {
                                jerseyNum = parseInt(playerProfile.data.number) || jerseyNum;
                            }
                        } catch (error) {
                            console.warn(`Could not load profile for ${name}:`, error);
                        }
                        
                        return {
                            id: player.playerId || player.id,
                            name,
                            number: jerseyNum.toString(),
                            position: player.position || 'IF/OF',
                            avatar,
                            battingAvg: player.battingAverage ? player.battingAverage.toFixed(3) : '.000'
                        };
                    });
                    
                    const formattedPlayers = await Promise.all(formattedPlayersPromises);
                    
                    setPlayers(formattedPlayers);
                    
                    const upcomingGames = await window.FirebaseGameTracker.getUpcomingTeamGames(
                        selectedTeam,
                        currentSeason.id
                    );
                    
                    const capitalizeTeamName = (name) => {
                        if (!name) return '';
                        return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                    };
                    
                    const formattedGames = upcomingGames.map(game => {
                        const gameDate = game.date?.seconds
                            ? new Date(game.date.seconds * 1000).toLocaleDateString()
                            : game.date;
                        
                        const teamLower = selectedTeam.toLowerCase();
                        const homeTeamLower = (game.homeTeam || game.homeTeamId || '').toLowerCase();
                        const isHome = homeTeamLower === teamLower;
                        
                        const homeTeamCapitalized = capitalizeTeamName(game.homeTeam || game.homeTeamId);
                        const awayTeamCapitalized = capitalizeTeamName(game.awayTeam || game.awayTeamId);
                        const opponent = isHome ? awayTeamCapitalized : homeTeamCapitalized;
                        
                        return {
                            id: game.id,
                            date: gameDate,
                            homeTeam: homeTeamCapitalized,
                            awayTeam: awayTeamCapitalized,
                            homeTeamId: game.homeTeamId,
                            awayTeamId: game.awayTeamId,
                            opponent,
                            isHome,
                            seasonId: currentSeason.id // Add seasonId from current season
                        };
                    });
                    
                    setGames(formattedGames);
                    console.log('âœ… Team data loaded:', formattedPlayers.length, 'players,', formattedGames.length, 'games');
                    
                } catch (error) {
                    console.error('âŒ Error loading team data:', error);
                }
            };

            const handleTeamSelect = (team) => {
                setSelectedTeam(team);
                setSelectedGame(null);
                setLineupExists(false);
            };

            const handleGameSelect = async (game) => {
                setSelectedGame(game);
                const teamIsHome = game.homeTeam?.toLowerCase() === selectedTeam.toLowerCase();
                setIsHome(teamIsHome);
                
                try {
                    const battingOrderIds = await window.FirebaseGameTracker.getBattingOrder(
                        game.id,
                        selectedTeam
                    );
                    setLineupExists(battingOrderIds && battingOrderIds.length > 0);
                    
                    const savedState = await window.FirebaseGameTracker.loadGameState(
                        game.id,
                        selectedTeam,
                        game.seasonId
                    );
                    
                    // Check for saved game (data is flat, not nested)
                    if (savedState && !savedState.cleared && (savedState.plays?.length > 0 || savedState.inning > 1)) {
                        console.log('ðŸ“‚ Found game in progress');
                    }
                } catch (error) {
                    console.error('Error checking lineup:', error);
                    setLineupExists(false);
                }
            };

            const startGame = async () => {
                if (!selectedTeam || !selectedGame) return;
                
                // Validate seasonId exists
                if (!selectedGame.seasonId) {
                    console.error('âŒ Game missing seasonId - cannot start tracking');
                    alert('Error: Game is missing season information. Please refresh and try again.');
                    return;
                }
                
                const savedState = await window.FirebaseGameTracker.loadGameState(
                    selectedGame.id,
                    selectedTeam,
                    selectedGame.seasonId
                );
                
                // Check if there's a saved game (data is stored flat, not nested)
                if (savedState && !savedState.cleared && (savedState.plays?.length > 0 || savedState.inning > 1)) {
                    const resume = window.confirm(
                        'A game in progress was found. Do you want to resume where you left off?\n\n' +
                        `Inning: ${savedState.inning || 1}\n` +
                        `Outs: ${savedState.outs || 0}\n` +
                        `Score: ${savedState.score || 0}\n` +
                        `Plays recorded: ${savedState.plays?.length || 0}\n\n` +
                        'Click OK to resume, or Cancel to start a new game.'
                    );
                    
                    if (resume) {
                        // Restore batting order from saved player IDs
                        const savedBattingOrderIds = savedState.battingOrder || [];
                        const orderedPlayers = savedBattingOrderIds
                            .map(playerId => players.find(p => p.id === playerId))
                            .filter(p => p !== null && p !== undefined);
                        
                        if (orderedPlayers.length > 0) {
                            setBattingOrder(orderedPlayers);
                        } else {
                            setBattingOrder(players);
                        }
                        
                        // Map flat Firebase structure to component's gameState structure
                        const restoredGameState = {
                            inning: savedState.inning || 1,
                            outs: savedState.outs || 0,
                            bases: savedState.bases || { first: null, second: null, third: null },
                            score: { 
                                yourTeam: savedState.score || 0, 
                                opponent: 0  // Will be updated from metadata subscription
                            },
                            currentBatter: savedState.currentBatter || 0,
                            playHistory: savedState.plays || [],
                            gameActive: savedState.gameActive !== false,
                            isYourTeamBatting: savedState.isYourTeamBatting !== false
                        };
                        
                        setGameState(restoredGameState);
                        setSetupMode(false);
                        console.log('âœ… Resumed game from saved state:', restoredGameState);
                        return;
                    } else {
                        await window.FirebaseGameTracker.clearGameState(
                            selectedGame.id,
                            selectedTeam,
                            selectedGame.seasonId
                        );
                    }
                }
                
                try {
                    const battingOrderIds = await window.FirebaseGameTracker.getBattingOrder(
                        selectedGame.id,
                        selectedTeam
                    );
                    
                    if (battingOrderIds && battingOrderIds.length > 0) {
                        const orderedPlayers = battingOrderIds
                            .map(playerId => players.find(p => p.id === playerId))
                            .filter(p => p !== null && p !== undefined);
                        
                        if (orderedPlayers.length > 0) {
                            console.log('âœ… Loaded batting order from roster management:', orderedPlayers.length, 'players');
                            setBattingOrder(orderedPlayers);
                        } else {
                            console.log('âš ï¸ Could not map player IDs to players, using full roster');
                            setBattingOrder(players);
                        }
                    } else {
                        console.log('â„¹ï¸ No pre-set lineup found, using full roster');
                        setBattingOrder(players);
                    }
                } catch (error) {
                    console.error('Error loading batting order:', error);
                    console.log('Using full roster as fallback');
                    setBattingOrder(players);
                }
                
                setGameState({
                    inning: 1,
                    outs: 0,
                    bases: { first: null, second: null, third: null },
                    score: { yourTeam: 0, opponent: 0 },
                    currentBatter: 0,
                    playHistory: [],
                    gameActive: true,
                    isYourTeamBatting: !isHome
                });
                
                // Initialize shared game metadata
                // Away team ALWAYS bats first (top of 1st)
                try {
                    const firstBattingTeam = selectedGame.awayTeam || selectedGame.awayTeamId;
                    await window.FirebaseGameTracker.updateGameMetadata(selectedGame.seasonId, selectedGame.id, {
                        inning: 1,
                        outs: 0,
                        homeScore: 0,
                        awayScore: 0,
                        currentBattingTeam: firstBattingTeam
                    });
                    console.log(`âœ… Game metadata initialized: ${firstBattingTeam} batting first (top of 1st)`);
                } catch (error) {
                    console.error('Error initializing game metadata:', error);
                }
                
                setSetupMode(false);
            };

            const currentBatter = battingOrder[gameState.currentBatter];
            const opponentName = selectedGame ? (isHome ? selectedGame.awayTeam : selectedGame.homeTeam) : 'Opponent';

            const initiatePlay = (playType) => {
                const play = PLAY_TYPES.find(p => p.value === playType);
                if (!play) return;

                if (play.noAdjust) {
                    const newState = { ...gameState };
                    newState.outs += 1;

                    const playRecord = {
                        inning: gameState.inning,
                        isYourTeam: gameState.isYourTeamBatting,
                        batter: currentBatter.name,
                        playType: play.value,
                        playLabel: play.label,
                        outsBefore: gameState.outs,
                        outsAfter: newState.outs,
                        basesBefore: { ...gameState.bases },
                        basesAfter: { ...gameState.bases },
                        runsScored: 0,
                        timestamp: Date.now()
                    };

                    newState.currentBatter = (newState.currentBatter + 1) % battingOrder.length;
                    newState.playHistory = [...gameState.playHistory, playRecord];
                    setGameState(newState);
                    return;
                }

                const newBases = { ...gameState.bases };
                let autoScore = 0;
                let autoOuts = 0;

                if (play.bases === 4) {
                    if (newBases.third) autoScore++;
                    if (newBases.second) autoScore++;
                    if (newBases.first) autoScore++;
                    autoScore++;
                    newBases.first = null;
                    newBases.second = null;
                    newBases.third = null;
                } else if (play.bases === 3) {
                    if (newBases.third) autoScore++;
                    if (newBases.second) autoScore++;
                    if (newBases.first) autoScore++;
                    newBases.third = currentBatter.name;
                    newBases.second = null;
                    newBases.first = null;
                } else if (play.bases === 2) {
                    if (newBases.third) autoScore++;
                    if (newBases.second) autoScore++;
                    newBases.third = newBases.first;
                    newBases.second = currentBatter.name;
                    newBases.first = null;
                } else if (play.bases === 1) {
                    const isWalk = play.value === 'walk';
                    
                    if (isWalk) {
                        if (newBases.first) {
                            if (newBases.second) {
                                if (newBases.third) {
                                    autoScore++;
                                    newBases.third = newBases.second;
                                    newBases.second = newBases.first;
                                    newBases.first = currentBatter.name;
                                } else {
                                    newBases.third = newBases.second;
                                    newBases.second = newBases.first;
                                    newBases.first = currentBatter.name;
                                }
                            } else {
                                const runnerOn3rd = newBases.third;
                                newBases.second = newBases.first;
                                newBases.first = currentBatter.name;
                                newBases.third = runnerOn3rd;
                            }
                        } else {
                            newBases.first = currentBatter.name;
                        }
                    } else {
                        const runnersToMove = [];
                        if (newBases.third) runnersToMove.push({ runner: newBases.third, from: 'third' });
                        if (newBases.second) runnersToMove.push({ runner: newBases.second, from: 'second' });
                        if (newBases.first) runnersToMove.push({ runner: newBases.first, from: 'first' });

                        newBases.first = currentBatter.name;
                        newBases.second = null;
                        newBases.third = null;

                        runnersToMove.forEach(({runner, from}) => {
                            if (from === 'third') {
                                autoScore++;
                            } else if (from === 'second') {
                                newBases.third = runner;
                            } else if (from === 'first') {
                                newBases.second = runner;
                            }
                        });
                    }
                } else if (play.isOut) {
                    autoOuts = 1;
                } else if (play.outs) {
                    autoOuts = play.outs;
                } else if (play.value === 'fielders_choice') {
                    newBases.first = currentBatter.name;
                }

                setTempBases(newBases);
                setTempScore(autoScore);
                setTempOuts(autoOuts);
                setPendingPlay({ play, type: playType });
            };

            const adjustRunner = (base, direction) => {
                const newBases = { ...tempBases };
                const runner = newBases[base];
                
                if (!runner) return;

                newBases[base] = null;

                if (direction === 'advance') {
                    if (base === 'first') {
                        newBases.second = runner;
                    } else if (base === 'second') {
                        newBases.third = runner;
                    } else if (base === 'third') {
                        setTempScore(tempScore + 1);
                    }
                } else if (direction === 'back') {
                    if (base === 'second') {
                        newBases.first = runner;
                    } else if (base === 'third') {
                        newBases.second = runner;
                    }
                }

                setTempBases(newBases);
            };

            const handleDragStart = (base) => {
                setDraggedRunner({ base, runner: tempBases[base] });
            };

            const handleDragOver = (e) => {
                e.preventDefault();
            };

            const handleDrop = (targetBase) => {
                if (!draggedRunner) return;

                const newBases = { ...tempBases };
                newBases[draggedRunner.base] = null;

                if (targetBase === 'home') {
                    setTempScore(tempScore + 1);
                } else {
                    newBases[targetBase] = draggedRunner.runner;
                }

                setTempBases(newBases);
                setDraggedRunner(null);
            };

            const removeRunner = (base) => {
                const newBases = { ...tempBases };
                newBases[base] = null;
                setTempBases(newBases);
                setTempOuts(tempOuts + 1);
            };

            const confirmPlay = () => {
                if (!pendingPlay) return;

                const newState = { ...gameState };
                const play = pendingPlay.play;

                newState.outs += tempOuts;

                const playRecord = {
                    inning: gameState.inning,
                    isYourTeam: gameState.isYourTeamBatting,
                    batter: currentBatter.name,
                    playType: play.value,
                    playLabel: play.label,
                    outsBefore: gameState.outs,
                    outsAfter: newState.outs,
                    basesBefore: { ...gameState.bases },
                    basesAfter: { ...tempBases },
                    runsScored: tempScore,
                    timestamp: Date.now()
                };

                newState.bases = tempBases;
                newState.score.yourTeam += tempScore;
                newState.currentBatter = (newState.currentBatter + 1) % battingOrder.length;
                newState.playHistory = [...gameState.playHistory, playRecord];

                setGameState(newState);
                setPendingPlay(null);
                setTempBases(null);
                setTempScore(0);
                setTempOuts(0);
            };

            const cancelPlay = () => {
                setPendingPlay(null);
                setTempBases(null);
                setTempScore(0);
                setTempOuts(0);
            };

            // Update opponent score manually (for when opponent team isn't tracking)
            const updateOpponentScore = async (delta) => {
                const newOpponentScore = Math.max(0, gameState.score.opponent + delta);
                
                // Update local state
                setGameState(prev => ({
                    ...prev,
                    score: {
                        ...prev.score,
                        opponent: newOpponentScore
                    }
                }));
                
                // Update Firebase metadata
                try {
                    const updateData = {
                        // If we're home, opponent is away; if we're away, opponent is home
                        [isHome ? 'awayScore' : 'homeScore']: newOpponentScore
                    };
                    await window.FirebaseGameTracker.updateGameMetadata(
                        selectedGame.seasonId, 
                        selectedGame.id, 
                        updateData
                    );
                    console.log(`âœ… Opponent score updated: ${newOpponentScore}`);
                } catch (error) {
                    console.error('Error updating opponent score:', error);
                }
            };

            const advanceToNextHalfInning = async () => {
                const newState = { ...gameState };
                newState.outs = 0;
                newState.bases = { first: null, second: null, third: null };
                
                // Determine which team should bat next based on current state
                let nextBattingTeam;
                let nextInning = gameMetadata?.inning || gameState.inning;
                
                if (newState.isYourTeamBatting) {
                    // Your team just finished batting, opponent bats next
                    newState.isYourTeamBatting = false;
                    nextBattingTeam = opponentTeamName;
                    // Increment inning after home team finishes batting (end of full inning)
                    if (isHome) {
                        nextInning += 1;
                    }
                } else {
                    // Opponent just finished batting, your team bats next
                    newState.isYourTeamBatting = true;
                    nextBattingTeam = selectedTeam;
                    // Increment inning after home team finishes batting (end of full inning)
                    if (!isHome) {
                        nextInning += 1;
                    }
                }
                
                // Update local state
                newState.inning = nextInning;
                setGameState(newState);
                
                // Update shared game metadata so both teams know who's batting
                try {
                    await window.FirebaseGameTracker.updateGameMetadata(selectedGame.seasonId, selectedGame.id, {
                        inning: nextInning,
                        outs: 0,
                        currentBattingTeam: nextBattingTeam,
                        homeScore: isHome ? gameState.score.yourTeam : (opponentGameState?.score || 0),
                        awayScore: !isHome ? gameState.score.yourTeam : (opponentGameState?.score || 0)
                    });
                    console.log(`âœ… Half-inning advanced: ${nextBattingTeam} now batting in inning ${nextInning}`);
                } catch (error) {
                    console.error('Error updating game metadata:', error);
                }
            };

            const undoLastPlay = () => {
                if (gameState.playHistory.length === 0) return;

                const newHistory = [...gameState.playHistory];
                const lastPlay = newHistory.pop();

                const newState = {
                    ...gameState,
                    bases: { ...lastPlay.basesBefore },
                    outs: lastPlay.outsBefore,
                    score: {
                        ...gameState.score,
                        yourTeam: gameState.score.yourTeam - (lastPlay.runsScored || 0)
                    },
                    playHistory: newHistory
                };

                newState.currentBatter = (newState.currentBatter - 1 + battingOrder.length) % battingOrder.length;

                if (lastPlay.outsBefore >= 3 && gameState.outs === 0) {
                    if (gameState.isYourTeamBatting && gameState.inning > 1) {
                        newState.inning -= 1;
                        newState.isYourTeamBatting = false;
                    } else if (!gameState.isYourTeamBatting) {
                        newState.isYourTeamBatting = true;
                    }
                    newState.outs = lastPlay.outsBefore;
                }

                setGameState(newState);
            };

            const clearProgress = async () => {
                const confirmed = window.confirm(
                    'âš ï¸ Clear Game Progress?\n\n' +
                    'This will:\n' +
                    '- Delete all saved progress for this game\n' +
                    '- Reset to game setup screen\n' +
                    '- NOT save any batting stats\n\n' +
                    `Current Progress:\n` +
                    `- Inning: ${gameState.inning}\n` +
                    `- Score: ${gameState.score.yourTeam}-${gameState.score.opponent}\n` +
                    `- Plays: ${gameState.playHistory.length}\n\n` +
                    'Are you sure you want to clear all progress?'
                );
                
                if (confirmed) {
                    if (selectedGame && selectedTeam && selectedGame.seasonId) {
                        await window.FirebaseGameTracker.clearGameState(
                            selectedGame.id,
                            selectedTeam,
                            selectedGame.seasonId
                        );
                    }
                    
                    setSetupMode(true);
                    setGameState({
                        inning: 1,
                        outs: 0,
                        bases: { first: null, second: null, third: null },
                        score: { yourTeam: 0, opponent: 0 },
                        currentBatter: 0,
                        playHistory: [],
                        gameActive: true,
                        isYourTeamBatting: true
                    });
                    setPendingPlay(null);
                    setTempBases(null);
                    setTempScore(0);
                    setTempOuts(0);
                    
                    alert('âœ… Game progress cleared. You can start fresh or choose a different game.');
                }
            };

            const endGame = async () => {
                const confirmed = window.confirm(
                    'Are you sure you want to end the game?\n\n' +
                    `Final Score: ${selectedTeam} ${gameState.score.yourTeam} - ${opponentName} ${gameState.score.opponent}\n` +
                    `Plays Recorded: ${gameState.playHistory.length}\n\n` +
                    'This will save batting stats and clear the game tracker.'
                );
                
                if (confirmed) {
                    if (selectedGame && selectedTeam && currentSeason) {
                        const result = await window.FirebaseGameTracker.saveGameResults(
                            selectedGame.id,
                            selectedTeam,
                            currentSeason.id,
                            gameState,
                            battingOrder,
                            isHome,
                            opponentName
                        );
                        
                        if (result.success) {
                            alert(
                                'âœ… Game Complete!\n\n' +
                                'Batting stats have been saved:\n' +
                                `- ${result.battingStats.length} players tracked\n` +
                                `- ${gameState.playHistory.length} plays recorded\n` +
                                `- Final Score: ${gameState.score.yourTeam}-${gameState.score.opponent}`
                            );
                        }
                    }
                    
                    setGameState({ ...gameState, gameActive: false });
                    
                    if (selectedGame && selectedTeam && selectedGame.seasonId) {
                        await window.FirebaseGameTracker.clearGameState(
                            selectedGame.id,
                            selectedTeam,
                            selectedGame.seasonId
                        );
                    }
                }
            };

            // Go back to setup screen (with confirmation if game in progress)
            const backToSetup = () => {
                if (gameState.playHistory.length > 0) {
                    const confirmed = window.confirm(
                        'âš ï¸ Leave Game Tracker?\n\n' +
                        'Your progress is auto-saved and you can resume later.\n\n' +
                        `Current Progress:\n` +
                        `- Inning: ${gameState.inning}\n` +
                        `- Score: ${selectedTeam} ${gameState.score.yourTeam} - ${opponentName} ${gameState.score.opponent}\n` +
                        `- Plays: ${gameState.playHistory.length}\n\n` +
                        'Go back to game selection?'
                    );
                    
                    if (!confirmed) return;
                }
                
                setSetupMode(true);
                setSelectedGame(null);
            };

            // Lineup editing functions
            const movePlayerUp = (index) => {
                if (index === 0) return;
                const newOrder = [...battingOrder];
                [newOrder[index - 1], newOrder[index]] = [newOrder[index], newOrder[index - 1]];
                
                // Adjust currentBatter if affected
                let newCurrentBatter = gameState.currentBatter;
                if (gameState.currentBatter === index) {
                    newCurrentBatter = index - 1;
                } else if (gameState.currentBatter === index - 1) {
                    newCurrentBatter = index;
                }
                
                setBattingOrder(newOrder);
                if (newCurrentBatter !== gameState.currentBatter) {
                    setGameState(prev => ({ ...prev, currentBatter: newCurrentBatter }));
                }
            };

            const movePlayerDown = (index) => {
                if (index === battingOrder.length - 1) return;
                const newOrder = [...battingOrder];
                [newOrder[index], newOrder[index + 1]] = [newOrder[index + 1], newOrder[index]];
                
                // Adjust currentBatter if affected
                let newCurrentBatter = gameState.currentBatter;
                if (gameState.currentBatter === index) {
                    newCurrentBatter = index + 1;
                } else if (gameState.currentBatter === index + 1) {
                    newCurrentBatter = index;
                }
                
                setBattingOrder(newOrder);
                if (newCurrentBatter !== gameState.currentBatter) {
                    setGameState(prev => ({ ...prev, currentBatter: newCurrentBatter }));
                }
            };

            const removeFromLineup = (index) => {
                if (battingOrder.length <= 1) {
                    alert('Cannot remove the last player from the lineup.');
                    return;
                }
                
                const playerName = battingOrder[index].name;
                const confirmed = window.confirm(`Remove ${playerName} from the batting order?`);
                if (!confirmed) return;
                
                const newOrder = battingOrder.filter((_, i) => i !== index);
                
                // Adjust currentBatter if needed
                let newCurrentBatter = gameState.currentBatter;
                if (index < gameState.currentBatter) {
                    newCurrentBatter = gameState.currentBatter - 1;
                } else if (index === gameState.currentBatter) {
                    newCurrentBatter = gameState.currentBatter % newOrder.length;
                }
                
                setBattingOrder(newOrder);
                setGameState(prev => ({ ...prev, currentBatter: newCurrentBatter }));
            };

            const addToLineup = (player) => {
                if (battingOrder.find(p => p.id === player.id)) {
                    alert(`${player.name} is already in the lineup.`);
                    return;
                }
                setBattingOrder([...battingOrder, player]);
            };

            // Get players not currently in lineup (for adding)
            const availablePlayers = players.filter(p => !battingOrder.find(b => b.id === p.id));

            const displayBases = pendingPlay ? tempBases : gameState.bases;
            const displayScore = pendingPlay ? tempScore : 0;
            const inningOver = gameState.outs >= 3;

            if (loading) {
                return (
                    <div className="min-h-screen flex items-center justify-center" style={{ background: 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)' }}>
                        <div className="text-center">
                            <div className="text-6xl mb-4 animate-bounce">âš¾</div>
                            <h1 className="text-2xl font-bold mb-2" style={{ color: '#2d5016' }}>Loading Game Tracker...</h1>
                            <p className="text-gray-600">Connecting to Firebase...</p>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="min-h-screen flex items-center justify-center" style={{ background: 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)' }}>
                        <div className="text-center bg-white p-8 rounded-2xl shadow-lg max-w-md mx-4">
                            <div className="text-5xl mb-4">âŒ</div>
                            <h1 className="text-2xl font-bold text-red-600 mb-3">Error Loading Data</h1>
                            <p className="text-gray-600 mb-4">{error}</p>
                            <p className="text-sm text-gray-500">Please check your Firebase connection.</p>
                        </div>
                    </div>
                );
            }

            if (setupMode) {
                return (
                    <div className="min-h-screen" style={{ background: 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)' }}>
                        {/* Header */}
                        <div className="relative overflow-hidden" style={{ background: 'linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%)', padding: '3rem 2rem' }}>
                            <div className="absolute top-0 right-0 w-64 h-64 rounded-full opacity-10" style={{ background: 'radial-gradient(circle, white 0%, transparent 70%)', transform: 'translate(30%, -30%)' }}></div>
                            <div className="absolute bottom-0 left-0 text-9xl opacity-5 select-none" style={{ transform: 'translate(-20%, 20%)' }}>âš¾</div>
                            <div className="max-w-4xl mx-auto text-center relative z-10">
                                <h1 className="text-4xl font-bold text-white mb-2">
                                    âš¾ Game Tracker
                                </h1>
                                <p className="text-xl text-white/90">
                                    {currentSeason ? `${currentSeason.year} ${currentSeason.season.charAt(0).toUpperCase() + currentSeason.season.slice(1)} Season` : 'Loading...'}
                                </p>
                                {!currentUser && (
                                    <p className="text-sm mt-3 px-4 py-2 rounded-full inline-block" style={{ background: 'rgba(255,215,0,0.2)', color: '#ffd700' }}>
                                        â„¹ï¸ Sign in to save tracking to your account
                                    </p>
                                )}
                            </div>
                        </div>

                        {/* Main Content */}
                        <div className="max-w-4xl mx-auto p-6 -mt-6">
                            {/* Step 1: Team Selection */}
                            <div className="bg-white rounded-2xl p-6 mb-6 relative overflow-hidden" style={{ boxShadow: '0 4px 16px rgba(0,0,0,0.08)', border: '1px solid #e2e8f0' }}>
                                <div className="absolute top-0 left-0 right-0 h-1" style={{ background: 'linear-gradient(90deg, #2d5016 0%, #1a6b4a 100%)' }}></div>
                                <h2 className="text-xl font-bold mb-4 flex items-center gap-3" style={{ color: '#2d3748' }}>
                                    <span className="w-8 h-8 rounded-full flex items-center justify-center text-white text-sm font-bold" style={{ background: 'linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%)' }}>1</span>
                                    Select Your Team
                                </h2>
                                <select 
                                    value={selectedTeam}
                                    onChange={(e) => handleTeamSelect(e.target.value)}
                                    className="w-full p-4 text-lg rounded-xl transition-all focus:outline-none"
                                    style={{ 
                                        border: '2px solid #e2e8f0',
                                        background: selectedTeam ? '#f0fdf4' : 'white'
                                    }}
                                    onFocus={(e) => e.target.style.borderColor = '#2d5016'}
                                    onBlur={(e) => e.target.style.borderColor = '#e2e8f0'}
                                >
                                    <option value="">Choose a team...</option>
                                    {allTeams.map(team => (
                                        <option key={team} value={team}>{team}</option>
                                    ))}
                                </select>
                            </div>

                            {/* Step 2: Game Selection */}
                            {selectedTeam && games.length > 0 && (
                                <div className="bg-white rounded-2xl p-6 mb-6 relative overflow-hidden" style={{ boxShadow: '0 4px 16px rgba(0,0,0,0.08)', border: '1px solid #e2e8f0' }}>
                                    <div className="absolute top-0 left-0 right-0 h-1" style={{ background: 'linear-gradient(90deg, #2d5016 0%, #1a6b4a 100%)' }}></div>
                                    <h2 className="text-xl font-bold mb-4 flex items-center gap-3" style={{ color: '#2d3748' }}>
                                        <span className="w-8 h-8 rounded-full flex items-center justify-center text-white text-sm font-bold" style={{ background: 'linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%)' }}>2</span>
                                        Select Game to Track
                                    </h2>
                                    <div className="space-y-3">
                                        {games.map((game, idx) => (
                                            <button
                                                key={idx}
                                                onClick={() => handleGameSelect(game)}
                                                className="w-full p-4 text-left rounded-xl transition-all"
                                                style={{
                                                    border: selectedGame === game ? '2px solid #2d5016' : '2px solid #e2e8f0',
                                                    background: selectedGame === game ? 'linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)' : 'white',
                                                    transform: selectedGame === game ? 'scale(1.02)' : 'scale(1)',
                                                    boxShadow: selectedGame === game ? '0 4px 12px rgba(45,80,22,0.15)' : 'none'
                                                }}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <div className="flex items-center gap-2">
                                                        <span className="font-bold text-lg" style={{ color: '#2d3748' }}>{game.awayTeam}</span>
                                                        <span className="text-gray-400 text-sm">@</span>
                                                        <span className="font-bold text-lg" style={{ color: '#2d3748' }}>{game.homeTeam}</span>
                                                    </div>
                                                    <div className="text-sm font-medium" style={{ color: '#718096' }}>{game.date}</div>
                                                </div>
                                                <div className="flex items-center gap-2 mt-2">
                                                    <span className="text-xs px-2 py-1 rounded-full font-medium" style={{ 
                                                        background: game.isHome ? '#dcfce7' : '#e0f2fe',
                                                        color: game.isHome ? '#166534' : '#0369a1'
                                                    }}>
                                                        {game.isHome ? 'ðŸ  Home' : 'âœˆï¸ Away'}
                                                    </span>
                                                    {selectedGame === game && (
                                                        <span className="text-xs px-2 py-1 rounded-full font-medium" style={{ background: '#fef3c7', color: '#92400e' }}>
                                                            âœ“ Selected
                                                        </span>
                                                    )}
                                                </div>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* No Games Warning */}
                            {selectedTeam && games.length === 0 && (
                                <div className="bg-amber-50 border-2 border-amber-300 rounded-2xl p-6 mb-6">
                                    <div className="flex items-center gap-3">
                                        <span className="text-2xl">ðŸ“…</span>
                                        <p className="text-amber-900 font-medium">No upcoming games found for {selectedTeam}</p>
                                    </div>
                                </div>
                            )}

                            {/* Step 3: Start Game */}
                            {selectedTeam && selectedGame && (
                                <div className="bg-white rounded-2xl p-6 relative overflow-hidden" style={{ boxShadow: '0 4px 16px rgba(0,0,0,0.08)', border: '1px solid #e2e8f0' }}>
                                    <div className="absolute top-0 left-0 right-0 h-1" style={{ background: 'linear-gradient(90deg, #2d5016 0%, #1a6b4a 100%)' }}></div>
                                    
                                    {lineupExists && (
                                        <div className="mb-6 p-4 rounded-xl flex items-center gap-3" style={{ background: '#f0fdf4', border: '1px solid #86efac' }}>
                                            <span className="text-xl">âœ…</span>
                                            <p className="font-medium" style={{ color: '#166534' }}>
                                                Batting order set by captain - will be loaded automatically
                                            </p>
                                        </div>
                                    )}
                                    
                                    <div className="text-center">
                                        <h2 className="text-xl font-bold mb-4 flex items-center justify-center gap-3" style={{ color: '#2d3748' }}>
                                            <span className="w-8 h-8 rounded-full flex items-center justify-center text-white text-sm font-bold" style={{ background: 'linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%)' }}>3</span>
                                            Ready to Track
                                        </h2>
                                        
                                        <div className="mb-6 p-4 rounded-xl" style={{ background: '#f7fafc' }}>
                                            <p className="text-lg font-bold" style={{ color: '#2d3748' }}>
                                                {selectedTeam} vs {opponentName}
                                            </p>
                                            <p className="text-sm mt-1" style={{ color: '#718096' }}>
                                                {selectedGame?.date} â€¢ {isHome ? 'Home Game ðŸ ' : 'Away Game âœˆï¸'}
                                            </p>
                                        </div>
                                        
                                        <button
                                            onClick={startGame}
                                            className="px-10 py-4 text-xl font-bold text-white rounded-xl transition-all hover:scale-105"
                                            style={{ 
                                                background: 'linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%)',
                                                boxShadow: '0 4px 16px rgba(45,80,22,0.3)'
                                            }}
                                        >
                                            âš¾ Start Game Tracker
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            // Calculate live batting stats from current game
            const liveBattingStats = battingOrder.map(player => {
                const playerPlays = gameState.playHistory.filter(play => play.batter === player.name);
                
                let atBats = 0;
                let hits = 0;
                let runs = 0;
                let walks = 0;
                
                playerPlays.forEach(play => {
                    if (play.playType !== 'walk' && play.playType !== 'sacfly') {
                        atBats++;
                    }
                    if (['single', 'double', 'triple', 'homerun'].includes(play.playType)) {
                        hits++;
                    }
                    if (play.playType === 'walk') {
                        walks++;
                    }
                });
                
                // Count runs scored by this player
                gameState.playHistory.forEach(play => {
                    if (play.basesAfter.first !== play.basesBefore.first && play.basesBefore.first === player.name) {
                        // Player was on first and moved/scored
                    }
                    if (play.basesAfter.second !== play.basesBefore.second && play.basesBefore.second === player.name) {
                        // Player was on second and moved/scored
                    }
                    if (play.basesAfter.third !== play.basesBefore.third && play.basesBefore.third === player.name) {
                        // Player was on third and moved/scored
                    }
                    // Check if player scored (was on base before, not after, and runs were scored)
                    if (play.runsScored > 0) {
                        if (play.basesBefore.third === player.name && !play.basesAfter.third) runs++;
                        if (play.basesBefore.second === player.name && !play.basesAfter.second && !play.basesAfter.third) runs++;
                        if (play.basesBefore.first === player.name && !play.basesAfter.first && !play.basesAfter.second && !play.basesAfter.third) runs++;
                    }
                    // Home runs count as a run for the batter
                    if (play.batter === player.name && play.playType === 'homerun') {
                        runs++;
                    }
                });
                
                return {
                    name: player.name,
                    number: player.number,
                    atBats,
                    hits,
                    runs,
                    walks,
                    avg: atBats > 0 ? (hits / atBats).toFixed(3) : '.000'
                };
            });
			// Notification Toast Component
const NotificationToast = ({ notification, onDismiss }) => {
    return (
        <div className={`fixed top-20 right-4 max-w-sm rounded-lg shadow-lg p-4 z-50 ${
            notification.type === 'score' ? 'bg-green-600' :
            notification.type === 'update' ? 'bg-blue-600' :
            'bg-gray-600'
        } text-white animate-slide-in`}>
            <div className="flex items-center gap-3">
                <div className="flex-1">
                    <div className="font-semibold">{notification.message}</div>
                </div>
                <button 
                    onClick={onDismiss}
                    className="text-white opacity-75 hover:opacity-100 text-xl leading-none"
                >
                    Ã—
                </button>
            </div>
        </div>
    );
};

// Live Score Header Component
const LiveScoreHeader = ({ gameMetadata, yourTeamName, opponentTeamName, isHome }) => {
    if (!gameMetadata) return null;
    
    // gameMetadata only has: { inning, outs, homeScore, awayScore }
    const yourScore = isHome ? gameMetadata.homeScore : gameMetadata.awayScore;
    const opponentScore = isHome ? gameMetadata.awayScore : gameMetadata.homeScore;
    
    return (
        <div className="text-white p-6 rounded-xl mb-6" style={{ background: 'linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%)' }}>
            <div className="flex items-center justify-between">
                {/* Your Team */}
                <div className="flex-1 text-center">
                    <div className="text-2xl font-bold">{yourTeamName}</div>
                    <div className="text-6xl font-black mt-2">{yourScore || 0}</div>
                </div>
                
                <div className="text-3xl font-bold px-6">VS</div>
                
                {/* Opponent Team */}
                <div className="flex-1 text-center">
                    <div className="text-2xl font-bold">{opponentTeamName}</div>
                    <div className="text-6xl font-black mt-2">{opponentScore || 0}</div>
                </div>
            </div>
            
            <div className="text-center mt-4 text-xl font-semibold">
                Inning {gameMetadata.inning || 1} â€¢ {gameMetadata.outs || 0} Outs
            </div>
            
            <div className="flex items-center justify-center gap-2 mt-3">
                <div className="w-2 h-2 rounded-full animate-pulse" style={{ background: '#ffd700' }} />
                <span className="text-sm">LIVE</span>
            </div>
        </div>
    );
};

// Presence Indicator Component
const PresenceIndicator = ({ presenceUsers }) => {
    if (!presenceUsers || presenceUsers.length === 0) return null;
    
    const trackers = presenceUsers.filter(u => u.role === 'tracker');
    const viewers = presenceUsers.filter(u => u.role === 'viewer');
    
    return (
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
            <div className="flex items-center gap-3">
                <span className="text-xl">ðŸ‘¥</span>
                <div className="flex-1 text-sm">
                    {trackers.length > 0 && (
                        <div className="font-semibold text-blue-900">
                            Tracking: {trackers.map(t => t.userName).join(', ')}
                        </div>
                    )}
                    {viewers.length > 0 && (
                        <div className="text-blue-700">
                            Watching: {viewers.map(v => v.userName).join(', ')}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

// Merged Play-by-Play Component
const MergedPlayByPlay = ({ yourPlays, opponentPlays, yourTeamName, opponentName }) => {
    // Helper to determine if batter advanced beyond expected base
    const getAdvancementNote = (play) => {
        if (!play.basesAfter || !play.batter) return null;
        
        // Expected base positions for each play type
        const expectedBase = {
            'single': 'first',
            'double': 'second',
            'triple': 'third',
            'walk': 'first',
            'fielders_choice': 'first'
        };
        
        const expected = expectedBase[play.playType];
        if (!expected) return null; // HR, outs, etc. don't apply
        
        // Find where the batter actually ended up
        const bases = play.basesAfter;
        let actualBase = null;
        if (bases.third === play.batter) actualBase = 'third';
        else if (bases.second === play.batter) actualBase = 'second';
        else if (bases.first === play.batter) actualBase = 'first';
        
        // If they're not on any base but runs scored, they might have scored
        if (!actualBase && play.runsScored > 0) {
            // Check if the batter scored (not on any base after a hit)
            const baseOrder = ['first', 'second', 'third', 'home'];
            const expectedIdx = baseOrder.indexOf(expected);
            // Batter scored from a single/double/triple due to overthrow
            if (expectedIdx < 3) return 'scored';
        }
        
        if (!actualBase) return null;
        
        // Compare expected vs actual
        const baseOrder = ['first', 'second', 'third'];
        const expectedIdx = baseOrder.indexOf(expected);
        const actualIdx = baseOrder.indexOf(actualBase);
        
        if (actualIdx > expectedIdx) {
            const baseLabels = { 'second': '2nd', 'third': '3rd' };
            return baseLabels[actualBase];
        }
        
        return null;
    };

    // Combine and sort by timestamp
    const allPlays = React.useMemo(() => {
        const combined = [
            ...(yourPlays || []).map(p => ({ 
                ...p, 
                team: yourTeamName, 
                isYourTeam: true 
            })),
            ...(opponentPlays || []).map(p => ({ 
                ...p, 
                team: opponentName, 
                isYourTeam: false 
            }))
        ];
        
        return combined.sort((a, b) => b.timestamp - a.timestamp);
    }, [yourPlays, opponentPlays, yourTeamName, opponentName]);
    
    return (
        <div className="bg-white border border-gray-200 rounded-xl p-5">
            <h2 className="text-xl font-bold mb-4">
                Play-by-Play {opponentPlays && opponentPlays.length > 0 ? '(Both Teams)' : `(${yourTeamName} Only)`}
            </h2>
            <div className="max-h-80 overflow-y-auto">
                {allPlays.length === 0 ? (
                    <div className="text-center text-gray-400 py-5">
                        No plays recorded yet
                    </div>
                ) : (
                    allPlays.map((play, idx) => {
                        const advancementNote = getAdvancementNote(play);
                        return (
                            <div 
                                key={`${play.team}-${play.timestamp}-${idx}`}
                                className={`p-3 border-b border-gray-100 ${
                                    play.isYourTeam ? 'bg-green-50' : 'bg-gray-50'
                                }`}
                            >
                                <span className="font-bold" style={{ color: '#2d5016' }}>
                                    {play.inning}
                                </span>
                                {' â€¢ '}
                                <span className="font-semibold text-gray-700">
                                    {play.team}
                                </span>
                                {' â€¢ '}
                                <span className="font-bold">{play.batter}</span>
                                {' - '}
                                <span className={`px-2 py-1 rounded text-sm font-bold ${
                                    PLAY_TYPES.find(p => p.value === play.playType)?.isHit ? 'bg-green-100 text-green-800' : 
                                    PLAY_TYPES.find(p => p.value === play.playType)?.isOut ? 'bg-red-100 text-red-800' : 
                                    'bg-blue-100 text-blue-800'
                                }`}>
                                    {play.playLabel}
                                </span>
                                {advancementNote && (
                                    <span className="ml-2 text-orange-600 text-sm italic">
                                        (advanced to {advancementNote})
                                    </span>
                                )}
                                {play.runsScored > 0 && (
                                    <span className="ml-2 text-green-600 font-bold">
                                        +{play.runsScored} run{play.runsScored > 1 ? 's' : ''}
                                    </span>
                                )}
                            </div>
                        );
                    })
                )}
            </div>
        </div>
    );
};

// Viewer-Only Message Component
const ViewerOnlyMessage = () => {
    return (
        <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
            <div className="flex items-center">
                <AlertCircle size={20} className="text-yellow-600 mr-3" />
                <p className="text-yellow-800 font-medium">
                    ðŸ“º You're viewing this game. Only team captains and staff can track plays.
                </p>
            </div>
        </div>
    );
};
            return (
                <>
                    <div className="fixed top-20 right-4 z-50 space-y-2">
                        {notifications.map(notif => (
                            <NotificationToast
                                key={notif.id}
                                notification={notif}
                                onDismiss={() => setNotifications(prev => 
                                    prev.filter(n => n.id !== notif.id)
                                )}
                            />
                        ))}
                    </div>
                    
                    <div className="max-w-7xl mx-auto p-5 font-sans">
                    <div className="mb-6">
                        <button
                            onClick={backToSetup}
                            className="mb-4 px-4 py-2 text-sm font-medium text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded-lg transition-colors inline-flex items-center gap-2"
                        >
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7"/>
                            </svg>
                            Back to Game Selection
                        </button>
                        <div className="text-center">
                            <h1 className="text-3xl font-bold text-gray-900 mb-2">
                                Live Game Tracker
                            </h1>
                            <div className="text-lg text-gray-600">
                                {selectedTeam} vs {opponentName}
                            </div>
                            <div className="text-sm text-gray-500">
                                {selectedGame?.date} â€¢ {isHome ? 'Home' : 'Away'} Game
                            </div>
                        </div>
                    </div>

                    {/* Live Score Header - only show when metadata exists */}
                    {gameMetadata && (
                        <LiveScoreHeader 
                            gameMetadata={gameMetadata}
                            yourTeamName={selectedTeam}
                            opponentTeamName={opponentTeamName}
                            isHome={isHome}
                        />
                    )}

                    {/* Presence Indicator */}
                    {presenceUsers.length > 0 && (
                        <PresenceIndicator presenceUsers={presenceUsers} />
                    )}

                    {/* Viewer-Only Message */}
                    {!userCanTrack && (
                        <ViewerOnlyMessage />
                    )}

                    <div className="text-white p-5 rounded-xl mb-5 grid grid-cols-4 gap-4 text-center" style={{ background: 'linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%)' }}>
                        <div>
                            <div className="text-sm opacity-90">Inning</div>
                            <div className="text-2xl font-bold">
                                {(isHome && !gameState.isYourTeamBatting) || (!isHome && gameState.isYourTeamBatting) ? 'â–²' : 'â–¼'} {gameState.inning}
                            </div>
                            <div className="text-xs opacity-75 mt-1">
                                {gameState.isYourTeamBatting ? `${selectedTeam} Batting` : `${opponentName} Batting`}
                            </div>
                        </div>
                        <div>
                            <div className="text-sm opacity-90">Outs</div>
                            <div className="text-2xl font-bold">{gameState.outs}</div>
                        </div>
                        <div>
                            <div className="text-sm opacity-90">{selectedTeam}</div>
                            <div className="text-2xl font-bold">
                                {gameState.score.yourTeam}
                            </div>
                        </div>
                        <div>
                            <div className="text-sm opacity-90">{opponentName}</div>
                            <div className="text-2xl font-bold flex items-center justify-center gap-2">
                                {userCanTrack && (
                                    <button
                                        onClick={() => updateOpponentScore(-1)}
                                        disabled={gameState.score.opponent <= 0}
                                        className="w-9 h-9 rounded-full bg-white/20 hover:bg-white/30 disabled:opacity-30 disabled:cursor-not-allowed text-lg font-bold"
                                    >
                                        âˆ’
                                    </button>
                                )}
                                <span>{gameState.score.opponent}</span>
                                {userCanTrack && (
                                    <button
                                        onClick={() => updateOpponentScore(1)}
                                        className="w-9 h-9 rounded-full bg-white/20 hover:bg-white/30 text-lg font-bold"
                                    >
                                        +
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>

                    {inningOver && gameState.gameActive && !pendingPlay && (
                        <div className="bg-gradient-to-br from-amber-500 to-amber-600 text-white p-6 rounded-xl mb-5 text-center">
                            <div className="text-2xl font-bold mb-2">
                                3 Outs - Side Retired
                            </div>
                            {gameState.isYourTeamBatting ? (
                                <>
                                    <div className="text-base mb-2 opacity-95">
                                        {selectedTeam}'s half inning is complete
                                    </div>
                                    <div className="text-sm mb-5 opacity-90 italic">
                                        Opponent batting - click when {selectedTeam} is back at bat
                                    </div>
                                    <button
                                        onClick={advanceToNextHalfInning}
                                        className="px-8 py-5 sm:px-10 sm:py-4 text-lg font-bold border-none rounded-xl cursor-pointer bg-white text-amber-600 shadow-lg hover:shadow-xl active:shadow-md active:scale-95 transition-all"
                                    >
                                        {isHome ? `Top ${gameState.inning + 1} - ${opponentName} Batting` : `Bottom ${gameState.inning} - ${opponentName} Batting`}
                                    </button>
                                </>
                            ) : (
                                <>
                                    <div className="text-base mb-2 opacity-95">
                                        {opponentName}'s half inning is complete
                                    </div>
                                    <div className="text-sm mb-5 opacity-90 italic">
                                        Click below to start tracking {selectedTeam}'s at-bats
                                    </div>
                                    <button
                                        onClick={advanceToNextHalfInning}
                                        className="px-8 py-5 sm:px-10 sm:py-4 text-lg font-bold border-none rounded-xl cursor-pointer bg-white text-amber-600 shadow-lg hover:shadow-xl active:shadow-md active:scale-95 transition-all"
                                    >
                                        {isHome ? `Bottom ${gameState.inning} - ${selectedTeam} Batting` : `Top ${gameState.inning + 1} - ${selectedTeam} Batting`}
                                    </button>
                                </>
                            )}
                        </div>
                    )}

                    {!gameState.isYourTeamBatting && !inningOver && (
                        <div className="rounded-xl p-6 mb-5 text-center" style={{ background: '#f0fdf4', border: '2px solid #86efac' }}>
                            <div className="text-xl font-bold mb-2" style={{ color: '#166534' }}>
                                {opponentName} is Batting
                            </div>
                            <div className="text-base mb-4" style={{ color: '#15803d' }}>
                                Track their runs below, then click "Back at Bat" after 3 outs
                            </div>
                            
                            {userCanTrack && (
                                <div className="bg-white rounded-xl p-4 mb-4 inline-block">
                                    <div className="text-sm text-gray-600 mb-2">{opponentName} Runs</div>
                                    <div className="flex items-center justify-center gap-4">
                                        <button
                                            onClick={() => updateOpponentScore(-1)}
                                            disabled={gameState.score.opponent <= 0}
                                            className="w-14 h-14 rounded-full bg-red-100 hover:bg-red-200 active:bg-red-300 disabled:opacity-30 disabled:cursor-not-allowed text-2xl font-bold text-red-600 border-2 border-red-300"
                                        >
                                            âˆ’
                                        </button>
                                        <span className="text-5xl font-bold min-w-16 text-center" style={{ color: '#166534' }}>
                                            {gameState.score.opponent}
                                        </span>
                                        <button
                                            onClick={() => updateOpponentScore(1)}
                                            className="w-14 h-14 rounded-full bg-green-100 hover:bg-green-200 active:bg-green-300 text-2xl font-bold text-green-600 border-2 border-green-300"
                                        >
                                            +
                                        </button>
                                    </div>
                                </div>
                            )}
                            
                            <div>
                                <button
                                    onClick={advanceToNextHalfInning}
                                    className="px-6 py-4 sm:px-8 sm:py-3 text-lg font-bold border-none rounded-xl cursor-pointer text-white transition-all shadow-lg inline-flex items-center gap-2 hover:scale-105 active:scale-95"
                                    style={{ background: 'linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%)' }}
                                >
                                    <PlayCircle size={24} /> Back at Bat
                                </button>
                            </div>
                        </div>
                    )}

                    {pendingPlay && (
                        <div className="bg-amber-50 border-2 border-amber-400 rounded-lg p-4 mb-5 text-center">
                            <div className="font-bold mb-1 text-amber-900">
                                Adjust Base Runners
                            </div>
                            <div className="text-sm text-amber-800">
                                Use arrows â€¢ Drag runners to bases or home â€¢ Click X to mark runner out
                            </div>
                        </div>
                    )}

                    {gameState.isYourTeamBatting && (
                        <>
                            <div className="flex flex-col lg:flex-row gap-6 mb-8">
                                <div className={`relative w-full lg:max-w-lg bg-green-800 rounded-xl p-8 ${pendingPlay ? 'border-4 border-amber-400' : ''} ${inningOver && !pendingPlay ? 'opacity-50' : 'opacity-100'}`}>
                                <svg viewBox="0 0 400 400" className="w-full h-auto">
                                    <polygon 
                                        points="200,80 320,200 200,320 80,200" 
                                        fill="#8b4513"
                                        stroke="#fff"
                                        strokeWidth="3"
                                    />
                                    
                                    <circle 
                                        cx="200" 
                                        cy="320" 
                                        r="25" 
                                        fill={draggedRunner ? '#10b981' : '#fff'}
                                        onDragOver={handleDragOver}
                                        onDrop={() => handleDrop('home')}
                                        style={{ cursor: draggedRunner ? 'pointer' : 'default' }}
                                    />
                                    <text x="200" y="365" textAnchor="middle" fill="#fff" fontSize="14" fontWeight="bold">
                                        HOME
                                    </text>

                                    {['first', 'second', 'third'].map((base, idx) => {
                                        const positions = {
                                            first: { cx: 320, cy: 200, labelY: 165, arrowY: 240, arrow1X: 295, arrow2X: 345, removeY: 225, 
                                                    advanceArrow: 'â–²', backArrow: 'â–¼' },
                                            second: { cx: 200, cy: 80, labelY: 45, arrowY: 120, arrow1X: 175, arrow2X: 225, removeY: 105,
                                                     advanceArrow: 'â—€', backArrow: 'â–¶' },
                                            third: { cx: 80, cy: 200, labelY: 165, arrowY: 240, arrow1X: 55, arrow2X: 105, removeY: 225,
                                                    advanceArrow: 'â–¼', backArrow: 'â–²' }
                                        };
                                        const pos = positions[base];
                                        const baseLabel = base === 'first' ? '1B' : base === 'second' ? '2B' : '3B';

                                        return (
                                            <g key={base}>
                                                <circle 
                                                    cx={pos.cx} 
                                                    cy={pos.cy} 
                                                    r="32" 
                                                    fill={displayBases[base] ? '#fbbf24' : '#fff'} 
                                                    stroke="#000"
                                                    strokeWidth="2"
                                                    onDragOver={handleDragOver}
                                                    onDrop={() => handleDrop(base)}
                                                    style={{ cursor: draggedRunner ? 'pointer' : 'default' }}
                                                />
                                                <text x={pos.cx} y={pos.labelY} textAnchor="middle" fill="#fff" fontSize="12" fontWeight="bold">
                                                    {baseLabel}
                                                </text>
                                                {displayBases[base] && (
                                                    <g>
                                                        <text 
                                                            x={pos.cx} 
                                                            y={pos.cy + 5} 
                                                            textAnchor="middle" 
                                                            fill="#000" 
                                                            fontSize="11" 
                                                            fontWeight="bold"
                                                            style={{ cursor: pendingPlay ? 'move' : 'default' }}
                                                            draggable={pendingPlay}
                                                            onDragStart={() => handleDragStart(base)}
                                                        >
                                                            {displayBases[base].split(' ').pop()}
                                                        </text>
                                                        {pendingPlay && (
                                                            <>
                                                                <text 
                                                                    x={pos.arrow1X} y={pos.arrowY} 
                                                                    textAnchor="middle" 
                                                                    fill="#fff" 
                                                                    fontSize="18" 
                                                                    fontWeight="bold"
                                                                    style={{ cursor: 'pointer' }}
                                                                    onClick={() => adjustRunner(base, 'back')}
                                                                >
                                                                    {pos.backArrow}
                                                                </text>
                                                                <text 
                                                                    x={pos.arrow2X} y={pos.arrowY} 
                                                                    textAnchor="middle" 
                                                                    fill="#fff" 
                                                                    fontSize="18" 
                                                                    fontWeight="bold"
                                                                    style={{ cursor: 'pointer' }}
                                                                    onClick={() => adjustRunner(base, 'advance')}
                                                                >
                                                                    {pos.advanceArrow}
                                                                </text>
                                                                <circle
                                                                    cx={pos.cx}
                                                                    cy={pos.removeY}
                                                                    r="8"
                                                                    fill="#ef4444"
                                                                    style={{ cursor: 'pointer' }}
                                                                    onClick={() => removeRunner(base)}
                                                                />
                                                                <text
                                                                    x={pos.cx}
                                                                    y={pos.removeY + 4}
                                                                    textAnchor="middle"
                                                                    fill="white"
                                                                    fontSize="10"
                                                                    fontWeight="bold"
                                                                    style={{ pointerEvents: 'none' }}
                                                                >
                                                                    X
                                                                </text>
                                                            </>
                                                        )}
                                                    </g>
                                                )}
                                            </g>
                                        );
                                    })}
                                </svg>

                                {pendingPlay && (displayScore > 0 || tempOuts > 0) && (
                                    <div className="absolute bottom-3 left-1/2 -translate-x-1/2 flex gap-3 items-center">
                                        {displayScore > 0 && (
                                            <div className="bg-green-600 text-white px-4 py-2 rounded-lg font-bold">
                                                +{displayScore} Run{displayScore > 1 ? 's' : ''}
                                            </div>
                                        )}
                                        {tempOuts > 0 && (
                                            <div className="bg-red-500 text-white px-4 py-2 rounded-lg font-bold">
                                                +{tempOuts} Out{tempOuts > 1 ? 's' : ''}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            
                            <div className="bg-white border border-gray-200 rounded-xl p-4 flex-shrink-0" style={{ width: '300px' }}>
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="text-lg font-bold text-gray-800">
                                        {editingLineup ? 'Edit Lineup' : 'Live Batting Stats'}
                                    </h3>
                                    {userCanTrack && (
                                        <button
                                            onClick={() => setEditingLineup(!editingLineup)}
                                            className="text-xs px-3 py-1 rounded-full font-medium transition-all"
                                            style={editingLineup ? {
                                                background: '#dcfce7',
                                                color: '#166534'
                                            } : {
                                                background: '#f3f4f6',
                                                color: '#6b7280'
                                            }}
                                        >
                                            {editingLineup ? 'âœ“ Done' : 'âœï¸ Edit'}
                                        </button>
                                    )}
                                </div>
                                
                                <div className="space-y-1 max-h-80 overflow-y-auto">
                                    {liveBattingStats.map((stat, idx) => {
                                        const isCurrentBatter = idx === gameState.currentBatter;
                                        return (
                                            <div 
                                                key={stat.name}
                                                className="text-xs p-2 rounded"
                                                style={isCurrentBatter ? { 
                                                    background: '#f0fdf4', 
                                                    border: '2px solid #22c55e',
                                                    fontWeight: 'bold'
                                                } : { background: '#f9fafb' }}
                                            >
                                                {editingLineup ? (
                                                    /* Edit Mode */
                                                    <div className="flex items-center gap-2">
                                                        <div className="flex flex-col gap-1">
                                                            <button
                                                                onClick={() => movePlayerUp(idx)}
                                                                disabled={idx === 0}
                                                                className="w-7 h-6 flex items-center justify-center rounded bg-gray-200 hover:bg-gray-300 active:bg-gray-400 disabled:opacity-30 disabled:cursor-not-allowed text-xs"
                                                            >
                                                                â–²
                                                            </button>
                                                            <button
                                                                onClick={() => movePlayerDown(idx)}
                                                                disabled={idx === battingOrder.length - 1}
                                                                className="w-7 h-6 flex items-center justify-center rounded bg-gray-200 hover:bg-gray-300 active:bg-gray-400 disabled:opacity-30 disabled:cursor-not-allowed text-xs"
                                                            >
                                                                â–¼
                                                            </button>
                                                        </div>
                                                        <div className="flex-1">
                                                            <span className="text-gray-500 mr-1">{idx + 1}.</span>
                                                            <span className="font-semibold text-gray-900">{stat.name.split(' ').pop()}</span>
                                                            {isCurrentBatter && (
                                                                <span className="ml-1 text-green-600">â† Up</span>
                                                            )}
                                                        </div>
                                                        <button
                                                            onClick={() => removeFromLineup(idx)}
                                                            className="w-8 h-8 flex items-center justify-center rounded bg-red-100 hover:bg-red-200 active:bg-red-300 text-red-600 text-sm"
                                                            title="Remove from lineup"
                                                        >
                                                            âœ•
                                                        </button>
                                                    </div>
                                                ) : (
                                                    /* Stats Mode */
                                                    <>
                                                        <div className="flex items-center gap-1 mb-1">
                                                            <span className="text-gray-500">#{stat.number}</span>
                                                            <span className="font-semibold text-gray-900 truncate">{stat.name.split(' ').pop()}</span>
                                                        </div>
                                                        <div className="grid grid-cols-4 gap-1 text-center">
                                                            <div>
                                                                <div className="text-gray-500">AB</div>
                                                                <div className="font-bold">{stat.atBats}</div>
                                                            </div>
                                                            <div>
                                                                <div className="text-gray-500">H</div>
                                                                <div className="font-bold">{stat.hits}</div>
                                                            </div>
                                                            <div>
                                                                <div className="text-gray-500">R</div>
                                                                <div className="font-bold">{stat.runs}</div>
                                                            </div>
                                                            <div>
                                                                <div className="text-gray-500">BB</div>
                                                                <div className="font-bold">{stat.walks}</div>
                                                            </div>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                                
                                {/* Add Player Section - Only in Edit Mode */}
                                {editingLineup && availablePlayers.length > 0 && (
                                    <div className="mt-3 pt-3 border-t border-gray-200">
                                        <div className="text-xs font-semibold text-gray-600 mb-2">Add Player</div>
                                        <div className="space-y-1 max-h-32 overflow-y-auto">
                                            {availablePlayers.map(player => (
                                                <button
                                                    key={player.id}
                                                    onClick={() => addToLineup(player)}
                                                    className="w-full text-left text-xs p-2 rounded bg-blue-50 hover:bg-blue-100 transition-colors flex items-center justify-between"
                                                >
                                                    <span>
                                                        <span className="text-gray-500">#{player.number || '?'}</span>
                                                        <span className="ml-1 font-medium text-gray-800">{player.name}</span>
                                                    </span>
                                                    <span className="text-blue-600 font-bold">+</span>
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                
                                {editingLineup && availablePlayers.length === 0 && (
                                    <div className="mt-3 pt-3 border-t border-gray-200 text-xs text-gray-500 text-center">
                                        All rostered players are in lineup
                                    </div>
                                )}
                            </div>
                        </div>

                            {pendingPlay && (
                                <div className="flex gap-3 mb-5 justify-center flex-wrap">
                                    <button
                                        onClick={confirmPlay}
                                        className="px-6 py-5 sm:px-8 sm:py-4 text-lg font-bold border-none rounded-xl cursor-pointer bg-green-600 text-white hover:bg-green-700 active:bg-green-800 transition-colors inline-flex items-center gap-2"
                                    >
                                        <PlayCircle size={24} /> Confirm Play
                                    </button>
                                    <button
                                        onClick={cancelPlay}
                                        className="px-6 py-5 sm:px-8 sm:py-4 text-lg font-bold border-2 border-red-500 rounded-xl cursor-pointer bg-white text-red-500 hover:bg-red-50 active:bg-red-100 transition-colors"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            )}

                            <div className={`bg-gray-100 p-5 rounded-xl mb-5 text-center ${inningOver ? 'opacity-40' : 'opacity-100'}`}>
                                <div className="text-sm text-gray-600 mb-1">Now Batting</div>
                                <div className="text-2xl font-bold text-gray-900">
                                    #{currentBatter?.number} {currentBatter?.name}
                                </div>
                                <div className="text-base text-gray-600">{currentBatter?.position}</div>
                            </div>

                            {userCanTrack && gameState.gameActive && !pendingPlay && (
                                <div className={`grid grid-cols-3 sm:grid-cols-4 gap-2 sm:gap-3 mb-8 ${inningOver ? 'opacity-30 pointer-events-none' : ''}`}>
                                    {PLAY_TYPES.map(play => (
                                        <button
                                            key={play.value}
                                            onClick={() => initiatePlay(play.value)}
                                            disabled={inningOver}
                                            className={`py-5 px-3 sm:p-4 text-lg sm:text-base font-bold border-none rounded-xl cursor-pointer text-white transition-transform hover:scale-105 active:scale-95 ${
                                                play.isHit ? 'bg-green-600 hover:bg-green-700' : 
                                                play.isOut ? 'bg-red-500 hover:bg-red-600' : 
                                                'bg-blue-500 hover:bg-blue-600'
                                            }`}
                                        >
                                            {play.label}
                                        </button>
                                    ))}
                                </div>
                            )}
                        </>
                    )}

                    {!pendingPlay && (
                        <div className="flex gap-3 mb-8 justify-center flex-wrap">
                            <button
                                onClick={undoLastPlay}
                                disabled={gameState.playHistory.length === 0}
                                className={`px-5 py-4 sm:px-6 sm:py-3 border-none rounded-xl inline-flex items-center gap-2 text-base sm:text-sm ${
                                    gameState.playHistory.length === 0 
                                        ? 'bg-gray-300 cursor-not-allowed opacity-50' 
                                        : 'bg-gray-600 cursor-pointer hover:bg-gray-700 active:bg-gray-800'
                                } text-white transition-colors`}
                            >
                                <Undo2 size={20} /> Undo
                            </button>
                            
                            {gameState.gameActive && (
                                <>
                                    <button
                                        onClick={endGame}
                                        className="px-5 py-4 sm:px-6 sm:py-3 border-none rounded-xl cursor-pointer bg-red-600 text-white hover:bg-red-700 active:bg-red-800 transition-colors inline-flex items-center gap-2 text-base sm:text-sm"
                                    >
                                        <Save size={20} /> End Game
                                    </button>
                                    
                                    <button
                                        onClick={clearProgress}
                                        className="px-5 py-4 sm:px-6 sm:py-3 border-none rounded-xl cursor-pointer bg-orange-600 text-white hover:bg-orange-700 active:bg-orange-800 transition-colors inline-flex items-center gap-2 text-base sm:text-sm"
                                    >
                                        <AlertCircle size={20} /> Clear
                                    </button>
                                </>
                            )}
                        </div>
                    )}

                    {/* Lineup Manager - Always visible for trackers */}
                    {userCanTrack && (
                        <div className="bg-white border border-gray-200 rounded-xl p-4 mb-6">
                            <div 
                                className="flex items-center justify-between cursor-pointer"
                                onClick={() => setEditingLineup(!editingLineup)}
                            >
                                <h3 className="text-lg font-bold text-gray-800">
                                    ðŸ“‹ Lineup ({battingOrder.length} players)
                                </h3>
                                <button
                                    className="text-sm px-3 py-1 rounded-full font-medium transition-all"
                                    style={editingLineup ? {
                                        background: '#dcfce7',
                                        color: '#166534'
                                    } : {
                                        background: '#f3f4f6',
                                        color: '#6b7280'
                                    }}
                                >
                                    {editingLineup ? 'â–¼ Close' : 'â–¶ Edit Lineup'}
                                </button>
                            </div>
                            
                            {editingLineup && (
                                <div className="mt-4 pt-4 border-t border-gray-200">
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        {/* Current Lineup */}
                                        <div>
                                            <div className="text-sm font-semibold text-gray-600 mb-2">Batting Order</div>
                                            <div className="space-y-1 max-h-64 overflow-y-auto">
                                                {battingOrder.map((player, idx) => {
                                                    const isCurrentBatter = idx === gameState.currentBatter;
                                                    return (
                                                        <div 
                                                            key={player.id}
                                                            className="text-sm p-2 rounded flex items-center gap-2"
                                                            style={isCurrentBatter ? { 
                                                                background: '#f0fdf4', 
                                                                border: '2px solid #22c55e'
                                                            } : { background: '#f9fafb' }}
                                                        >
                                                            <div className="flex flex-col gap-1">
                                                                <button
                                                                    onClick={() => movePlayerUp(idx)}
                                                                    disabled={idx === 0}
                                                                    className="w-8 h-7 flex items-center justify-center rounded bg-gray-200 hover:bg-gray-300 active:bg-gray-400 disabled:opacity-30 disabled:cursor-not-allowed text-sm"
                                                                >
                                                                    â–²
                                                                </button>
                                                                <button
                                                                    onClick={() => movePlayerDown(idx)}
                                                                    disabled={idx === battingOrder.length - 1}
                                                                    className="w-8 h-7 flex items-center justify-center rounded bg-gray-200 hover:bg-gray-300 active:bg-gray-400 disabled:opacity-30 disabled:cursor-not-allowed text-sm"
                                                                >
                                                                    â–¼
                                                                </button>
                                                            </div>
                                                            <div className="flex-1">
                                                                <span className="font-bold text-gray-500 mr-2">{idx + 1}.</span>
                                                                <span className="font-semibold text-gray-900">{player.name}</span>
                                                                {isCurrentBatter && (
                                                                    <span className="ml-2 text-xs px-2 py-0.5 rounded-full bg-green-100 text-green-700">Up Now</span>
                                                                )}
                                                            </div>
                                                            <button
                                                                onClick={() => removeFromLineup(idx)}
                                                                className="w-9 h-9 flex items-center justify-center rounded bg-red-100 hover:bg-red-200 active:bg-red-300 text-red-600 text-base"
                                                                title="Remove from lineup"
                                                            >
                                                                âœ•
                                                            </button>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                        
                                        {/* Available Players */}
                                        <div>
                                            <div className="text-sm font-semibold text-gray-600 mb-2">
                                                Add Player {availablePlayers.length > 0 && `(${availablePlayers.length} available)`}
                                            </div>
                                            {availablePlayers.length > 0 ? (
                                                <div className="space-y-2 max-h-64 overflow-y-auto">
                                                    {availablePlayers.map(player => (
                                                        <button
                                                            key={player.id}
                                                            onClick={() => addToLineup(player)}
                                                            className="w-full text-left text-sm p-3 rounded-lg bg-blue-50 hover:bg-blue-100 active:bg-blue-200 transition-colors flex items-center justify-between"
                                                        >
                                                            <span>
                                                                <span className="text-gray-500">#{player.number || '?'}</span>
                                                                <span className="ml-2 font-medium text-gray-800">{player.name}</span>
                                                            </span>
                                                            <span className="text-blue-600 font-bold text-xl">+</span>
                                                        </button>
                                                    ))}
                                                </div>
                                            ) : (
                                                <div className="text-sm text-gray-500 text-center py-4 bg-gray-50 rounded">
                                                    All rostered players are in lineup
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {/* Merged Play-by-Play */}
                    <MergedPlayByPlay
                        yourPlays={gameState.playHistory}
                        opponentPlays={opponentGameState?.playHistory || []}
                        yourTeamName={selectedTeam}
                        opponentName={opponentTeamName}
                    />
                </div>
                </>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GameTracker />);
		
		
function updateConnectionStatus() {
  const status = document.getElementById('connectionStatus');
  if (!status) return;
  
  const icon = status.querySelector('.status-icon');
  const text = status.querySelector('.status-text');
  
  if (navigator.onLine) {
    // Show "Back online" message
    status.classList.remove('hidden');  // SHOW IT FIRST
    status.classList.add('online');
    icon.textContent = 'âœ…';
    text.textContent = 'Back online';
    
    // Hide after 3 seconds
    setTimeout(() => {
      status.classList.add('hidden');
    }, 3000);
  } else {
    // Show "You're offline" message
    status.classList.remove('hidden', 'online');
    icon.textContent = 'ðŸ“¡';
    text.textContent = "You're offline";
  }
}

window.addEventListener('online', updateConnectionStatus);
window.addEventListener('offline', updateConnectionStatus);
if (!navigator.onLine) updateConnectionStatus();
    </script>
	<script type="module" src="offline-queue.js"></script>
	<script src="theme-toggle.js"></script>
</body>
</html>
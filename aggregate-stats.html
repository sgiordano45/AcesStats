<!DOCTYPE html>
<html lang="en">
<head>
<link rel="manifest" href="/manifest.json">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stats Aggregator - Mountainside Aces Admin</title>
<meta name="theme-color" content="#6b21a8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
  :root {
    --primary-color: #2d5016;
    --secondary-color: #1a6b4a;
    --accent-color: #ffd700;
    --admin-color: #6b21a8;
    --admin-secondary: #7c3aed;
    --card-bg: #ffffff;
    --text-dark: #2d3748;
    --text-light: #718096;
    --border-color: #e2e8f0;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
    --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
    --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
    --success-color: #22c55e;
    --warning-color: #f59e0b;
    --danger-color: #ef4444;
    --2025-color: #0891b2;
    --2025-secondary: #06b6d4;
  }

  * { box-sizing: border-box; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    min-height: 100vh;
    color: var(--text-dark);
  }

  /* Loading Overlay */
  .loading-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(255,255,255,0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    transition: opacity 0.5s ease;
  }

  .loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .loading-spinner::before {
    content: 'üìä';
    font-size: 80px;
    animation: pulse 1.5s ease-in-out infinite;
  }

  .loading-text {
    margin-top: 1rem;
    color: var(--text-light);
    font-size: 1.1rem;
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.1); opacity: 0.8; }
  }

  /* Auth Gate */
  .auth-gate {
    display: none;
    max-width: 500px;
    margin: 4rem auto;
    padding: 3rem;
    background: var(--card-bg);
    border-radius: 16px;
    box-shadow: var(--shadow-lg);
    text-align: center;
  }

  .auth-gate.visible {
    display: block;
  }

  .auth-gate h2 {
    color: var(--danger-color);
    margin-bottom: 1rem;
  }

  .auth-gate p {
    color: var(--text-light);
    margin-bottom: 2rem;
  }

  .auth-gate a {
    display: inline-block;
    padding: 0.75rem 2rem;
    background: var(--admin-color);
    color: white;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 600;
    margin: 0.5rem;
  }

  /* Header */
  .header {
    background: linear-gradient(135deg, var(--admin-color) 0%, var(--admin-secondary) 100%);
    color: white;
    padding: 2rem 2rem;
    box-shadow: var(--shadow-lg);
    position: relative;
    overflow: hidden;
  }

  .header::before {
    content: '';
    position: absolute;
    top: -100px;
    right: -100px;
    width: 300px;
    height: 300px;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }

  .header::after {
    content: 'üìä';
    position: absolute;
    bottom: -40px;
    left: -30px;
    font-size: 180px;
    opacity: 0.08;
  }

  .header-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
    z-index: 1;
  }

  .header h1 {
    margin: 0;
    font-size: 1.75rem;
    font-weight: 800;
    margin-bottom: 0.25rem;
  }

  .header p {
    margin: 0;
    opacity: 0.9;
    font-size: 0.95rem;
  }

  .admin-badge {
    display: inline-block;
    background: rgba(255,255,255,0.2);
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    font-size: 0.85rem;
    margin-top: 0.5rem;
  }

  .header-buttons {
    display: flex;
    gap: 0.75rem;
  }

  .nav-btn {
    padding: 0.75rem 1.25rem;
    border: 2px solid white;
    background: white;
    color: var(--admin-color);
    border-radius: 10px;
    font-weight: 600;
    font-size: 0.9rem;
    cursor: pointer;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    transition: all 0.3s ease;
  }

  .nav-btn:hover {
    background: var(--accent-color);
    transform: translateY(-2px);
  }

  /* Main Container */
  .main-content {
    display: none;
  }

  .main-content.visible {
    display: block;
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }

  /* Info Boxes */
  .new-box, .success-box, .info-box, .warning-box, .splits-box {
    padding: 1.25rem;
    border-radius: 12px;
    margin-bottom: 1.5rem;
  }

  .new-box {
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    border: 2px solid #3b82f6;
  }

  .success-box {
    background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
    border: 2px solid var(--success-color);
  }

  .info-box {
    background: #f1f5f9;
    border: 1px solid var(--border-color);
  }

  .warning-box {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    border: 2px solid var(--warning-color);
  }

  .splits-box {
    background: linear-gradient(135deg, #cffafe 0%, #a5f3fc 100%);
    border: 2px solid var(--2025-color);
  }

  .new-box ul, .success-box ul, .splits-box ul {
    margin: 0.75rem 0 0 0;
    padding-left: 1.5rem;
  }

  .new-box li, .success-box li, .splits-box li {
    margin: 0.5rem 0;
  }

  /* Section Cards */
  .section {
    background: var(--card-bg);
    border-radius: 16px;
    box-shadow: var(--shadow-md);
    margin-bottom: 2rem;
    overflow: hidden;
    border: 1px solid var(--border-color);
  }

  .section-header {
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    padding: 1.25rem 1.5rem;
    font-size: 1.15rem;
    font-weight: 700;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .section-header.splits-header {
    background: linear-gradient(135deg, #ecfeff 0%, #cffafe 100%);
    border-bottom-color: var(--2025-color);
  }

  .section-content {
    padding: 1.5rem;
  }

  /* Buttons */
  button {
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    font-size: 0.95rem;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
  }

  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .btn-primary {
    background: var(--admin-color);
    color: white;
  }

  .btn-primary:hover:not(:disabled) {
    background: var(--admin-secondary);
    transform: translateY(-1px);
  }

  .btn-success {
    background: var(--success-color);
    color: white;
  }

  .btn-success:hover:not(:disabled) {
    background: #16a34a;
    transform: translateY(-1px);
  }

  .btn-secondary {
    background: #64748b;
    color: white;
  }

  .btn-secondary:hover:not(:disabled) {
    background: #475569;
  }

  .btn-warning {
    background: var(--warning-color);
    color: white;
  }

  .btn-warning:hover:not(:disabled) {
    background: #d97706;
  }

  .btn-2025 {
    background: var(--2025-color);
    color: white;
  }

  .btn-2025:hover:not(:disabled) {
    background: var(--2025-secondary);
    transform: translateY(-1px);
  }

  /* Form Elements */
  select {
    padding: 0.75rem 1rem;
    font-size: 1rem;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    min-width: 200px;
    background: white;
    cursor: pointer;
    transition: border-color 0.2s;
  }

  select:focus {
    outline: none;
    border-color: var(--admin-color);
  }

  .flex-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  /* Stats Grid */
  .stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 1rem;
    margin: 1.5rem 0;
  }

  .stat-card {
    background: #f8fafc;
    padding: 1.25rem;
    border-radius: 12px;
    text-align: center;
    border: 1px solid var(--border-color);
  }

  .stat-number {
    font-size: 2rem;
    font-weight: 800;
    color: var(--admin-color);
  }

  .stat-number.green {
    color: var(--success-color);
  }

  .stat-number.orange {
    color: var(--warning-color);
  }

  .stat-number.blue {
    color: #3b82f6;
  }

  .stat-number.cyan {
    color: var(--2025-color);
  }

  .stat-label {
    font-size: 0.8rem;
    color: var(--text-light);
    margin-top: 0.25rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* Console Output */
  #output {
    background: #1e293b;
    color: #a5f3fc;
    padding: 1.5rem;
    border-radius: 12px;
    max-height: 500px;
    overflow-y: auto;
    font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.7;
    white-space: pre-wrap;
    margin-top: 1.5rem;
    border: 1px solid #334155;
  }

  #output::-webkit-scrollbar {
    width: 8px;
  }

  #output::-webkit-scrollbar-track {
    background: #334155;
    border-radius: 4px;
  }

  #output::-webkit-scrollbar-thumb {
    background: #64748b;
    border-radius: 4px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .header {
      padding: 1.5rem 1rem;
    }

    .header h1 {
      font-size: 1.4rem;
    }

    .header-content {
      flex-direction: column;
      text-align: center;
      gap: 1rem;
    }

    .header-buttons {
      width: 100%;
      justify-content: center;
    }

    .flex-row {
      flex-direction: column;
      align-items: stretch;
    }

    select {
      width: 100%;
    }

    button {
      width: 100%;
      justify-content: center;
    }
  }
</style>
</head>
<body>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="loading-spinner"></div>
  <div class="loading-text">Checking permissions...</div>
</div>

<!-- Auth Gate (shown if not authorized) -->
<div class="auth-gate" id="authGate">
  <h2>üîí Admin Access Required</h2>
  <p>You need admin or league staff permissions to access the Stats Aggregator.</p>
  <a href="signin.html">Sign In</a>
  <a href="index.html" style="background: var(--primary-color);">Back to Home</a>
</div>

<!-- Main Content (shown if authorized) -->
<div class="main-content" id="mainContent">
  
  <!-- Header -->
  <header class="header">
    <div class="header-content">
      <div>
        <h1>üìä Stats Aggregator</h1>
        <p>Aggregate game-level stats into season and career totals</p>
        <span class="admin-badge">üîí Admin Tool</span>
      </div>
      <div class="header-buttons">
        <a href="admin-content.html" class="nav-btn">
          ‚Üê Back to Admin
        </a>
        <a href="index.html" class="nav-btn">
          üè† Home
        </a>
      </div>
    </div>
  </header>

  <div class="container">
    
    <!-- Info Boxes -->
    <div class="new-box">
      <strong>üÜï Game-Level Stats Support</strong>
      <ul>
        <li><strong>2025 Seasons (partial data):</strong> Splits saved to separate collection - does NOT affect production stats</li>
        <li><strong>2026-summer and beyond:</strong> Full aggregation to production (acesBPI, career totals)</li>
        <li><strong>Career totals:</strong> Only recalculated for 2026+ aggregation</li>
      </ul>
    </div>

    <div class="success-box">
      <strong>‚úÖ No Duplicates - Hybrid Approach</strong>
      <ul>
        <li><strong>Auth users:</strong> Aggregates from their linked player stats</li>
        <li><strong>Legacy players:</strong> Aggregates normally (not migrated)</li>
        <li><strong>Migrated profiles:</strong> Skipped (prevents duplicates)</li>
      </ul>
    </div>

    <!-- Section 0: 2025 Splits-Only Aggregation (NEW) -->
    <div class="section">
      <div class="section-header splits-header">
        üìà 2025 Splits Aggregation (Partial Data)
      </div>
      <div class="section-content">
        
        <div class="splits-box">
          <strong>‚ÑπÔ∏è About 2025 Splits Data</strong>
          <ul>
            <li>Game-level data for 2025 seasons is <strong>incomplete</strong> (only some teams/players)</li>
            <li>Splits data is stored in a <strong>separate collection</strong>: <code>aggregatedPlayerStats2025Splits</code></li>
            <li>This does <strong>NOT</strong> modify production stats, acesBPI, or career totals</li>
            <li>Player-splits page will load from this collection for 2025 seasons</li>
          </ul>
        </div>

        <p>Aggregate available 2025 game data into splits-only collection:</p>
        
        <div class="flex-row">
          <select id="season2025Select">
            <option value="">-- Select 2025 Season --</option>
            <option value="2025-summer">2025 Summer (Partial)</option>
            <option value="2025-fall">2025 Fall (Partial)</option>
          </select>
          <button id="preview2025Btn" class="btn-success" onclick="preview2025Splits()">
            üëÅÔ∏è Preview
          </button>
          <button id="aggregate2025Btn" class="btn-2025" onclick="aggregate2025Splits()">
            üìà Aggregate 2025 Splits
          </button>
        </div>

        <div class="info-box" style="margin-top: 1rem;">
          <strong>üí° Tip:</strong> This only creates/updates split data (home/away, playoff/regular, vs opponent). 
          Production acesBPI and career stats remain unchanged.
        </div>
        
        <div class="stats" id="splits2025StatsDisplay" style="display: none;">
          <div class="stat-card">
            <div class="stat-number cyan" id="splits2025Players">0</div>
            <div class="stat-label">Players Found</div>
          </div>
          <div class="stat-card">
            <div class="stat-number blue" id="splits2025Games">0</div>
            <div class="stat-label">Games Processed</div>
          </div>
          <div class="stat-card">
            <div class="stat-number green" id="splits2025Updated">0</div>
            <div class="stat-label">Players Updated</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Section 1: Aggregate Game-Based Season (2026+) -->
    <div class="section">
      <div class="section-header">
        üéÆ Step 1: Aggregate Game-Level Stats (2026+)
      </div>
      <div class="section-content">
        
        <!-- Test Mode Banner (hidden by default) -->
        <div id="testModeBanner" style="
          display: none;
          background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
          border: 2px solid #f59e0b;
          border-radius: 8px;
          padding: 1rem;
          margin-bottom: 1.5rem;
          align-items: center;
          gap: 0.75rem;
        ">
          <span style="font-size: 1.5rem;">üß™</span>
          <div>
            <div style="font-weight: 700; color: #92400e;">TEST MODE ACTIVE</div>
            <div style="color: #b45309; font-size: 0.9rem;">
              Data will be written to <code style="background: rgba(0,0,0,0.1); padding: 0.1rem 0.3rem; border-radius: 3px;">aggregatedPlayerStats_test</code> ‚Äî production data is safe!
            </div>
          </div>
        </div>

        <p>Select a season that uses game-level stats collection:</p>
        
        <div class="flex-row">
          <select id="seasonSelect">
            <option value="">-- Select Season --</option>
            <option value="2026-summer">2026 Summer</option>
            <option value="2026-fall">2026 Fall</option>
            <option value="2027-summer">2027 Summer</option>
            <option value="2027-fall">2027 Fall</option>
          </select>
          <button id="previewSeasonBtn" class="btn-success" onclick="previewGameBasedSeason()">
            üëÅÔ∏è Preview
          </button>
          <button id="aggregateSeasonBtn" class="btn-primary" onclick="aggregateGameBasedSeason()">
            üéÆ Aggregate Season
          </button>
        </div>
        
        <!-- Test Mode Toggle -->
        <div style="
          margin-top: 1rem;
          padding: 1rem;
          background: #fffbeb;
          border: 2px solid #fcd34d;
          border-radius: 8px;
          display: flex;
          align-items: center;
          gap: 0.75rem;
        ">
          <input type="checkbox" id="testModeCheckbox" style="
            width: 20px;
            height: 20px;
            cursor: pointer;
          " onchange="toggleTestMode()">
          <label for="testModeCheckbox" style="cursor: pointer; flex: 1;">
            <strong style="color: #92400e;">üß™ Test Mode</strong>
            <span style="color: #b45309; font-size: 0.9rem; display: block;">
              Write to <code>aggregatedPlayerStats_test</code> instead of production.
            </span>
          </label>
        </div>

        <div class="info-box" style="margin-top: 1rem;">
          <strong>üí° Tip:</strong> Use "Preview" first to see what will be aggregated without making any changes.
        </div>
        
        <div class="stats" id="seasonStatsDisplay" style="display: none;">
          <div class="stat-card">
            <div class="stat-number" id="playersWithGames">0</div>
            <div class="stat-label">Players Found</div>
          </div>
          <div class="stat-card">
            <div class="stat-number blue" id="totalGamesProcessed">0</div>
            <div class="stat-label">Games Processed</div>
          </div>
          <div class="stat-card">
            <div class="stat-number green" id="battingUpdated">0</div>
            <div class="stat-label">Batting Updated</div>
          </div>
          <div class="stat-card">
            <div class="stat-number orange" id="pitchingUpdated">0</div>
            <div class="stat-label">Pitching Updated</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Section 2: Full Career Recalculation -->
    <div class="section">
      <div class="section-header">
        üîÑ Step 2: Career Recalculation (Optional)
      </div>
      <div class="section-content">
        <p>Recalculates career totals from ALL seasons (historical + game-based). Only needed if data gets out of sync.</p>
        
        <div class="flex-row">
          <button id="aggregateBtn" class="btn-warning" onclick="runFullAggregation()">
            üöÄ Recalculate All Careers
          </button>
          <button id="verifyBtn" class="btn-success" onclick="verifyAggregation()">
            ‚úì Verify Collection
          </button>
          <button onclick="clearOutput()" class="btn-secondary">
            Clear Output
          </button>
        </div>

        <div class="stats" id="fullStatsDisplay" style="display: none;">
          <div class="stat-card">
            <div class="stat-number" id="playersProcessed">0</div>
            <div class="stat-label">Processed</div>
          </div>
          <div class="stat-card">
            <div class="stat-number blue" id="legacyCount">0</div>
            <div class="stat-label">Legacy</div>
          </div>
          <div class="stat-card">
            <div class="stat-number green" id="authCount">0</div>
            <div class="stat-label">Auth Users</div>
          </div>
          <div class="stat-card">
            <div class="stat-number orange" id="skippedCount">0</div>
            <div class="stat-label">Skipped</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="errorCount" style="color: var(--danger-color);">0</div>
            <div class="stat-label">Errors</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Console Output -->
    <div id="output">Initializing...</div>

  </div>
</div>

<!-- Firebase Auth Script -->
<script type="module">
  import { auth } from './firebase-auth.js';
  import { db } from './firebase-config.js';
  import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
  import {
    collection,
    collectionGroup,
    doc,
    getDocs,
    getDoc,
    setDoc,
    updateDoc,
    query,
    where
  } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

  // Make functions globally available
  window.db = db;
  window.collection = collection;
  window.collectionGroup = collectionGroup;
  window.doc = doc;
  window.getDocs = getDocs;
  window.getDoc = getDoc;
  window.setDoc = setDoc;
  window.updateDoc = updateDoc;
  window.query = query;
  window.where = where;

  // Seasons that use game-level stats (full aggregation to production)
  const GAME_BASED_SEASONS = ['2026-summer', '2026-fall', '2027-summer', '2027-fall'];
  
  // 2025 seasons (splits only, separate collection)
  const SPLITS_ONLY_SEASONS = ['2025-summer', '2025-fall'];
  
  // Collection for 2025 splits data
  const SPLITS_2025_COLLECTION = 'aggregatedPlayerStats2025Splits';

  // Test mode state
  let testModeEnabled = false;

  // Get the appropriate collection name based on test mode
  function getAggregatedCollection() {
    return testModeEnabled ? 'aggregatedPlayerStats_test' : 'aggregatedPlayerStats';
  }

  // Toggle test mode
  window.toggleTestMode = function() {
    testModeEnabled = document.getElementById('testModeCheckbox').checked;
    const banner = document.getElementById('testModeBanner');
    
    if (testModeEnabled) {
      banner.style.display = 'flex';
      log('');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('üß™ TEST MODE ENABLED', 'header');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('Data will be written to: aggregatedPlayerStats_test');
      log('Production data (aggregatedPlayerStats) will NOT be modified.');
      log('');
    } else {
      banner.style.display = 'none';
      log('');
      log('üî¥ Test mode disabled - using production collection');
      log('');
    }
  };

  // ============================================
  // AUTH CHECK
  // ============================================
  
  onAuthStateChanged(auth, async (user) => {
    const loadingOverlay = document.getElementById('loadingOverlay');
    const authGate = document.getElementById('authGate');
    const mainContent = document.getElementById('mainContent');
    
    if (!user) {
      // Not signed in
      loadingOverlay.classList.add('hidden');
      authGate.classList.add('visible');
      return;
    }

    try {
      // Check user role in Firestore
      const userDoc = await getDoc(doc(db, 'users', user.uid));
      
      if (!userDoc.exists()) {
        loadingOverlay.classList.add('hidden');
        authGate.classList.add('visible');
        authGate.querySelector('h2').textContent = 'üîí Profile Not Found';
        authGate.querySelector('p').textContent = 'Your user profile was not found. Please contact an administrator.';
        return;
      }

      const userData = userDoc.data();
      const userRole = (userData.userRole || userData.role || '').toLowerCase();
      
      // Check if admin or league-staff
      if (userRole === 'admin' || userRole === 'league-staff') {
        // Authorized!
        loadingOverlay.classList.add('hidden');
        mainContent.classList.add('visible');
        log(`‚úì Welcome, ${userData.displayName || userData.name || user.email}!`);
        log(`‚úì Role: ${userRole}`);
        log(`‚úì 2025 splits seasons: ${SPLITS_ONLY_SEASONS.join(', ')}`);
        log(`‚úì Full aggregation seasons: ${GAME_BASED_SEASONS.join(', ')}`);
        log('');
        log('Ready to aggregate stats. Select a season and click Preview or Aggregate.');
      } else {
        // Not authorized
        loadingOverlay.classList.add('hidden');
        authGate.classList.add('visible');
        authGate.querySelector('p').textContent = `Your role (${userRole || 'none'}) does not have access to this tool. Admin or league-staff required.`;
      }
      
    } catch (error) {
      console.error('Error checking permissions:', error);
      loadingOverlay.classList.add('hidden');
      authGate.classList.add('visible');
      authGate.querySelector('p').textContent = 'Error checking permissions. Please try again.';
    }
  });

  // ============================================
  // UTILITY FUNCTIONS
  // ============================================

  function log(message, type = 'info') {
    const output = document.getElementById('output');
    const timestamp = new Date().toLocaleTimeString();
    let prefix = '‚óÜ';
    
    if (type === 'success') prefix = '‚úì';
    if (type === 'error') prefix = '‚úó';
    if (type === 'header') prefix = '‚ïê‚ïê‚ïê';
    if (type === 'auth') prefix = 'üîê';
    if (type === 'legacy') prefix = 'üìÅ';
    if (type === 'skip') prefix = '‚è≠Ô∏è';
    if (type === 'game') prefix = 'üéÆ';
    if (type === 'pitching') prefix = '‚öæ';
    if (type === 'splits') prefix = 'üìà';
    
    const line = `[${timestamp}] ${prefix} ${message}\n`;
    output.textContent += line;
    output.scrollTop = output.scrollHeight;
  }
  window.log = log;

  function updateSeasonStats(players, games, batting, pitching) {
    document.getElementById('seasonStatsDisplay').style.display = 'grid';
    document.getElementById('playersWithGames').textContent = players;
    document.getElementById('totalGamesProcessed').textContent = games;
    document.getElementById('battingUpdated').textContent = batting;
    document.getElementById('pitchingUpdated').textContent = pitching;
  }
  window.updateSeasonStats = updateSeasonStats;

  function update2025SplitsStats(players, games, updated) {
    document.getElementById('splits2025StatsDisplay').style.display = 'grid';
    document.getElementById('splits2025Players').textContent = players;
    document.getElementById('splits2025Games').textContent = games;
    document.getElementById('splits2025Updated').textContent = updated;
  }
  window.update2025SplitsStats = update2025SplitsStats;

  function updateFullStats(processed, legacy, auth, skipped, errors) {
    document.getElementById('fullStatsDisplay').style.display = 'grid';
    document.getElementById('playersProcessed').textContent = processed;
    document.getElementById('legacyCount').textContent = legacy;
    document.getElementById('authCount').textContent = auth;
    document.getElementById('skippedCount').textContent = skipped;
    document.getElementById('errorCount').textContent = errors;
  }
  window.updateFullStats = updateFullStats;

  window.clearOutput = function() {
    document.getElementById('output').textContent = 'Output cleared. Ready for new operations.\n';
    document.getElementById('seasonStatsDisplay').style.display = 'none';
    document.getElementById('fullStatsDisplay').style.display = 'none';
    document.getElementById('splits2025StatsDisplay').style.display = 'none';
  };

  // ============================================
  // 2025 SPLITS-ONLY AGGREGATION (NEW)
  // ============================================

  window.preview2025Splits = async function() {
    const seasonId = document.getElementById('season2025Select').value;
    if (!seasonId) {
      alert('Please select a 2025 season first');
      return;
    }

    const btn = document.getElementById('preview2025Btn');
    btn.disabled = true;
    btn.textContent = '‚è≥ Loading...';

    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
    log(`PREVIEW: 2025 Splits for ${seasonId}`, 'header');
    log('‚ö†Ô∏è  NO CHANGES WILL BE MADE TO DATABASE', 'header');
    log(`üìà Target collection: ${SPLITS_2025_COLLECTION}`, 'header');
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');

    try {
      const result = await gatherSplitsData(seasonId);
      
      log('');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('PREVIEW COMPLETE', 'header');
      log(`Found ${result.playerCount} players with ${result.totalGames} total games`, 'success');
      log('No changes were made. Click "Aggregate 2025 Splits" to save.', 'splits');
      
      update2025SplitsStats(result.playerCount, result.totalGames, 0);
      
    } catch (error) {
      log(`Fatal error: ${error.message}`, 'error');
      console.error('Preview error:', error);
    } finally {
      btn.disabled = false;
      btn.textContent = 'üëÅÔ∏è Preview';
    }
  };

  window.aggregate2025Splits = async function() {
    const seasonId = document.getElementById('season2025Select').value;
    if (!seasonId) {
      alert('Please select a 2025 season first');
      return;
    }

    const confirmed = confirm(
      `This will aggregate splits data for ${seasonId} into:\n\n` +
      `üìà ${SPLITS_2025_COLLECTION}\n\n` +
      `‚ö†Ô∏è This data is PARTIAL and does NOT include all players.\n` +
      `‚úÖ Production stats (acesBPI, career) will NOT be modified.\n\n` +
      `Continue?`
    );
    if (!confirmed) return;

    const btn = document.getElementById('aggregate2025Btn');
    btn.disabled = true;
    btn.textContent = '‚è≥ Processing...';

    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
    log(`Aggregating 2025 Splits for ${seasonId}`, 'header');
    log(`üìà Target collection: ${SPLITS_2025_COLLECTION}`, 'header');
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');

    try {
      // Step 1: Gather splits data
      const result = await gatherSplitsData(seasonId);
      
      // Step 2: Save to 2025 splits collection
      log('');
      log('Saving splits data...', 'splits');
      
      let savedCount = 0;
      let errorCount = 0;
      
      for (const [legacyId, playerData] of result.playerSplits) {
        try {
          const docRef = window.doc(window.db, SPLITS_2025_COLLECTION, legacyId);
          const existingDoc = await window.getDoc(docRef);
          const existingData = existingDoc.exists() ? existingDoc.data() : {};
          
          // Merge seasons
          const existingSeasons = existingData.seasons || {};
          existingSeasons[seasonId] = playerData.seasonSplits;
          
          // Calculate career splits from all 2025 seasons in this collection
          const careerSplits = calculate2025CareerSplits(existingSeasons);
          
          await window.setDoc(docRef, {
            name: playerData.playerName,
            seasons: existingSeasons,
            careerSplits: careerSplits,
            lastUpdated: new Date(),
            dataNote: 'Partial game data - not all games/players included'
          }, { merge: true });
          
          savedCount++;
          log(`  ‚úì ${playerData.playerName}: ${playerData.games} games, ${Object.keys(playerData.seasonSplits.vsOpponent || {}).length} opponents`, 'success');
          
        } catch (error) {
          log(`  ‚úó Error saving ${legacyId}: ${error.message}`, 'error');
          errorCount++;
        }
      }
      
      update2025SplitsStats(result.playerCount, result.totalGames, savedCount);
      
      log('');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('AGGREGATION COMPLETE', 'header');
      log(`‚úì ${savedCount} players saved to ${SPLITS_2025_COLLECTION}`, 'success');
      if (errorCount > 0) log(`‚úó ${errorCount} errors`, 'error');
      log('Production stats remain unchanged.', 'splits');
      
    } catch (error) {
      log(`Fatal error: ${error.message}`, 'error');
      console.error('Aggregation error:', error);
    } finally {
      btn.disabled = false;
      btn.textContent = 'üìà Aggregate 2025 Splits';
    }
  };

  async function gatherSplitsData(seasonId) {
    // Get all player legacy IDs from aggregatedPlayerStats
    log('Step 1: Getting player IDs from aggregatedPlayerStats...', 'splits');
    
    const aggregatedRef = window.collection(window.db, 'aggregatedPlayerStats');
    const aggregatedSnap = await window.getDocs(aggregatedRef);
    
    const playerLegacyIds = new Set();
    const legacyToName = new Map();
    
    aggregatedSnap.forEach(docSnap => {
      const data = docSnap.data();
      if (data.migrated) return;
      
      let legacyId;
      let playerName;
      
      if (data.isAuthUser && data.linkedPlayer) {
        legacyId = data.linkedPlayer.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_');
        playerName = data.linkedPlayer;
      } else {
        legacyId = docSnap.id;
        playerName = data.name || docSnap.id;
      }
      
      playerLegacyIds.add(legacyId);
      legacyToName.set(legacyId, playerName);
    });
    
    log(`Found ${playerLegacyIds.size} player IDs to check`, 'success');
    
    // Query each player's games for this season
    log('');
    log('Step 2: Scanning player game stats...', 'splits');
    
    const playerSplits = new Map();
    let totalGames = 0;
    let checkedCount = 0;
    
    for (const legacyId of playerLegacyIds) {
      try {
        const gamesRef = window.collection(window.db, 'playerStats', legacyId, 'games');
        const gamesSnap = await window.getDocs(gamesRef);
        
        const seasonGames = [];
        gamesSnap.forEach(gameDoc => {
          const data = gameDoc.data();
          if (data.seasonId === seasonId) {
            seasonGames.push({ gameId: gameDoc.id, ...data });
          }
        });
        
        if (seasonGames.length > 0) {
          const seasonSplits = calculateSeasonSplits(seasonGames);
          playerSplits.set(legacyId, {
            playerName: legacyToName.get(legacyId) || legacyId,
            games: seasonGames.length,
            seasonSplits: seasonSplits
          });
          totalGames += seasonGames.length;
          
          log(`  ${legacyToName.get(legacyId)}: ${seasonGames.length} games found`);
        }
        
      } catch (err) {
        // Player might not have game stats
      }
      
      checkedCount++;
      if (checkedCount % 50 === 0) {
        log(`  Checked ${checkedCount}/${playerLegacyIds.size} players...`);
      }
    }
    
    log(`Found ${playerSplits.size} players with game data`, 'success');
    
    return {
      playerCount: playerSplits.size,
      totalGames: totalGames,
      playerSplits: playerSplits
    };
  }

  function calculateSeasonSplits(games) {
    const splits = {
      games: games.length,
      atBats: 0, hits: 0, runs: 0, walks: 0,
      doubles: 0, triples: 0, homeRuns: 0, rbi: 0,
      vsOpponent: {},
      home: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
      away: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
      regular: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
      playoff: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 }
    };
    
    games.forEach(game => {
      splits.atBats += game.atBats || 0;
      splits.hits += game.hits || 0;
      splits.runs += game.runs || 0;
      splits.walks += game.walks || 0;
      splits.doubles += game.doubles || 0;
      splits.triples += game.triples || 0;
      splits.homeRuns += game.homeRuns || 0;
      splits.rbi += game.rbi || 0;
      
      // Opponent breakdown
      const opponent = game.opponent || 'Unknown';
      if (!splits.vsOpponent[opponent]) {
        splits.vsOpponent[opponent] = {
          games: 0, atBats: 0, hits: 0, runs: 0, walks: 0,
          doubles: 0, triples: 0, homeRuns: 0, rbi: 0
        };
      }
      const opp = splits.vsOpponent[opponent];
      opp.games++;
      opp.atBats += game.atBats || 0;
      opp.hits += game.hits || 0;
      opp.runs += game.runs || 0;
      opp.walks += game.walks || 0;
      opp.doubles += game.doubles || 0;
      opp.triples += game.triples || 0;
      opp.homeRuns += game.homeRuns || 0;
      opp.rbi += game.rbi || 0;
      
      // Home/Away
      const homeAway = game.isHome === true ? splits.home : splits.away;
      homeAway.games++;
      homeAway.atBats += game.atBats || 0;
      homeAway.hits += game.hits || 0;
      homeAway.runs += game.runs || 0;
      homeAway.walks += game.walks || 0;
      homeAway.doubles += game.doubles || 0;
      homeAway.triples += game.triples || 0;
      homeAway.homeRuns += game.homeRuns || 0;
      homeAway.rbi += game.rbi || 0;
      
      // Regular/Playoff
      const isPlayoff = game.isPlayoff === true || game.gameType === 'playoff';
      const gameType = isPlayoff ? splits.playoff : splits.regular;
      gameType.games++;
      gameType.atBats += game.atBats || 0;
      gameType.hits += game.hits || 0;
      gameType.runs += game.runs || 0;
      gameType.walks += game.walks || 0;
      gameType.doubles += game.doubles || 0;
      gameType.triples += game.triples || 0;
      gameType.homeRuns += game.homeRuns || 0;
      gameType.rbi += game.rbi || 0;
    });
    
    // Calculate averages
    splits.battingAverage = splits.atBats > 0 ? splits.hits / splits.atBats : 0;
    splits.onBasePercentage = (splits.atBats + splits.walks) > 0
      ? (splits.hits + splits.walks) / (splits.atBats + splits.walks) : 0;
    
    // Calculate per-split averages
    [splits.home, splits.away, splits.regular, splits.playoff].forEach(split => {
      split.battingAverage = split.atBats > 0 ? split.hits / split.atBats : 0;
      split.onBasePercentage = (split.atBats + split.walks) > 0
        ? (split.hits + split.walks) / (split.atBats + split.walks) : 0;
    });
    
    // Calculate per-opponent averages
    Object.values(splits.vsOpponent).forEach(opp => {
      opp.battingAverage = opp.atBats > 0 ? opp.hits / opp.atBats : 0;
      opp.onBasePercentage = (opp.atBats + opp.walks) > 0
        ? (opp.hits + opp.walks) / (opp.atBats + opp.walks) : 0;
    });
    
    // Restructure to match expected format
    return {
      games: splits.games,
      atBats: splits.atBats,
      hits: splits.hits,
      runs: splits.runs,
      walks: splits.walks,
      doubles: splits.doubles,
      triples: splits.triples,
      homeRuns: splits.homeRuns,
      rbi: splits.rbi,
      battingAverage: splits.battingAverage,
      onBasePercentage: splits.onBasePercentage,
      vsOpponent: splits.vsOpponent,
      splits: {
        home: splits.home,
        away: splits.away,
        regular: splits.regular,
        playoff: splits.playoff
      }
    };
  }

  function calculate2025CareerSplits(seasonsObject) {
    const career = {
      games: 0, atBats: 0, hits: 0, runs: 0, walks: 0,
      vsOpponent: {},
      splits: {
        home: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
        away: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
        regular: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
        playoff: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 }
      }
    };
    
    Object.values(seasonsObject).forEach(season => {
      career.games += season.games || 0;
      career.atBats += season.atBats || 0;
      career.hits += season.hits || 0;
      career.runs += season.runs || 0;
      career.walks += season.walks || 0;
      
      // Aggregate vsOpponent
      if (season.vsOpponent) {
        Object.entries(season.vsOpponent).forEach(([opponent, oppStats]) => {
          if (!career.vsOpponent[opponent]) {
            career.vsOpponent[opponent] = {
              games: 0, atBats: 0, hits: 0, runs: 0, walks: 0,
              doubles: 0, triples: 0, homeRuns: 0, rbi: 0
            };
          }
          const careerOpp = career.vsOpponent[opponent];
          careerOpp.games += oppStats.games || 0;
          careerOpp.atBats += oppStats.atBats || 0;
          careerOpp.hits += oppStats.hits || 0;
          careerOpp.runs += oppStats.runs || 0;
          careerOpp.walks += oppStats.walks || 0;
        });
      }
      
      // Aggregate splits
      if (season.splits) {
        ['home', 'away', 'regular', 'playoff'].forEach(splitKey => {
          const seasonSplit = season.splits[splitKey];
          const careerSplit = career.splits[splitKey];
          if (seasonSplit) {
            careerSplit.games += seasonSplit.games || 0;
            careerSplit.atBats += seasonSplit.atBats || 0;
            careerSplit.hits += seasonSplit.hits || 0;
            careerSplit.runs += seasonSplit.runs || 0;
            careerSplit.walks += seasonSplit.walks || 0;
          }
        });
      }
    });
    
    // Calculate averages
    career.battingAverage = career.atBats > 0 ? career.hits / career.atBats : 0;
    career.onBasePercentage = (career.atBats + career.walks) > 0
      ? (career.hits + career.walks) / (career.atBats + career.walks) : 0;
    
    // Calculate per-split averages
    Object.values(career.splits).forEach(split => {
      split.battingAverage = split.atBats > 0 ? split.hits / split.atBats : 0;
      split.onBasePercentage = (split.atBats + split.walks) > 0
        ? (split.hits + split.walks) / (split.atBats + split.walks) : 0;
    });
    
    // Calculate per-opponent averages
    Object.values(career.vsOpponent).forEach(opp => {
      opp.battingAverage = opp.atBats > 0 ? opp.hits / opp.atBats : 0;
      opp.onBasePercentage = (opp.atBats + opp.walks) > 0
        ? (opp.hits + opp.walks) / (opp.atBats + opp.walks) : 0;
    });
    
    return career;
  }

  // ============================================
  // PREVIEW FUNCTION (2026+ - READ-ONLY)
  // ============================================

  window.previewGameBasedSeason = async function() {
    const seasonId = document.getElementById('seasonSelect').value;
    if (!seasonId) {
      alert('Please select a season first');
      return;
    }

    const btn = document.getElementById('previewSeasonBtn');
    btn.disabled = true;
    btn.textContent = '‚è≥ Loading...';

    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
    log(`PREVIEW: Game-Level Stats for ${seasonId}`, 'header');
    log('‚ö†Ô∏è  NO CHANGES WILL BE MADE TO DATABASE', 'header');
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');

    try {
      // STEP 1: Get all player legacy IDs from aggregatedPlayerStats
      log('Step 1: Getting player IDs from aggregatedPlayerStats...', 'game');
      
      const aggregatedRef = window.collection(window.db, 'aggregatedPlayerStats');
      const aggregatedSnap = await window.getDocs(aggregatedRef);
      
      const playerLegacyIds = new Set();
      
      aggregatedSnap.forEach(docSnap => {
        const data = docSnap.data();
        if (data.migrated) return; // Skip migrated profiles
        
        // Determine the legacyId to query for game stats
        let legacyId;
        if (data.isAuthUser && data.linkedPlayer) {
          // Auth user - derive legacyId from linkedPlayer name
          legacyId = data.linkedPlayer.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_');
        } else {
          // Legacy user - doc ID is the legacyId
          legacyId = docSnap.id;
        }
        playerLegacyIds.add(legacyId);
      });
      
      const playerIds = Array.from(playerLegacyIds);
      log(`Found ${playerIds.length} player IDs to check`, 'success');

      // Query each player's games for this season
      log('');
      log('Scanning player game stats...', 'game');
      
      const playersWithGames = [];
      let totalGamesFound = 0;
      let checkedCount = 0;
      
      for (const legacyId of playerIds) {
        try {
          const gamesRef = window.collection(window.db, 'playerStats', legacyId, 'games');
          const gamesSnap = await window.getDocs(gamesRef);
          
          let seasonGames = 0;
          gamesSnap.forEach(gameDoc => {
            const data = gameDoc.data();
            if (data.seasonId === seasonId) {
              seasonGames++;
            }
          });
          
          if (seasonGames > 0) {
            playersWithGames.push({ legacyId, games: seasonGames });
            totalGamesFound += seasonGames;
          }
        } catch (err) {
          // Player might not have game stats
        }
        
        checkedCount++;
        if (checkedCount % 50 === 0) {
          log(`  Checked ${checkedCount}/${playerIds.length} players...`);
        }
      }
      
      log('');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('PREVIEW RESULTS', 'header');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log(`Players with games: ${playersWithGames.length}`, 'success');
      log(`Total games found: ${totalGamesFound}`, 'success');
      log('');
      
      // Show top players
      playersWithGames.sort((a, b) => b.games - a.games);
      log('Top players by games:');
      playersWithGames.slice(0, 10).forEach(p => {
        log(`  ${p.legacyId}: ${p.games} games`);
      });
      
      if (playersWithGames.length > 10) {
        log(`  ... and ${playersWithGames.length - 10} more players`);
      }
      
      updateSeasonStats(playersWithGames.length, totalGamesFound, 0, 0);
      
      log('');
      log('No changes were made. Click "Aggregate Season" to process and save.', 'game');
      
    } catch (error) {
      log(`Fatal error: ${error.message}`, 'error');
      console.error('Preview error:', error);
    } finally {
      btn.disabled = false;
      btn.textContent = 'üëÅÔ∏è Preview';
    }
  };

  // ============================================
  // AGGREGATION FUNCTION (2026+)
  // ============================================

  window.aggregateGameBasedSeason = async function() {
    const seasonId = document.getElementById('seasonSelect').value;
    if (!seasonId) {
      alert('Please select a season first');
      return;
    }

    const testModeNote = testModeEnabled 
      ? `\n\nüß™ TEST MODE: Data will be written to "${getAggregatedCollection()}" (production is safe)`
      : '';

    const confirmed = confirm(
      `This will aggregate all game stats for ${seasonId} and update career totals.\n\n` +
      `üí° Tip: Use "Preview" first to see what will change.${testModeNote}\n\n` +
      `Continue with aggregation?`
    );
    if (!confirmed) return;

    const btn = document.getElementById('aggregateSeasonBtn');
    btn.disabled = true;
    btn.textContent = '‚è≥ Processing...';

    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
    log(`Aggregating Game-Level Stats for ${seasonId}`, 'header');
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');

    if (testModeEnabled) {
      log(`üß™ TEST MODE: Writing to ${getAggregatedCollection()}`, 'header');
    }

    try {
      // STEP 1: Get all player IDs and build legacyId ‚Üí documentId mapping
      log('Step 1: Getting player IDs and building ID mapping...', 'game');
      
      const aggregatedRef = window.collection(window.db, 'aggregatedPlayerStats');
      const aggregatedSnap = await window.getDocs(aggregatedRef);
      
      const playerLegacyIds = new Set();
      const legacyToDocId = new Map();  // Maps legacyId -> actual document ID
      const docIdToPlayerInfo = new Map(); // Maps docId -> player info for non-sub detection
      
      aggregatedSnap.forEach(docSnap => {
        const data = docSnap.data();
        if (data.migrated) return; // Skip migrated profiles
        
        const docId = docSnap.id;
        let legacyId;
        
        if (data.isAuthUser && data.linkedPlayer) {
          // Auth user - derive legacyId from linkedPlayer name
          legacyId = data.linkedPlayer.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_');
          log(`  Auth user: ${data.linkedPlayer} (${legacyId}) ‚Üí docId: ${docId}`);
        } else {
          // Legacy user - doc ID is the legacyId
          legacyId = docId;
        }
        
        playerLegacyIds.add(legacyId);
        legacyToDocId.set(legacyId, docId);
        docIdToPlayerInfo.set(docId, {
          name: data.name || data.linkedPlayer || legacyId,
          isAuthUser: data.isAuthUser || false,
          existingData: data
        });
      });
      
      const playerIds = Array.from(playerLegacyIds);
      log(`Found ${playerIds.length} unique player IDs to check`, 'success');
      log(`Built mapping for ${legacyToDocId.size} players`, 'success');

      // Query each player's games for this season
      log('');
      log('Scanning player game stats...', 'game');
      
      const playerBattingGames = new Map();
      const playerPitchingGames = new Map();
      let checkedCount = 0;
      
      for (const legacyId of playerIds) {
        // Check batting stats
        try {
          const gamesRef = window.collection(window.db, 'playerStats', legacyId, 'games');
          const gamesSnap = await window.getDocs(gamesRef);
          
          gamesSnap.forEach(gameDoc => {
            const data = gameDoc.data();
            // Only include games for this season
            if (data.seasonId === seasonId) {
              if (!playerBattingGames.has(legacyId)) {
                playerBattingGames.set(legacyId, []);
              }
              playerBattingGames.get(legacyId).push({
                gameId: gameDoc.id,
                ...data
              });
            }
          });
        } catch (err) {
          // Player might not have any game stats yet
        }
        
        // Check pitching stats
        try {
          const pitchingRef = window.collection(window.db, 'pitchingStats', legacyId, 'games');
          const pitchingSnap = await window.getDocs(pitchingRef);
          
          pitchingSnap.forEach(gameDoc => {
            const data = gameDoc.data();
            // Only include games for this season
            if (data.seasonId === seasonId) {
              if (!playerPitchingGames.has(legacyId)) {
                playerPitchingGames.set(legacyId, []);
              }
              playerPitchingGames.get(legacyId).push({
                gameId: gameDoc.id,
                ...data
              });
            }
          });
        } catch (err) {
          // Player might not have pitching stats
        }
        
        checkedCount++;
        if (checkedCount % 50 === 0) {
          log(`  Checked ${checkedCount}/${playerIds.length} players...`);
        }
      }

      log(`Found ${playerBattingGames.size} players with batting games`, 'success');
      log(`Found ${playerPitchingGames.size} players with pitching games`, 'success');

      // STEP 2: Calculate season totals for all players (first pass - no acesBPI yet)
      log('');
      log('Step 2: Calculating season totals...', 'game');

      let battingUpdatedCount = 0;
      let pitchingUpdatedCount = 0;
      let totalGamesProcessed = 0;
      let errorCount = 0;
      
      // Store all season totals for acesBPI calculation
      const allSeasonTotals = new Map(); // legacyId -> seasonTotals

      for (const [legacyId, games] of playerBattingGames) {
        const seasonTotals = {
          games: games.length,
          atBats: 0,
          hits: 0,
          runs: 0,
          walks: 0,
          doubles: 0,
          triples: 0,
          homeRuns: 0,
          rbi: 0,
          strikeouts: 0,
          stolenBases: 0,
          team: null,
          playerName: null,
          vsOpponent: {},  // Per-opponent breakdown
          splits: {        // Home/Away and Playoff/Regular splits
            home: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
            away: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
            regular: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
            playoff: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 }
          }
        };

        games.forEach(game => {
          seasonTotals.atBats += game.atBats || 0;
          seasonTotals.hits += game.hits || 0;
          seasonTotals.runs += game.runs || 0;
          seasonTotals.walks += game.walks || 0;
          seasonTotals.doubles += game.doubles || 0;
          seasonTotals.triples += game.triples || 0;
          seasonTotals.homeRuns += game.homeRuns || 0;
          seasonTotals.rbi += game.rbi || 0;
          seasonTotals.strikeouts += game.strikeouts || 0;
          seasonTotals.stolenBases += game.stolenBases || 0;
          if (!seasonTotals.team) seasonTotals.team = game.teamId || '';
          if (!seasonTotals.playerName) seasonTotals.playerName = game.playerName || '';
          
          // Track per-opponent stats
          const opponent = game.opponent || 'Unknown';
          if (!seasonTotals.vsOpponent[opponent]) {
            seasonTotals.vsOpponent[opponent] = {
              games: 0, atBats: 0, hits: 0, runs: 0, walks: 0,
              doubles: 0, triples: 0, homeRuns: 0, rbi: 0
            };
          }
          const opp = seasonTotals.vsOpponent[opponent];
          opp.games++;
          opp.atBats += game.atBats || 0;
          opp.hits += game.hits || 0;
          opp.runs += game.runs || 0;
          opp.walks += game.walks || 0;
          opp.doubles += game.doubles || 0;
          opp.triples += game.triples || 0;
          opp.homeRuns += game.homeRuns || 0;
          opp.rbi += game.rbi || 0;
          
          // Track Home/Away splits
          const homeAwaySplit = game.isHome === true ? seasonTotals.splits.home : seasonTotals.splits.away;
          homeAwaySplit.games++;
          homeAwaySplit.atBats += game.atBats || 0;
          homeAwaySplit.hits += game.hits || 0;
          homeAwaySplit.runs += game.runs || 0;
          homeAwaySplit.walks += game.walks || 0;
          homeAwaySplit.doubles += game.doubles || 0;
          homeAwaySplit.triples += game.triples || 0;
          homeAwaySplit.homeRuns += game.homeRuns || 0;
          homeAwaySplit.rbi += game.rbi || 0;
          
          // Track Playoff/Regular splits
          const isPlayoffGame = game.isPlayoff === true || game.gameType === 'playoff';
          const gameTypeSplit = isPlayoffGame ? seasonTotals.splits.playoff : seasonTotals.splits.regular;
          gameTypeSplit.games++;
          gameTypeSplit.atBats += game.atBats || 0;
          gameTypeSplit.hits += game.hits || 0;
          gameTypeSplit.runs += game.runs || 0;
          gameTypeSplit.walks += game.walks || 0;
          gameTypeSplit.doubles += game.doubles || 0;
          gameTypeSplit.triples += game.triples || 0;
          gameTypeSplit.homeRuns += game.homeRuns || 0;
          gameTypeSplit.rbi += game.rbi || 0;
        });

        // Calculate basic stats for season totals
        seasonTotals.battingAverage = seasonTotals.atBats > 0 ? seasonTotals.hits / seasonTotals.atBats : 0;
        seasonTotals.onBasePercentage = (seasonTotals.atBats + seasonTotals.walks) > 0
          ? (seasonTotals.hits + seasonTotals.walks) / (seasonTotals.atBats + seasonTotals.walks) : 0;
        seasonTotals.runsPerPA = (seasonTotals.atBats + seasonTotals.walks) > 0
          ? seasonTotals.runs / (seasonTotals.atBats + seasonTotals.walks) : 0;
        
        // Calculate per-opponent averages
        Object.values(seasonTotals.vsOpponent).forEach(opp => {
          opp.battingAverage = opp.atBats > 0 ? opp.hits / opp.atBats : 0;
          opp.onBasePercentage = (opp.atBats + opp.walks) > 0
            ? (opp.hits + opp.walks) / (opp.atBats + opp.walks) : 0;
        });
        
        // Calculate splits averages (home/away, playoff/regular)
        Object.values(seasonTotals.splits).forEach(split => {
          split.battingAverage = split.atBats > 0 ? split.hits / split.atBats : 0;
          split.onBasePercentage = (split.atBats + split.walks) > 0
            ? (split.hits + split.walks) / (split.atBats + split.walks) : 0;
        });

        allSeasonTotals.set(legacyId, seasonTotals);
        totalGamesProcessed += games.length;
      }

      // STEP 3: Calculate league averages for acesBPI
      log('');
      log('Step 3: Calculating league averages for acesBPI...', 'game');
      
      // Determine max games played (for reference/logging only)
      let maxGames = 0;
      allSeasonTotals.forEach(stats => {
        if (stats.games > maxGames) maxGames = stats.games;
      });
      
      log(`  Max games in season: ${maxGames}`);
      
      // Collect stats from all players for mean/stddev calculation
      // Note: sub flag check kept for backward compatibility with old seasons
      const nonSubStats = {
        battingAverage: [],
        onBasePercentage: [],
        runsPerPA: [],
        games: []
      };
      
      allSeasonTotals.forEach((stats, legacyId) => {
        // Only exclude if explicitly marked as sub (for old data or future use)
        const isSub = (stats.sub || '').toLowerCase() === 'yes';
        
        if (!isSub && stats.atBats > 0) {
          nonSubStats.battingAverage.push(stats.battingAverage);
          nonSubStats.onBasePercentage.push(stats.onBasePercentage);
          nonSubStats.runsPerPA.push(stats.runsPerPA);
          nonSubStats.games.push(stats.games);
        }
      });
      
      log(`  Players for league averages: ${nonSubStats.battingAverage.length}`);
      
      // Calculate mean and standard deviation for each stat
      function calcMean(arr) {
        if (arr.length === 0) return 0;
        return arr.reduce((a, b) => a + b, 0) / arr.length;
      }
      
      function calcStdDev(arr, mean) {
        if (arr.length < 2) return 1; // Avoid division by zero
        const squaredDiffs = arr.map(x => Math.pow(x - mean, 2));
        return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / arr.length) || 1;
      }
      
      const leagueStats = {
        battingAverage: { mean: calcMean(nonSubStats.battingAverage), stdDev: 0 },
        onBasePercentage: { mean: calcMean(nonSubStats.onBasePercentage), stdDev: 0 },
        runsPerPA: { mean: calcMean(nonSubStats.runsPerPA), stdDev: 0 },
        games: { mean: calcMean(nonSubStats.games), stdDev: 0 }
      };
      
      leagueStats.battingAverage.stdDev = calcStdDev(nonSubStats.battingAverage, leagueStats.battingAverage.mean);
      leagueStats.onBasePercentage.stdDev = calcStdDev(nonSubStats.onBasePercentage, leagueStats.onBasePercentage.mean);
      leagueStats.runsPerPA.stdDev = calcStdDev(nonSubStats.runsPerPA, leagueStats.runsPerPA.mean);
      leagueStats.games.stdDev = calcStdDev(nonSubStats.games, leagueStats.games.mean);
      
      log(`  League BA: ${leagueStats.battingAverage.mean.toFixed(3)} (œÉ=${leagueStats.battingAverage.stdDev.toFixed(3)})`);
      log(`  League OBP: ${leagueStats.onBasePercentage.mean.toFixed(3)} (œÉ=${leagueStats.onBasePercentage.stdDev.toFixed(3)})`);
      log(`  League R/PA: ${leagueStats.runsPerPA.mean.toFixed(3)} (œÉ=${leagueStats.runsPerPA.stdDev.toFixed(3)})`);
      log(`  League Games: ${leagueStats.games.mean.toFixed(1)} (œÉ=${leagueStats.games.stdDev.toFixed(1)})`);

      // STEP 4: Calculate acesBPI and save all player data
      log('');
      log('Step 4: Calculating acesBPI and saving...', 'game');
      
      // acesBPI weights: 50% BA, 10% OBP, 30% Runs/PA, 10% Games
      const weights = { battingAverage: 0.5, onBasePercentage: 0.1, runsPerPA: 0.3, games: 0.1 };
      
      function calcZScore(value, mean, stdDev) {
        if (stdDev === 0) return 0;
        return (value - mean) / stdDev;
      }

      for (const [legacyId, seasonTotals] of allSeasonTotals) {
        try {
          // Calculate z-scores
          const zScores = {
            battingAverage: calcZScore(seasonTotals.battingAverage, leagueStats.battingAverage.mean, leagueStats.battingAverage.stdDev),
            onBasePercentage: calcZScore(seasonTotals.onBasePercentage, leagueStats.onBasePercentage.mean, leagueStats.onBasePercentage.stdDev),
            runsPerPA: calcZScore(seasonTotals.runsPerPA, leagueStats.runsPerPA.mean, leagueStats.runsPerPA.stdDev),
            games: calcZScore(seasonTotals.games, leagueStats.games.mean, leagueStats.games.stdDev)
          };
          
          // Weighted average of z-scores
          const weightedZScore = 
            (zScores.battingAverage * weights.battingAverage) +
            (zScores.onBasePercentage * weights.onBasePercentage) +
            (zScores.runsPerPA * weights.runsPerPA) +
            (zScores.games * weights.games);
          
          // acesBPI = 50 + 10 * weighted z-score
          seasonTotals.acesBPI = 50 + (10 * weightedZScore);
          
          // Get the correct document ID (authUID for auth users, legacyId for legacy users)
          const docId = legacyToDocId.get(legacyId) || legacyId;
          const playerInfo = docIdToPlayerInfo.get(docId) || {};
          
          // Get existing data (from test or production collection)
          const aggregatedDocRef = window.doc(window.db, getAggregatedCollection(), docId);
          const existingDoc = await window.getDoc(aggregatedDocRef);
          const existingData = existingDoc.exists() ? existingDoc.data() : {};
          const existingSeasons = { ...(existingData.seasons || {}) };

          existingSeasons[seasonId] = seasonTotals;

          const career = recalculateCareer(existingSeasons);

          await window.setDoc(aggregatedDocRef, {
            ...existingData,
            name: existingData.name || seasonTotals.playerName,
            seasons: existingSeasons,
            career: career,
            totalSeasons: Object.keys(existingSeasons).length,
            lastUpdated: new Date(),
            lastGameAggregation: seasonId
          }, { merge: true });

          battingUpdatedCount++;

          const avgDisplay = seasonTotals.atBats > 0 
            ? '.' + (seasonTotals.battingAverage * 1000).toFixed(0).padStart(3, '0') : '.000';
          const oppCount = Object.keys(seasonTotals.vsOpponent).length;
          const homeGames = seasonTotals.splits.home.games;
          const awayGames = seasonTotals.splits.away.games;
          const playoffGames = seasonTotals.splits.playoff.games;
          log(`  ‚úì ${seasonTotals.playerName || legacyId}: ${seasonTotals.games} G (${homeGames}H/${awayGames}A, ${playoffGames} playoff), ${avgDisplay} BA, ${seasonTotals.acesBPI.toFixed(1)} BPI, vs ${oppCount} teams ‚Üí ${docId}`, 'success');

          updateSeasonStats(playerBattingGames.size, totalGamesProcessed, battingUpdatedCount, pitchingUpdatedCount);

        } catch (error) {
          log(`  ‚úó Error with ${legacyId}: ${error.message}`, 'error');
          errorCount++;
        }
      }

      // Handle pitching stats (similar structure)
      log('');
      log('Step 5: Processing pitching stats...', 'pitching');
      
      for (const [legacyId, games] of playerPitchingGames) {
        try {
          const pitchingTotals = {
            games: games.length,
            inningsPitched: 0,
            runsAllowed: 0,
            earnedRuns: 0,
            strikeouts: 0,
            walks: 0,
            hits: 0,
            wins: 0,
            losses: 0,
            saves: 0
          };
          
          games.forEach(game => {
            pitchingTotals.inningsPitched += game.inningsPitched || 0;
            pitchingTotals.runsAllowed += game.runsAllowed || 0;
            pitchingTotals.earnedRuns += game.earnedRuns || 0;
            pitchingTotals.strikeouts += game.strikeouts || 0;
            pitchingTotals.walks += game.walks || 0;
            pitchingTotals.hits += game.hits || 0;
            pitchingTotals.wins += game.wins || 0;
            pitchingTotals.losses += game.losses || 0;
            pitchingTotals.saves += game.saves || 0;
          });
          
          pitchingTotals.earnedRunAverage = pitchingTotals.inningsPitched > 0
            ? (pitchingTotals.runsAllowed * 7) / pitchingTotals.inningsPitched : 0;
          
          const docId = legacyToDocId.get(legacyId) || legacyId;
          const aggregatedDocRef = window.doc(window.db, getAggregatedCollection(), docId);
          const existingDoc = await window.getDoc(aggregatedDocRef);
          const existingData = existingDoc.exists() ? existingDoc.data() : {};
          const existingPitchingSeasons = { ...(existingData.pitchingSeasons || {}) };
          
          existingPitchingSeasons[seasonId] = pitchingTotals;
          
          const pitchingCareer = recalculatePitchingCareer(existingPitchingSeasons);
          
          await window.setDoc(aggregatedDocRef, {
            pitchingSeasons: existingPitchingSeasons,
            pitchingCareer: pitchingCareer,
            lastUpdated: new Date()
          }, { merge: true });
          
          pitchingUpdatedCount++;
          log(`  ‚úì ${legacyId}: ${pitchingTotals.games} G, ${pitchingTotals.inningsPitched.toFixed(1)} IP, ${pitchingTotals.earnedRunAverage.toFixed(2)} ERA`, 'pitching');
          
        } catch (error) {
          log(`  ‚úó Pitching error ${legacyId}: ${error.message}`, 'error');
        }
      }

      log('');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('AGGREGATION COMPLETE', 'header');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log(`Batting stats updated: ${battingUpdatedCount}`, 'success');
      log(`Pitching stats updated: ${pitchingUpdatedCount}`, 'success');
      log(`Total games processed: ${totalGamesProcessed}`, 'success');
      if (errorCount > 0) log(`Errors: ${errorCount}`, 'error');
      
      updateSeasonStats(playerBattingGames.size, totalGamesProcessed, battingUpdatedCount, pitchingUpdatedCount);

    } catch (error) {
      log(`Fatal error: ${error.message}`, 'error');
      console.error('Aggregation error:', error);
    } finally {
      btn.disabled = false;
      btn.textContent = 'üéÆ Aggregate Season';
    }
  };

  // ============================================
  // CAREER RECALCULATION
  // ============================================

  function recalculateCareer(seasonsObject) {
    const career = {
      games: 0, atBats: 0, hits: 0, runs: 0, walks: 0,
      doubles: 0, triples: 0, homeRuns: 0, rbi: 0,
      strikeouts: 0, stolenBases: 0,
      acesBPITotal: 0, acesBPICount: 0,
      vsOpponent: {},  // Career vs opponent totals
      splits: {        // Career splits aggregated from seasons with game-level data
        home: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
        away: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
        regular: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 },
        playoff: { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0, doubles: 0, triples: 0, homeRuns: 0, rbi: 0 }
      }
    };

    Object.entries(seasonsObject).forEach(([seasonId, season]) => {
      career.games += season.games || 0;
      career.atBats += season.atBats || 0;
      career.hits += season.hits || 0;
      career.runs += season.runs || 0;
      career.walks += season.walks || 0;
      career.doubles += season.doubles || 0;
      career.triples += season.triples || 0;
      career.homeRuns += season.homeRuns || 0;
      career.rbi += season.rbi || 0;
      career.strikeouts += season.strikeouts || 0;
      career.stolenBases += season.stolenBases || 0;
      
      const sub = (season.sub || '').toLowerCase();
      if (season.acesBPI && season.acesBPI > 0 && sub !== 'yes') {
        career.acesBPITotal += season.acesBPI;
        career.acesBPICount++;
      }
      
      // Aggregate vsOpponent data from seasons that have it (game-based seasons)
      if (season.vsOpponent) {
        Object.entries(season.vsOpponent).forEach(([opponent, oppStats]) => {
          if (!career.vsOpponent[opponent]) {
            career.vsOpponent[opponent] = {
              games: 0, atBats: 0, hits: 0, runs: 0, walks: 0,
              doubles: 0, triples: 0, homeRuns: 0, rbi: 0
            };
          }
          const careerOpp = career.vsOpponent[opponent];
          careerOpp.games += oppStats.games || 0;
          careerOpp.atBats += oppStats.atBats || 0;
          careerOpp.hits += oppStats.hits || 0;
          careerOpp.runs += oppStats.runs || 0;
          careerOpp.walks += oppStats.walks || 0;
          careerOpp.doubles += oppStats.doubles || 0;
          careerOpp.triples += oppStats.triples || 0;
          careerOpp.homeRuns += oppStats.homeRuns || 0;
          careerOpp.rbi += oppStats.rbi || 0;
        });
      }
      
      // Aggregate splits data from seasons that have it (game-based seasons)
      if (season.splits) {
        ['home', 'away', 'regular', 'playoff'].forEach(splitKey => {
          const seasonSplit = season.splits[splitKey];
          const careerSplit = career.splits[splitKey];
          if (seasonSplit) {
            careerSplit.games += seasonSplit.games || 0;
            careerSplit.atBats += seasonSplit.atBats || 0;
            careerSplit.hits += seasonSplit.hits || 0;
            careerSplit.runs += seasonSplit.runs || 0;
            careerSplit.walks += seasonSplit.walks || 0;
            careerSplit.doubles += seasonSplit.doubles || 0;
            careerSplit.triples += seasonSplit.triples || 0;
            careerSplit.homeRuns += seasonSplit.homeRuns || 0;
            careerSplit.rbi += seasonSplit.rbi || 0;
          }
        });
      }
    });

    career.battingAverage = career.atBats > 0 ? career.hits / career.atBats : 0;
    career.onBasePercentage = (career.atBats + career.walks) > 0
      ? (career.hits + career.walks) / (career.atBats + career.walks) : 0;
    career.acesBPI = career.acesBPICount > 0 ? career.acesBPITotal / career.acesBPICount : 0;
    
    // Calculate per-opponent career averages
    Object.values(career.vsOpponent).forEach(opp => {
      opp.battingAverage = opp.atBats > 0 ? opp.hits / opp.atBats : 0;
      opp.onBasePercentage = (opp.atBats + opp.walks) > 0
        ? (opp.hits + opp.walks) / (opp.atBats + opp.walks) : 0;
    });
    
    // Calculate career splits averages
    Object.values(career.splits).forEach(split => {
      split.battingAverage = split.atBats > 0 ? split.hits / split.atBats : 0;
      split.onBasePercentage = (split.atBats + split.walks) > 0
        ? (split.hits + split.walks) / (split.atBats + split.walks) : 0;
    });

    delete career.acesBPITotal;
    delete career.acesBPICount;

    return career;
  }

  function recalculatePitchingCareer(pitchingSeasonsObject) {
    const career = {
      games: 0, inningsPitched: 0, runsAllowed: 0, earnedRuns: 0,
      strikeouts: 0, walks: 0, hits: 0, wins: 0, losses: 0, saves: 0
    };

    Object.values(pitchingSeasonsObject).forEach(season => {
      career.games += season.games || 0;
      career.inningsPitched += season.inningsPitched || 0;
      career.runsAllowed += season.runsAllowed || 0;
      career.earnedRuns += season.earnedRuns || 0;
      career.strikeouts += season.strikeouts || 0;
      career.walks += season.walks || 0;
      career.hits += season.hits || 0;
      career.wins += season.wins || 0;
      career.losses += season.losses || 0;
      career.saves += season.saves || 0;
    });

    career.earnedRunAverage = career.inningsPitched > 0
      ? (career.runsAllowed * 7) / career.inningsPitched : 0;

    return career;
  }

  // ============================================
  // FULL AGGREGATION (LEGACY)
  // ============================================

  window.runFullAggregation = async function() {
    const confirmed = confirm(
      'This will recalculate career stats for ALL players from their season data.\n\n' +
      'This is typically only needed if data gets out of sync.\n\n' +
      'Continue?'
    );
    if (!confirmed) return;

    const btn = document.getElementById('aggregateBtn');
    btn.disabled = true;
    btn.textContent = '‚è≥ Processing...';
    
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
    log('Full Career Recalculation', 'header');
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
    
    if (testModeEnabled) {
      log(`üß™ TEST MODE: Reading/writing to ${getAggregatedCollection()}`);
    }
    
    try {
      const statsRef = window.collection(window.db, getAggregatedCollection());
      const snapshot = await window.getDocs(statsRef);
      
      log(`Found ${snapshot.size} documents to process`);
      
      let processed = 0, legacyCount = 0, authCount = 0, skipped = 0, errors = 0;
      
      for (const docSnap of snapshot.docs) {
        const playerData = docSnap.data();
        
        if (playerData.migrated) {
          skipped++;
          continue;
        }
        
        try {
          if (!playerData.seasons || Object.keys(playerData.seasons).length === 0) {
            skipped++;
            continue;
          }
          
          const career = recalculateCareer(playerData.seasons);
          
          await window.setDoc(
            window.doc(window.db, getAggregatedCollection(), docSnap.id),
            { career, lastUpdated: new Date() },
            { merge: true }
          );
          
          processed++;
          if (playerData.isAuthUser) authCount++;
          else legacyCount++;
          
          if (processed % 25 === 0) {
            log(`Processed ${processed} players...`);
            updateFullStats(processed, legacyCount, authCount, skipped, errors);
          }
          
        } catch (error) {
          log(`Error processing ${docSnap.id}: ${error.message}`, 'error');
          errors++;
        }
      }
      
      log('');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('RECALCULATION COMPLETE', 'header');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log(`Processed: ${processed}`, 'success');
      log(`Legacy: ${legacyCount}`, 'legacy');
      log(`Auth users: ${authCount}`, 'auth');
      log(`Skipped: ${skipped}`, 'skip');
      if (errors > 0) log(`Errors: ${errors}`, 'error');
      
      updateFullStats(processed, legacyCount, authCount, skipped, errors);
      
    } catch (error) {
      log(`Fatal error: ${error.message}`, 'error');
    } finally {
      btn.disabled = false;
      btn.textContent = 'üöÄ Recalculate All Careers';
    }
  };

  // ============================================
  // VERIFICATION
  // ============================================

  window.verifyAggregation = async function() {
    const btn = document.getElementById('verifyBtn');
    btn.disabled = true;
    
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
    log('Verifying Aggregated Collections', 'header');
    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
    
    if (testModeEnabled) {
      log(`üß™ TEST MODE: Verifying ${getAggregatedCollection()}`);
    }
    
    try {
      // Check main collection
      const statsRef = window.collection(window.db, getAggregatedCollection());
      const snapshot = await window.getDocs(statsRef);
      
      log(`\nüìä Main Collection: ${getAggregatedCollection()}`, 'header');
      log(`Found ${snapshot.size} documents`, 'success');
      
      let authUserCount = 0, legacyCount = 0, migratedCount = 0, hasGameBasedSeasons = 0;
      const issues = [];
      
      snapshot.docs.forEach(doc => {
        const data = doc.data();
        
        if (data.migrated) migratedCount++;
        else if (data.isAuthUser) authUserCount++;
        else legacyCount++;
        
        if (data.seasons) {
          const hasGameBased = Object.keys(data.seasons).some(s => GAME_BASED_SEASONS.includes(s));
          if (hasGameBased) hasGameBasedSeasons++;
        }
        
        if (!data.name && !data.displayName) issues.push(`${doc.id}: Missing name`);
        if (data.career && data.career.battingAverage > 1) issues.push(`${doc.id}: Invalid batting average`);
      });
      
      log(`  üìÅ Legacy players: ${legacyCount}`);
      log(`  üîê Auth users: ${authUserCount}`);
      log(`  ‚è≠Ô∏è Migrated: ${migratedCount}`);
      log(`  üéÆ Has 2026+ seasons: ${hasGameBasedSeasons}`);
      log(`  üìà Active total: ${legacyCount + authUserCount}`);
      
      // Check 2025 splits collection
      log(`\nüìà 2025 Splits Collection: ${SPLITS_2025_COLLECTION}`, 'header');
      
      try {
        const splits2025Ref = window.collection(window.db, SPLITS_2025_COLLECTION);
        const splits2025Snap = await window.getDocs(splits2025Ref);
        
        log(`Found ${splits2025Snap.size} documents`, 'success');
        
        let has2025Summer = 0, has2025Fall = 0;
        splits2025Snap.docs.forEach(doc => {
          const data = doc.data();
          if (data.seasons?.['2025-summer']) has2025Summer++;
          if (data.seasons?.['2025-fall']) has2025Fall++;
        });
        
        log(`  üåû 2025-summer: ${has2025Summer} players`);
        log(`  üçÇ 2025-fall: ${has2025Fall} players`);
        
      } catch (err) {
        log(`  Collection not found or empty`, 'skip');
      }
      
      // Check for duplicates in main collection
      const nameMap = new Map();
      snapshot.docs.forEach(doc => {
        const data = doc.data();
        if (data.migrated) return;
        const name = data.name || data.displayName;
        if (name) {
          if (!nameMap.has(name)) nameMap.set(name, []);
          nameMap.get(name).push(doc.id);
        }
      });
      
      const duplicates = Array.from(nameMap.entries()).filter(([name, ids]) => ids.length > 1);
      
      if (duplicates.length > 0) {
        log(`\n‚ö†Ô∏è Potential duplicates found:`, 'error');
        duplicates.forEach(([name, ids]) => log(`  ${name}: ${ids.join(', ')}`, 'error'));
      } else {
        log(`\n‚úÖ No duplicates found!`, 'success');
      }
      
      if (issues.length > 0) {
        log(`\n‚ö†Ô∏è Issues found:`, 'error');
        issues.slice(0, 10).forEach(issue => log(`  ${issue}`, 'error'));
        if (issues.length > 10) log(`  ... and ${issues.length - 10} more`, 'error');
      } else {
        log(`\n‚úÖ No data issues found!`, 'success');
      }
      
    } catch (error) {
      log(`Verification error: ${error.message}`, 'error');
    } finally {
      btn.disabled = false;
    }
  };
</script>

<script type="module">
  import { NavigationComponent } from './nav-component.js';
</script>
<script src="mobile-enhancements.js"></script>
</body>
</html>

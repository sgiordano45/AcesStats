<!DOCTYPE html>
<html lang="en">
<head>
<link rel="manifest" href="/manifest.json">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title id="pageTitle">Player Splits</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 20px;
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    min-height: 100vh;
  }
  
  .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    opacity: 1;
    visibility: visible;
  }
  
  .loading-overlay.hidden {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
  }
  
  .softball-spinner {
    text-align: center;
  }
  
  .softball-spinner::before {
    content: '‚öæ';
    font-size: 80px;
    display: block;
    animation: spin 1.5s ease-in-out infinite;
    margin-bottom: 20px;
  }
  
  .softball-spinner::after {
    content: 'Loading player splits...';
    display: block;
    font-size: 1.2rem;
    color: #4a5568;
    font-weight: 600;
  }
  
  @keyframes spin {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
  }
  
  .page-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 2rem;
  }
  
  /* Incomplete Data Banner */
  .incomplete-data-banner {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    border: 2px solid #f59e0b;
    border-radius: 12px;
    padding: 1rem 1.5rem;
    margin-bottom: 1.5rem;
    display: flex;
    align-items: flex-start;
    gap: 12px;
  }
  
  .incomplete-data-banner.hidden {
    display: none;
  }
  
  .incomplete-data-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
  }
  
  .incomplete-data-content h4 {
    margin: 0 0 4px 0;
    color: #92400e;
    font-size: 1rem;
  }
  
  .incomplete-data-content p {
    margin: 0;
    color: #b45309;
    font-size: 0.9rem;
  }
  
  /* Compact Player Header */
  .player-header-compact {
    background: linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%);
    color: white;
    padding: 1.5rem 2rem;
    border-radius: 16px;
    margin-bottom: 2rem;
    display: flex;
    align-items: center;
    gap: 20px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    position: relative;
    overflow: hidden;
  }
  
  .player-header-compact::before {
    content: "";
    position: absolute;
    top: -50%;
    right: -10%;
    width: 300px;
    height: 300px;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }
  
  .player-photo-small {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255,255,255,0.3);
    display: none;
    flex-shrink: 0;
  }
  
  .player-photo-small.loaded {
    display: block;
  }
  
  .player-photo-placeholder-small {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    border: 3px solid rgba(255,255,255,0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    color: rgba(255,255,255,0.5);
    flex-shrink: 0;
  }
  
  .player-photo-placeholder-small.hidden {
    display: none;
  }
  
  .player-info-compact {
    flex: 1;
    z-index: 1;
  }
  
  .player-info-compact h1 {
    margin: 0 0 4px 0;
    font-size: 1.8rem;
    font-weight: 700;
  }
  
  .player-info-compact .player-team {
    font-size: 1rem;
    opacity: 0.9;
  }
  
  .header-actions {
    display: flex;
    gap: 10px;
    z-index: 1;
  }
  
  /* Navigation Buttons */
  .nav-button {
    background: rgba(255,255,255,0.15);
    color: white;
    border: 2px solid rgba(255,255,255,0.3);
    padding: 10px 18px;
    border-radius: 10px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  
  .nav-button:hover {
    background: rgba(255,255,255,0.25);
    transform: translateY(-2px);
  }
  
  /* Filter Bar */
  .filter-bar {
    background: white;
    border-radius: 12px;
    padding: 1rem 1.5rem;
    margin-bottom: 2rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }
  
  .filter-label {
    font-weight: 600;
    color: #2d3748;
  }
  
  .filter-select {
    padding: 8px 16px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    background: white;
    cursor: pointer;
    transition: border-color 0.3s ease;
    min-width: 180px;
  }
  
  .filter-select:focus {
    outline: none;
    border-color: #2d5016;
  }
  
  .filter-info {
    margin-left: auto;
    color: #718096;
    font-size: 0.9rem;
  }
  
  .filter-info.partial-data {
    color: #b45309;
    font-weight: 500;
  }
  
  /* Split Sections */
  .splits-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    margin-bottom: 2rem;
  }
  
  .split-card {
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    border: 1px solid #e2e8f0;
  }
  
  .split-card-header {
    background: linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%);
    color: white;
    padding: 1rem 1.5rem;
    font-size: 1.2rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .split-card-content {
    padding: 0;
  }
  
  /* Split Tables */
  .split-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .split-table th,
  .split-table td {
    padding: 12px 16px;
    text-align: center;
    border-bottom: 1px solid #e2e8f0;
  }
  
  .split-table th {
    background: #f7fafc;
    color: #2d3748;
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .split-table th:first-child,
  .split-table td:first-child {
    text-align: left;
    font-weight: 600;
  }
  
  .split-table tbody tr:hover {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  }
  
  .split-table tbody tr:last-child td {
    border-bottom: none;
  }
  
  .split-label {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .split-icon {
    font-size: 1.2rem;
  }
  
  /* Comparison Highlights */
  .stat-better {
    color: #2d5016;
    font-weight: 700;
  }
  
  .stat-worse {
    color: #c53030;
  }
  
  /* Opponent Section - Full Width */
  .opponent-section {
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    border: 1px solid #e2e8f0;
    margin-bottom: 2rem;
  }
  
  .opponent-header {
    background: linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%);
    color: white;
    padding: 1rem 1.5rem;
    font-size: 1.2rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    user-select: none;
  }
  
  .opponent-toggle {
    transition: transform 0.3s ease;
  }
  
  .opponent-toggle.collapsed {
    transform: rotate(-180deg);
  }
  
  .opponent-content {
    max-height: 500px;
    overflow-y: auto;
    transition: max-height 0.3s ease;
  }
  
  .opponent-content.collapsed {
    max-height: 0;
    overflow: hidden;
  }
  
  .opponent-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .opponent-table th,
  .opponent-table td {
    padding: 12px 16px;
    text-align: center;
    border-bottom: 1px solid #e2e8f0;
  }
  
  .opponent-table th {
    background: #f7fafc;
    color: #2d3748;
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    position: sticky;
    top: 0;
    z-index: 1;
  }
  
  .opponent-table th:first-child,
  .opponent-table td:first-child {
    text-align: left;
    font-weight: 600;
  }
  
  .opponent-table tbody tr:hover {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  }
  
  .team-color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
    vertical-align: middle;
  }
  
  /* Game Log Section */
  .game-log-section {
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    border: 1px solid #e2e8f0;
    margin-bottom: 2rem;
  }
  
  .game-log-header {
    background: linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%);
    color: white;
    padding: 1rem 1.5rem;
    font-size: 1.2rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .game-log-content {
    max-height: 600px;
    overflow-y: auto;
  }
  
  .game-log-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .game-log-table th,
  .game-log-table td {
    padding: 12px 16px;
    text-align: center;
    border-bottom: 1px solid #e2e8f0;
  }
  
  .game-log-table th {
    background: #f7fafc;
    color: #2d3748;
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    position: sticky;
    top: 0;
    z-index: 1;
    cursor: pointer;
    user-select: none;
    transition: background 0.2s ease;
  }
  
  .game-log-table th:hover {
    background: #edf2f7;
  }
  
  .game-log-table th.sort-asc::after {
    content: ' ‚ñ≤';
    font-size: 0.7rem;
  }
  
  .game-log-table th.sort-desc::after {
    content: ' ‚ñº';
    font-size: 0.7rem;
  }
  
  .game-log-table th:first-child,
  .game-log-table td:first-child {
    text-align: left;
  }
  
  .game-log-table tbody tr:hover {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  }
  
  .game-type-badge {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
  }
  
  .game-type-regular {
    background: #e2e8f0;
    color: #4a5568;
  }
  
  .game-type-playoff {
    background: linear-gradient(135deg, #ffd700 0%, #ffed4a 100%);
    color: #744210;
  }
  
  .home-away-badge {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 600;
  }
  
  .badge-home {
    background: #dcfce7;
    color: #166534;
  }
  
  .badge-away {
    background: #dbeafe;
    color: #1e40af;
  }
  
  /* No Data State */
  .no-data {
    text-align: center;
    padding: 4rem 2rem;
    color: #718096;
  }
  
  .no-data-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
  }
  
  .no-data h3 {
    color: #2d3748;
    margin-bottom: 0.5rem;
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    body {
      padding: 10px;
    }
    
    .page-container {
      padding: 0 1rem;
    }
    
    .player-header-compact {
      flex-direction: column;
      text-align: center;
      padding: 1.5rem 1rem;
    }
    
    .header-actions {
      width: 100%;
      justify-content: center;
    }
    
    .filter-bar {
      flex-direction: column;
      align-items: stretch;
    }
    
    .filter-info {
      margin-left: 0;
      text-align: center;
    }
    
    .splits-grid {
      grid-template-columns: 1fr;
    }
    
    .split-table th,
    .split-table td,
    .opponent-table th,
    .opponent-table td,
    .game-log-table th,
    .game-log-table td {
      padding: 8px 10px;
      font-size: 0.85rem;
    }
    
    .incomplete-data-banner {
      flex-direction: column;
      text-align: center;
    }
  }
</style>
</head>
<body>

<nav-component></nav-component>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="softball-spinner"></div>
</div>

<div class="page-container">
  
  <!-- Incomplete Data Banner (hidden by default) -->
  <div class="incomplete-data-banner hidden" id="incompleteDataBanner">
    <div class="incomplete-data-icon">‚ö†Ô∏è</div>
    <div class="incomplete-data-content">
      <h4>Partial Game Data</h4>
      <p id="incompleteDataMessage">Game-level split data for 2025 seasons is incomplete and does not include all games or players. Complete game-level tracking begins with the 2026 Summer season.</p>
    </div>
  </div>
  
  <!-- Player Header (hidden until loaded) -->
  <div class="player-header-compact" id="playerHeader" style="display: none;">
    <div class="player-photo-placeholder-small" id="playerPhotoPlaceholder">üë§</div>
    <img class="player-photo-small" id="playerPhoto" alt="Player photo">
    <div class="player-info-compact">
      <h1 id="playerName">Loading...</h1>
      <div class="player-team" id="playerTeam"></div>
    </div>
    <div class="header-actions">
      <a id="fullProfileLink" href="#" class="nav-button">
        üìä Full Profile
      </a>
    </div>
  </div>
  
  <!-- Filter Bar (hidden until loaded) -->
  <div class="filter-bar" id="filterBar" style="display: none;">
    <span class="filter-label">View:</span>
    <select class="filter-select" id="seasonFilter">
      <option value="career">Career (All Seasons)</option>
    </select>
    <span class="filter-info" id="filterInfo">Showing career splits</span>
  </div>
  
  <!-- Splits Grid -->
  <div class="splits-grid" id="splitsGrid" style="display: none;">
    
    <!-- Playoff/Regular Split -->
    <div class="split-card">
      <div class="split-card-header">
        üèÜ Regular Season vs Playoffs
      </div>
      <div class="split-card-content" id="playoffSplitContent">
        <!-- Populated by JS -->
      </div>
    </div>
    
    <!-- Home/Away Split -->
    <div class="split-card">
      <div class="split-card-header">
        üè† Home vs Away
      </div>
      <div class="split-card-content" id="homeAwaySplitContent">
        <!-- Populated by JS -->
      </div>
    </div>
    
  </div>
  
  <!-- Opponent Breakdown -->
  <div class="opponent-section" id="opponentSection" style="display: none;">
    <div class="opponent-header" onclick="toggleOpponentSection()">
      <span>‚öîÔ∏è Performance vs Opponents</span>
      <span class="opponent-toggle" id="opponentToggle">‚ñº</span>
    </div>
    <div class="opponent-content" id="opponentContent">
      <table class="opponent-table">
        <thead>
          <tr>
            <th>Opponent</th>
            <th>G</th>
            <th>AB</th>
            <th>H</th>
            <th>R</th>
            <th>BB</th>
            <th>AVG</th>
            <th>OBP</th>
          </tr>
        </thead>
        <tbody id="opponentTableBody">
          <!-- Populated by JS -->
        </tbody>
      </table>
    </div>
  </div>
  
  <!-- Game Log -->
  <div class="game-log-section" id="gameLogSection" style="display: none;">
    <div class="game-log-header">
      üìã Game Log
    </div>
    <div class="game-log-content">
      <table class="game-log-table">
        <thead>
          <tr>
            <th data-sort="date" class="sort-desc">Date</th>
            <th data-sort="opponent">Opponent</th>
            <th data-sort="homeAway">H/A</th>
            <th data-sort="gameType">Type</th>
            <th data-sort="ab">AB</th>
            <th data-sort="h">H</th>
            <th data-sort="r">R</th>
            <th data-sort="bb">BB</th>
            <th data-sort="avg">AVG</th>
          </tr>
        </thead>
        <tbody id="gameLogTableBody">
          <!-- Populated by JS -->
        </tbody>
      </table>
    </div>
  </div>
  
  <!-- No Data Message (shown when no game-level data exists) -->
  <div class="no-data" id="noDataMessage" style="display: none;">
    <div class="no-data-icon">üìä</div>
    <h3>Game-Level Data Not Available</h3>
    <p>Detailed game-by-game statistics are available starting with the 2025 Fall season. Check back once game data has been recorded.</p>
    <a id="backToProfileLink" class="nav-button" href="#" style="margin-top: 1.5rem; background: #2d5016; color: white;">
      ‚Üê Back to Player Profile
    </a>
  </div>
  
</div>

<script type="module">
  import { 
    db, 
    doc, 
    getDoc,
    collection,
    getDocs,
    query,
    where
  } from './firebase-config.js';
  
  // Get player ID from URL
  const urlParams = new URLSearchParams(window.location.search);
  const playerId = urlParams.get('id');
  const playerName = urlParams.get('player');
  const testMode = urlParams.get('test') === 'true';
  
  // Collection names
  const AGGREGATED_COLLECTION = testMode ? 'aggregatedPlayerStats_test' : 'aggregatedPlayerStats';
  const SPLITS_2025_COLLECTION = 'aggregatedPlayerStats2025Splits';
  
  // Seasons configuration
  const SPLITS_2025_SEASONS = ['2025-summer', '2025-fall'];  // Partial data, separate collection
  const MIN_GAME_DATA_SEASON = '2025-summer';  // First season with any game data
  const FULL_DATA_START_SEASON = '2026-summer';  // First season with complete data
  
  // Show test mode banner if enabled
  if (testMode) {
    console.log('üß™ TEST MODE ENABLED - Reading from aggregatedPlayerStats_test');
    const banner = document.createElement('div');
    banner.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
      padding: 8px 16px;
      text-align: center;
      font-weight: 600;
      font-size: 0.9rem;
      z-index: 10000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    `;
    banner.innerHTML = 'üß™ TEST MODE - Reading from <code style="background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 4px;">aggregatedPlayerStats_test</code>';
    document.body.prepend(banner);
    document.body.style.paddingTop = '40px';
  }
  
  // Team colors for opponent display
  const teamColors = {
    'White': '#f0f0f0',
    'Blue': '#1e90ff',
    'Green': '#228b22',
    'Gray': '#808080',
    'Grey': '#808080',
    'Red': '#dc143c',
    'Orange': '#ff8c00',
    'Yellow': '#ffd700',
    'Purple': '#8b008b',
    'Black': '#333333'
  };
  
  // State
  let currentPlayer = null;
  let splits2025Data = null;  // Data from 2025 splits collection
  let gameStats = [];         // Only loaded for game log
  let currentFilter = 'career';
  let currentSort = { column: 'date', direction: 'desc' };
  
  function hideLoadingIndicator() {
    document.getElementById('loadingOverlay').classList.add('hidden');
  }
  
  function formatDate(dateValue) {
    if (!dateValue) return 'N/A';
    
    let date;
    if (dateValue.seconds) {
      date = new Date(dateValue.seconds * 1000);
    } else if (dateValue instanceof Date) {
      date = dateValue;
    } else {
      date = new Date(dateValue);
    }
    
    if (isNaN(date.getTime())) return 'N/A';
    
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
  }
  
  function getTeamColorDot(teamName) {
    const color = teamColors[teamName] || '#888888';
    const border = teamName === 'White' ? 'border: 1px solid #ccc;' : '';
    return `<span class="team-color-dot" style="background: ${color}; ${border}"></span>`;
  }
  
  function formatAvg(value) {
    if (typeof value !== 'number' || isNaN(value)) return '.000';
    return value.toFixed(3).replace(/^0/, '');
  }
  
  function calculateAvg(hits, atBats) {
    if (atBats === 0) return '.000';
    return (hits / atBats).toFixed(3).replace(/^0/, '');
  }
  
  function calculateOBP(hits, walks, atBats) {
    const pa = atBats + walks;
    if (pa === 0) return '.000';
    return ((hits + walks) / pa).toFixed(3).replace(/^0/, '');
  }
  
  function highlightBetter(val1, val2, higherIsBetter = true) {
    if (val1 === val2) return ['', ''];
    if (higherIsBetter) {
      return val1 > val2 ? ['stat-better', 'stat-worse'] : ['stat-worse', 'stat-better'];
    } else {
      return val1 < val2 ? ['stat-better', 'stat-worse'] : ['stat-worse', 'stat-better'];
    }
  }
  
  // Check if a season uses 2025 splits collection
  function is2025Season(seasonId) {
    return SPLITS_2025_SEASONS.includes(seasonId);
  }
  
  // Check if current filter shows partial data
  function isPartialDataSelection() {
    if (currentFilter === 'career') {
      // Career is partial if any 2025 data exists
      return splits2025Data !== null;
    }
    return is2025Season(currentFilter);
  }
  
  // Toggle opponent section collapse
  window.toggleOpponentSection = function() {
    const content = document.getElementById('opponentContent');
    const toggle = document.getElementById('opponentToggle');
    content.classList.toggle('collapsed');
    toggle.classList.toggle('collapsed');
  };
  
  // Get player from aggregated collection
  async function getPlayerFromAggregated(id) {
    try {
      const docRef = doc(db, AGGREGATED_COLLECTION, id);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists() && !docSnap.data().migrated) {
        return { id: docSnap.id, ...docSnap.data() };
      }
      return null;
    } catch (error) {
      console.error('Error fetching from aggregated collection:', error);
      return null;
    }
  }
  
  // Get player's 2025 splits data from separate collection
  async function get2025SplitsData(legacyId) {
    try {
      const docRef = doc(db, SPLITS_2025_COLLECTION, legacyId);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        console.log('‚úÖ Found 2025 splits data');
        return docSnap.data();
      }
      return null;
    } catch (error) {
      console.warn('Could not load 2025 splits data:', error);
      return null;
    }
  }
  
  // Resolve player name from aggregated collection
  async function resolvePlayerFromAggregated(searchName) {
    try {
      console.log(`üîç Resolving player name: "${searchName}" from ${AGGREGATED_COLLECTION}`);
      
      const statsRef = collection(db, AGGREGATED_COLLECTION);
      const snapshot = await getDocs(statsRef);
      
      const searchLower = searchName.toLowerCase();
      const searchNormalized = searchName.toLowerCase().replace(/\s+/g, '_');
      
      let foundPlayer = null;
      let bestMatch = null;
      let bestMatchScore = 0;
      
      snapshot.forEach(docSnap => {
        const data = docSnap.data();
        if (data.migrated === true) return;
        
        const dataName = (data.name || data.displayName || '').toLowerCase();
        const dataNameNormalized = dataName.replace(/\s+/g, '_');
        
        // Exact match
        if (dataName === searchLower || docSnap.id === searchNormalized) {
          foundPlayer = { id: docSnap.id, ...data };
          return;
        }
        
        // Normalized match
        if (dataNameNormalized === searchNormalized) {
          if (bestMatchScore < 90) {
            bestMatch = { id: docSnap.id, ...data };
            bestMatchScore = 90;
          }
        }
      });
      
      return foundPlayer || bestMatch;
    } catch (error) {
      console.error('Error resolving player:', error);
      return null;
    }
  }
  
  // Load player data
  async function loadPlayerData() {
    console.log(`‚ö° Loading splits for: ${playerId ? `ID=${playerId}` : `name=${playerName}`}`);
    console.log(`üìÇ Using collection: ${AGGREGATED_COLLECTION}`);
    
    try {
      let resolvedPlayer;
      
      if (playerId) {
        // Try direct lookup first
        resolvedPlayer = await getPlayerFromAggregated(playerId);
        
        if (!resolvedPlayer) {
          // Try resolving as name
          resolvedPlayer = await resolvePlayerFromAggregated(playerId);
        }
      } else if (playerName) {
        resolvedPlayer = await resolvePlayerFromAggregated(playerName);
      }
      
      if (!resolvedPlayer) {
        console.error('‚ùå Could not resolve player');
        hideLoadingIndicator();
        document.getElementById('noDataMessage').style.display = 'block';
        document.getElementById('noDataMessage').querySelector('h3').textContent = 'Player Not Found';
        document.getElementById('noDataMessage').querySelector('p').textContent = `Could not find player "${playerName || playerId}" in ${AGGREGATED_COLLECTION}`;
        return;
      }
      
      currentPlayer = resolvedPlayer;
      console.log('‚úÖ Loaded player:', currentPlayer.name);
      
      // Get the legacy ID for 2025 splits lookup
      const legacyId = currentPlayer.name ? 
        currentPlayer.name.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_') : 
        currentPlayer.id;
      
      // Load 2025 splits data from separate collection
      splits2025Data = await get2025SplitsData(legacyId);
      console.log('üìà 2025 splits data:', splits2025Data);
      
      // Update header
      updatePlayerHeader();
      
      // Check if player has any splits data (from either source)
      const hasSplitsData = checkForSplitsData();
      
      if (!hasSplitsData) {
        hideLoadingIndicator();
        document.getElementById('playerHeader').style.display = 'flex';
        document.getElementById('noDataMessage').style.display = 'block';
        return;
      }
      
      // Populate season filter
      populateSeasonFilter();
      
      // Render splits from aggregated data
      renderAllSplits();
      
      // Load game stats for game log (separate query - only needed for game log)
      await loadGameStatsForLog();
      renderGameLog();
      
      // Show UI
      document.getElementById('playerHeader').style.display = 'flex';
      document.getElementById('filterBar').style.display = 'flex';
      
      // Update incomplete data banner visibility
      updateIncompleteDataBanner();
      
      hideLoadingIndicator();
      
    } catch (error) {
      console.error('‚ùå Error loading player data:', error);
      hideLoadingIndicator();
      document.getElementById('noDataMessage').style.display = 'block';
    }
  }
  
  function checkForSplitsData() {
    // Check main aggregated collection for 2026+ seasons
    if (currentPlayer.seasons) {
      const mainSeasons = Object.keys(currentPlayer.seasons)
        .filter(s => s >= FULL_DATA_START_SEASON);
      
      const hasMainSplits = mainSeasons.some(seasonId => {
        const season = currentPlayer.seasons[seasonId];
        return season.splits && (season.splits.home?.games > 0 || season.splits.away?.games > 0);
      });
      
      if (hasMainSplits) {
        console.log('Found splits in main collection (2026+)');
        return true;
      }
    }
    
    // Check 2025 splits collection
    if (splits2025Data?.seasons) {
      const has2025Splits = Object.keys(splits2025Data.seasons).some(seasonId => {
        const season = splits2025Data.seasons[seasonId];
        return season.splits && (season.splits.home?.games > 0 || season.splits.away?.games > 0);
      });
      
      if (has2025Splits) {
        console.log('Found splits in 2025 collection');
        return true;
      }
    }
    
    // Check career splits from either source
    if (currentPlayer.career?.splits) {
      const hasCareerSplits = currentPlayer.career.splits.home?.games > 0 || 
                             currentPlayer.career.splits.away?.games > 0;
      if (hasCareerSplits) {
        console.log('Found career splits in main collection');
        return true;
      }
    }
    
    if (splits2025Data?.careerSplits?.splits) {
      const has2025CareerSplits = splits2025Data.careerSplits.splits.home?.games > 0 || 
                                  splits2025Data.careerSplits.splits.away?.games > 0;
      if (has2025CareerSplits) {
        console.log('Found career splits in 2025 collection');
        return true;
      }
    }
    
    console.log('No splits data found');
    return false;
  }
  
  function updatePlayerHeader() {
    const displayName = currentPlayer.name || currentPlayer.displayName;
    document.getElementById('pageTitle').textContent = `${displayName} - Splits${testMode ? ' (TEST)' : ''}`;
    document.getElementById('playerName').textContent = displayName;
    document.getElementById('playerTeam').textContent = currentPlayer.currentTeam || currentPlayer.seasons?.['2025-fall']?.team || 'Mountainside Aces';
    
    // Set profile link
    const profileLink = document.getElementById('fullProfileLink');
    const backLink = document.getElementById('backToProfileLink');
    const profileUrl = `player.html?id=${currentPlayer.id}`;
    profileLink.href = profileUrl;
    backLink.href = profileUrl;
    
    // Try to load photo
    loadPlayerPhoto();
  }
  
  async function loadPlayerPhoto() {
    try {
      const displayName = currentPlayer.name || currentPlayer.displayName;
      let playerPhotoURL = null;
      
      // Method 1: Query users collection for linkedPlayer matching display name
      const usersRef = collection(db, 'users');
      const q = query(usersRef, where('linkedPlayer', '==', displayName));
      const querySnapshot = await getDocs(q);
      
      if (!querySnapshot.empty) {
        const userDoc = querySnapshot.docs[0];
        const userData = userDoc.data();
        
        console.log('üîó Found linked user for player:', displayName);
        
        if (userData.playerPhotoURL) {
          playerPhotoURL = userData.playerPhotoURL;
        } else if (userData.profilePhotoURL) {
          playerPhotoURL = userData.profilePhotoURL;
        }
      }
      
      // Method 2: Direct lookup if player ID matches a user document
      if (!playerPhotoURL && currentPlayer.id) {
        const directUserDoc = await getDoc(doc(db, 'users', currentPlayer.id));
        if (directUserDoc.exists()) {
          const userData = directUserDoc.data();
          if (userData.playerPhotoURL) {
            playerPhotoURL = userData.playerPhotoURL;
          } else if (userData.profilePhotoURL) {
            playerPhotoURL = userData.profilePhotoURL;
          }
        }
      }
      
      // Apply photo if found
      if (playerPhotoURL) {
        const photoEl = document.getElementById('playerPhoto');
        const placeholderEl = document.getElementById('playerPhotoPlaceholder');
        
        photoEl.src = playerPhotoURL;
        photoEl.onload = () => {
          photoEl.classList.add('loaded');
          placeholderEl.classList.add('hidden');
        };
      }
    } catch (error) {
      console.warn('Could not load player photo:', error);
    }
  }
  
  // Load game stats ONLY for game log display
  async function loadGameStatsForLog() {
    gameStats = [];
    
    // Get the legacy ID for querying game stats
    const legacyId = currentPlayer.name ? 
      currentPlayer.name.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_') : 
      currentPlayer.id;
    
    console.log(`üìã Loading game log for legacyId: ${legacyId}`);
    
    try {
      // Game stats are always in playerStats (not a test collection)
      const gamesRef = collection(db, 'playerStats', legacyId, 'games');
      const gamesSnap = await getDocs(gamesRef);
      
      gamesSnap.forEach(docSnap => {
        const data = docSnap.data();
        // Include games from 2025+ (game data era)
        if (data.seasonId && data.seasonId >= MIN_GAME_DATA_SEASON) {
          gameStats.push({
            id: docSnap.id,
            ...data
          });
        }
      });
      
      // Sort by date descending
      gameStats.sort((a, b) => {
        const dateA = a.gameDate?.seconds || 0;
        const dateB = b.gameDate?.seconds || 0;
        return dateB - dateA;
      });
      
      console.log(`‚úÖ Loaded ${gameStats.length} games for game log`);
      
    } catch (error) {
      console.warn('Could not load game stats for log:', error);
    }
  }
  
  function populateSeasonFilter() {
    const filterSelect = document.getElementById('seasonFilter');
    const eligibleSeasons = new Set();
    
    // Add 2026+ seasons from main collection that have splits
    if (currentPlayer.seasons) {
      Object.keys(currentPlayer.seasons)
        .filter(s => s >= FULL_DATA_START_SEASON && currentPlayer.seasons[s].splits)
        .forEach(s => eligibleSeasons.add(s));
    }
    
    // Add 2025 seasons from splits collection
    if (splits2025Data?.seasons) {
      Object.keys(splits2025Data.seasons)
        .filter(s => splits2025Data.seasons[s].splits)
        .forEach(s => eligibleSeasons.add(s));
    }
    
    // Sort and add season options
    const sortedSeasons = Array.from(eligibleSeasons).sort().reverse();
    
    sortedSeasons.forEach(seasonId => {
      const [year, season] = seasonId.split('-');
      const displayName = `${year} ${season.charAt(0).toUpperCase() + season.slice(1)}`;
      const option = document.createElement('option');
      option.value = seasonId;
      
      // Mark 2025 seasons as partial
      if (is2025Season(seasonId)) {
        option.textContent = `${displayName} ‚ö†Ô∏è`;
        option.title = 'Partial data';
      } else {
        option.textContent = displayName;
      }
      
      filterSelect.appendChild(option);
    });
    
    // Add event listener
    filterSelect.addEventListener('change', (e) => {
      currentFilter = e.target.value;
      updateFilterInfo();
      updateIncompleteDataBanner();
      renderAllSplits();
      renderGameLog();
    });
  }
  
  function updateFilterInfo() {
    const filterInfo = document.getElementById('filterInfo');
    
    if (currentFilter === 'career') {
      if (splits2025Data) {
        filterInfo.textContent = 'Career splits (2025 data is partial)';
        filterInfo.classList.add('partial-data');
      } else {
        filterInfo.textContent = 'Showing career splits';
        filterInfo.classList.remove('partial-data');
      }
    } else {
      const [year, season] = currentFilter.split('-');
      const seasonName = `${year} ${season.charAt(0).toUpperCase() + season.slice(1)}`;
      
      if (is2025Season(currentFilter)) {
        filterInfo.textContent = `${seasonName} splits (partial data)`;
        filterInfo.classList.add('partial-data');
      } else {
        filterInfo.textContent = `Showing ${seasonName} splits`;
        filterInfo.classList.remove('partial-data');
      }
    }
  }
  
  function updateIncompleteDataBanner() {
    const banner = document.getElementById('incompleteDataBanner');
    const message = document.getElementById('incompleteDataMessage');
    
    if (isPartialDataSelection()) {
      banner.classList.remove('hidden');
      
      if (currentFilter === 'career') {
        message.textContent = 'Career splits include 2025 data which is incomplete. Game-level split data for 2025 seasons does not include all games or players. Complete game-level tracking begins with the 2026 Summer season.';
      } else {
        const [year, season] = currentFilter.split('-');
        message.textContent = `Game-level split data for ${year} ${season.charAt(0).toUpperCase() + season.slice(1)} is incomplete and does not include all games or players. Complete game-level tracking begins with the 2026 Summer season.`;
      }
    } else {
      banner.classList.add('hidden');
    }
  }
  
  // Get splits data based on filter - handles both collections
  function getSplitsData() {
    if (currentFilter === 'career') {
      // For career, combine data from both sources
      return getCombinedCareerSplits();
    }
    
    // For specific season, check which collection has the data
    if (is2025Season(currentFilter)) {
      // 2025 seasons: use 2025 splits collection
      return splits2025Data?.seasons?.[currentFilter]?.splits || null;
    } else {
      // 2026+ seasons: use main collection
      return currentPlayer.seasons?.[currentFilter]?.splits || null;
    }
  }
  
  // Combine career splits from both collections
  function getCombinedCareerSplits() {
    const mainCareerSplits = currentPlayer.career?.splits;
    const splits2025CareerSplits = splits2025Data?.careerSplits?.splits;
    
    // If only one source exists, use it
    if (!mainCareerSplits && !splits2025CareerSplits) return null;
    if (!mainCareerSplits) return splits2025CareerSplits;
    if (!splits2025CareerSplits) return mainCareerSplits;
    
    // Combine both sources
    const combined = {
      home: combineStatObjects(mainCareerSplits.home, splits2025CareerSplits.home),
      away: combineStatObjects(mainCareerSplits.away, splits2025CareerSplits.away),
      regular: combineStatObjects(mainCareerSplits.regular, splits2025CareerSplits.regular),
      playoff: combineStatObjects(mainCareerSplits.playoff, splits2025CareerSplits.playoff)
    };
    
    // Recalculate averages
    ['home', 'away', 'regular', 'playoff'].forEach(key => {
      const split = combined[key];
      split.battingAverage = split.atBats > 0 ? split.hits / split.atBats : 0;
      split.onBasePercentage = (split.atBats + split.walks) > 0
        ? (split.hits + split.walks) / (split.atBats + split.walks) : 0;
    });
    
    return combined;
  }
  
  // Helper to combine stat objects
  function combineStatObjects(obj1, obj2) {
    if (!obj1 && !obj2) return { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    if (!obj1) return { ...obj2 };
    if (!obj2) return { ...obj1 };
    
    return {
      games: (obj1.games || 0) + (obj2.games || 0),
      atBats: (obj1.atBats || 0) + (obj2.atBats || 0),
      hits: (obj1.hits || 0) + (obj2.hits || 0),
      runs: (obj1.runs || 0) + (obj2.runs || 0),
      walks: (obj1.walks || 0) + (obj2.walks || 0),
      doubles: (obj1.doubles || 0) + (obj2.doubles || 0),
      triples: (obj1.triples || 0) + (obj2.triples || 0),
      homeRuns: (obj1.homeRuns || 0) + (obj2.homeRuns || 0),
      rbi: (obj1.rbi || 0) + (obj2.rbi || 0)
    };
  }
  
  // Get vsOpponent data based on filter - handles both collections
  function getVsOpponentData() {
    if (currentFilter === 'career') {
      return getCombinedCareerVsOpponent();
    }
    
    if (is2025Season(currentFilter)) {
      return splits2025Data?.seasons?.[currentFilter]?.vsOpponent || {};
    } else {
      return currentPlayer.seasons?.[currentFilter]?.vsOpponent || {};
    }
  }
  
  // Combine career vsOpponent from both collections
  function getCombinedCareerVsOpponent() {
    const mainVsOpponent = currentPlayer.career?.vsOpponent || {};
    const splits2025VsOpponent = splits2025Data?.careerSplits?.vsOpponent || {};
    
    const combined = { ...mainVsOpponent };
    
    // Merge in 2025 data
    Object.entries(splits2025VsOpponent).forEach(([opponent, stats]) => {
      if (combined[opponent]) {
        combined[opponent] = combineStatObjects(combined[opponent], stats);
        // Recalculate averages
        combined[opponent].battingAverage = combined[opponent].atBats > 0 
          ? combined[opponent].hits / combined[opponent].atBats : 0;
        combined[opponent].onBasePercentage = (combined[opponent].atBats + combined[opponent].walks) > 0
          ? (combined[opponent].hits + combined[opponent].walks) / (combined[opponent].atBats + combined[opponent].walks) : 0;
      } else {
        combined[opponent] = { ...stats };
      }
    });
    
    return combined;
  }
  
  // Get filtered games for game log
  function getFilteredGames() {
    if (currentFilter === 'career') {
      return gameStats;
    }
    return gameStats.filter(g => g.seasonId === currentFilter);
  }
  
  function renderAllSplits() {
    const splits = getSplitsData();
    const vsOpponent = getVsOpponentData();
    
    console.log('Rendering splits:', splits);
    console.log('Rendering vsOpponent:', vsOpponent);
    
    if (!splits || (splits.home?.games === 0 && splits.away?.games === 0)) {
      // No splits data
      document.getElementById('splitsGrid').style.display = 'none';
      document.getElementById('opponentSection').style.display = 'none';
      document.getElementById('gameLogSection').style.display = 'none';
      document.getElementById('noDataMessage').style.display = 'block';
      return;
    }
    
    // Show all sections
    document.getElementById('splitsGrid').style.display = 'grid';
    document.getElementById('opponentSection').style.display = 'block';
    document.getElementById('gameLogSection').style.display = 'block';
    document.getElementById('noDataMessage').style.display = 'none';
    
    renderPlayoffSplit(splits);
    renderHomeAwaySplit(splits);
    renderOpponentBreakdown(vsOpponent);
  }
  
  function renderPlayoffSplit(splits) {
    const content = document.getElementById('playoffSplitContent');
    
    const regular = splits.regular || { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    const playoff = splits.playoff || { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    
    if (regular.games === 0 && playoff.games === 0) {
      content.innerHTML = `
        <div class="no-data">
          <div class="no-data-icon">üìä</div>
          <p>No game data available for this selection.</p>
        </div>
      `;
      return;
    }
    
    const regularAvg = formatAvg(regular.battingAverage);
    const regularOBP = formatAvg(regular.onBasePercentage);
    const playoffAvg = formatAvg(playoff.battingAverage);
    const playoffOBP = formatAvg(playoff.onBasePercentage);
    
    // Determine better stats
    const avgClass = highlightBetter(regular.battingAverage || 0, playoff.battingAverage || 0);
    const obpClass = highlightBetter(regular.onBasePercentage || 0, playoff.onBasePercentage || 0);
    
    content.innerHTML = `
      <table class="split-table">
        <thead>
          <tr>
            <th>Split</th>
            <th>G</th>
            <th>AB</th>
            <th>H</th>
            <th>R</th>
            <th>BB</th>
            <th>AVG</th>
            <th>OBP</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <div class="split-label">
                <span class="split-icon">üìÖ</span> Regular Season
              </div>
            </td>
            <td>${regular.games}</td>
            <td>${regular.atBats}</td>
            <td>${regular.hits}</td>
            <td>${regular.runs}</td>
            <td>${regular.walks}</td>
            <td class="${avgClass[0]}">${regularAvg}</td>
            <td class="${obpClass[0]}">${regularOBP}</td>
          </tr>
          <tr>
            <td>
              <div class="split-label">
                <span class="split-icon">üèÜ</span> Playoffs
              </div>
            </td>
            <td>${playoff.games}</td>
            <td>${playoff.atBats}</td>
            <td>${playoff.hits}</td>
            <td>${playoff.runs}</td>
            <td>${playoff.walks}</td>
            <td class="${avgClass[1]}">${playoffAvg}</td>
            <td class="${obpClass[1]}">${playoffOBP}</td>
          </tr>
        </tbody>
      </table>
    `;
  }
  
  function renderHomeAwaySplit(splits) {
    const content = document.getElementById('homeAwaySplitContent');
    
    const home = splits.home || { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    const away = splits.away || { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    
    if (home.games === 0 && away.games === 0) {
      content.innerHTML = `
        <div class="no-data">
          <div class="no-data-icon">üìä</div>
          <p>No game data available for this selection.</p>
        </div>
      `;
      return;
    }
    
    const homeAvg = formatAvg(home.battingAverage);
    const homeOBP = formatAvg(home.onBasePercentage);
    const awayAvg = formatAvg(away.battingAverage);
    const awayOBP = formatAvg(away.onBasePercentage);
    
    const avgClass = highlightBetter(home.battingAverage || 0, away.battingAverage || 0);
    const obpClass = highlightBetter(home.onBasePercentage || 0, away.onBasePercentage || 0);
    
    content.innerHTML = `
      <table class="split-table">
        <thead>
          <tr>
            <th>Split</th>
            <th>G</th>
            <th>AB</th>
            <th>H</th>
            <th>R</th>
            <th>BB</th>
            <th>AVG</th>
            <th>OBP</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <div class="split-label">
                <span class="split-icon">üè†</span> Home
              </div>
            </td>
            <td>${home.games}</td>
            <td>${home.atBats}</td>
            <td>${home.hits}</td>
            <td>${home.runs}</td>
            <td>${home.walks}</td>
            <td class="${avgClass[0]}">${homeAvg}</td>
            <td class="${obpClass[0]}">${homeOBP}</td>
          </tr>
          <tr>
            <td>
              <div class="split-label">
                <span class="split-icon">‚úàÔ∏è</span> Away
              </div>
            </td>
            <td>${away.games}</td>
            <td>${away.atBats}</td>
            <td>${away.hits}</td>
            <td>${away.runs}</td>
            <td>${away.walks}</td>
            <td class="${avgClass[1]}">${awayAvg}</td>
            <td class="${obpClass[1]}">${awayOBP}</td>
          </tr>
        </tbody>
      </table>
    `;
  }
  
  function renderOpponentBreakdown(vsOpponent) {
    const tbody = document.getElementById('opponentTableBody');
    
    if (!vsOpponent || Object.keys(vsOpponent).length === 0) {
      tbody.innerHTML = `
        <tr>
          <td colspan="8" style="text-align: center; padding: 2rem; color: #718096;">
            No opponent data available for this selection.
          </td>
        </tr>
      `;
      return;
    }
    
    // Sort opponents by games played (descending)
    const opponents = Object.entries(vsOpponent)
      .map(([name, stats]) => ({
        name,
        ...stats,
        avg: formatAvg(stats.battingAverage),
        obp: formatAvg(stats.onBasePercentage)
      }))
      .sort((a, b) => b.games - a.games);
    
    tbody.innerHTML = opponents.map(opp => `
      <tr>
        <td>
          ${getTeamColorDot(opp.name)}
          ${opp.name}
        </td>
        <td>${opp.games}</td>
        <td>${opp.atBats}</td>
        <td>${opp.hits}</td>
        <td>${opp.runs}</td>
        <td>${opp.walks}</td>
        <td>${opp.avg}</td>
        <td>${opp.obp}</td>
      </tr>
    `).join('');
  }
  
  function renderGameLog() {
    const tbody = document.getElementById('gameLogTableBody');
    const filteredGames = getFilteredGames();
    
    if (filteredGames.length === 0) {
      tbody.innerHTML = `
        <tr>
          <td colspan="9" style="text-align: center; padding: 2rem; color: #718096;">
            No games recorded for this selection.
          </td>
        </tr>
      `;
      return;
    }
    
    // Sort games
    const sortedGames = sortGames(filteredGames);
    
    tbody.innerHTML = sortedGames.map(g => {
      const isPlayoff = g.isPlayoff === true || g.gameType === 'playoff';
      const gameTypeClass = isPlayoff ? 'game-type-playoff' : 'game-type-regular';
      const gameTypeLabel = isPlayoff ? 'Playoff' : 'Regular';
      const homeAwayClass = g.isHome ? 'badge-home' : 'badge-away';
      const homeAwayLabel = g.isHome ? 'Home' : 'Away';
      const gameAvg = calculateAvg(g.hits || 0, g.atBats || 0);
      
      return `
        <tr>
          <td>${formatDate(g.gameDate)}</td>
          <td>${getTeamColorDot(g.opponent || 'Unknown')}${g.opponent || 'Unknown'}</td>
          <td><span class="home-away-badge ${homeAwayClass}">${homeAwayLabel}</span></td>
          <td><span class="game-type-badge ${gameTypeClass}">${gameTypeLabel}</span></td>
          <td>${g.atBats || 0}</td>
          <td>${g.hits || 0}</td>
          <td>${g.runs || 0}</td>
          <td>${g.walks || 0}</td>
          <td>${gameAvg}</td>
        </tr>
      `;
    }).join('');
  }
  
  function sortGames(games) {
    return [...games].sort((a, b) => {
      let valA, valB;
      
      switch (currentSort.column) {
        case 'date':
          valA = a.gameDate?.seconds || 0;
          valB = b.gameDate?.seconds || 0;
          break;
        case 'opponent':
          valA = (a.opponent || '').toLowerCase();
          valB = (b.opponent || '').toLowerCase();
          break;
        case 'homeAway':
          valA = a.isHome ? 1 : 0;
          valB = b.isHome ? 1 : 0;
          break;
        case 'gameType':
          valA = (a.isPlayoff || a.gameType === 'playoff') ? 1 : 0;
          valB = (b.isPlayoff || b.gameType === 'playoff') ? 1 : 0;
          break;
        case 'ab':
          valA = a.atBats || 0;
          valB = b.atBats || 0;
          break;
        case 'h':
          valA = a.hits || 0;
          valB = b.hits || 0;
          break;
        case 'r':
          valA = a.runs || 0;
          valB = b.runs || 0;
          break;
        case 'bb':
          valA = a.walks || 0;
          valB = b.walks || 0;
          break;
        case 'avg':
          valA = a.atBats > 0 ? a.hits / a.atBats : 0;
          valB = b.atBats > 0 ? b.hits / b.atBats : 0;
          break;
        default:
          valA = a.gameDate?.seconds || 0;
          valB = b.gameDate?.seconds || 0;
      }
      
      if (typeof valA === 'string') {
        return currentSort.direction === 'asc' 
          ? valA.localeCompare(valB) 
          : valB.localeCompare(valA);
      }
      
      return currentSort.direction === 'asc' ? valA - valB : valB - valA;
    });
  }
  
  // Setup sort handlers
  function setupSortHandlers() {
    const headers = document.querySelectorAll('.game-log-table th[data-sort]');
    headers.forEach(th => {
      th.addEventListener('click', () => {
        const column = th.dataset.sort;
        
        // Toggle direction if same column
        if (currentSort.column === column) {
          currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
          currentSort.column = column;
          currentSort.direction = 'desc';
        }
        
        // Update header classes
        headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
        th.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
        
        // Re-render
        renderGameLog();
      });
    });
  }
  
  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setupSortHandlers();
      loadPlayerData();
    });
  } else {
    setupSortHandlers();
    loadPlayerData();
  }
</script>

<script type="module">
  import { NavigationComponent } from './nav-component.js';
</script>
<script src="mobile-enhancements.js"></script>
</body>
</html>

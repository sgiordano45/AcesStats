<!DOCTYPE html>
<html lang="en">
<head>
<link rel="manifest" href="/manifest.json">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title id="pageTitle">Player Splits</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 20px;
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
    min-height: 100vh;
  }
  
  .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    opacity: 1;
    visibility: visible;
  }
  
  .loading-overlay.hidden {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
  }
  
  .softball-spinner {
    text-align: center;
  }
  
  .softball-spinner::before {
    content: '‚öæ';
    font-size: 80px;
    display: block;
    animation: spin 1.5s ease-in-out infinite;
    margin-bottom: 20px;
  }
  
  .softball-spinner::after {
    content: 'Loading player splits...';
    display: block;
    font-size: 1.2rem;
    color: #4a5568;
    font-weight: 600;
  }
  
  @keyframes spin {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
  }
  
  .page-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 2rem;
  }
  
  /* Compact Player Header */
  .player-header-compact {
    background: linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%);
    color: white;
    padding: 1.5rem 2rem;
    border-radius: 16px;
    margin-bottom: 2rem;
    display: flex;
    align-items: center;
    gap: 20px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    position: relative;
    overflow: hidden;
  }
  
  .player-header-compact::before {
    content: "";
    position: absolute;
    top: -50%;
    right: -10%;
    width: 300px;
    height: 300px;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }
  
  .player-photo-small {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255,255,255,0.3);
    display: none;
    flex-shrink: 0;
  }
  
  .player-photo-small.loaded {
    display: block;
  }
  
  .player-photo-placeholder-small {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    border: 3px solid rgba(255,255,255,0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    color: rgba(255,255,255,0.5);
    flex-shrink: 0;
  }
  
  .player-photo-placeholder-small.hidden {
    display: none;
  }
  
  .player-info-compact {
    flex: 1;
    z-index: 1;
  }
  
  .player-info-compact h1 {
    margin: 0 0 4px 0;
    font-size: 1.8rem;
    font-weight: 700;
  }
  
  .player-info-compact .player-team {
    font-size: 1rem;
    opacity: 0.9;
  }
  
  .header-actions {
    display: flex;
    gap: 10px;
    z-index: 1;
  }
  
  /* Navigation Buttons */
  .nav-button {
    background: rgba(255,255,255,0.15);
    color: white;
    border: 2px solid rgba(255,255,255,0.3);
    padding: 10px 18px;
    border-radius: 10px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  
  .nav-button:hover {
    background: rgba(255,255,255,0.25);
    transform: translateY(-2px);
  }
  
  /* Filter Bar */
  .filter-bar {
    background: white;
    border-radius: 12px;
    padding: 1rem 1.5rem;
    margin-bottom: 2rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }
  
  .filter-label {
    font-weight: 600;
    color: #2d3748;
  }
  
  .filter-select {
    padding: 8px 16px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    background: white;
    cursor: pointer;
    transition: border-color 0.3s ease;
    min-width: 180px;
  }
  
  .filter-select:focus {
    outline: none;
    border-color: #2d5016;
  }
  
  .filter-info {
    margin-left: auto;
    color: #718096;
    font-size: 0.9rem;
  }
  
  /* Split Sections */
  .splits-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    margin-bottom: 2rem;
  }
  
  .split-card {
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    border: 1px solid #e2e8f0;
  }
  
  .split-card-header {
    background: linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%);
    color: white;
    padding: 1rem 1.5rem;
    font-size: 1.2rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .split-card-content {
    padding: 0;
  }
  
  /* Split Tables */
  .split-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .split-table th,
  .split-table td {
    padding: 12px 16px;
    text-align: center;
    border-bottom: 1px solid #e2e8f0;
  }
  
  .split-table th {
    background: #f7fafc;
    color: #2d3748;
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .split-table th:first-child,
  .split-table td:first-child {
    text-align: left;
    font-weight: 600;
  }
  
  .split-table tbody tr:hover {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  }
  
  .split-table tbody tr:last-child td {
    border-bottom: none;
  }
  
  .split-label {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .split-icon {
    font-size: 1.2rem;
  }
  
  /* Comparison Highlights */
  .stat-better {
    color: #2d5016;
    font-weight: 700;
  }
  
  .stat-worse {
    color: #c53030;
  }
  
  /* Opponent Section - Full Width */
  .opponent-section {
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    border: 1px solid #e2e8f0;
    margin-bottom: 2rem;
  }
  
  .opponent-header {
    background: linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%);
    color: white;
    padding: 1rem 1.5rem;
    font-size: 1.2rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  
  .opponent-header:hover {
    background: linear-gradient(135deg, #3d6a1e 0%, #2a8b5a 100%);
  }
  
  .opponent-toggle {
    font-size: 1.5rem;
    transition: transform 0.3s ease;
  }
  
  .opponent-toggle.collapsed {
    transform: rotate(-90deg);
  }
  
  .opponent-content {
    max-height: 1000px;
    overflow: hidden;
    transition: max-height 0.4s ease;
  }
  
  .opponent-content.collapsed {
    max-height: 0;
  }
  
  .opponent-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .opponent-table th,
  .opponent-table td {
    padding: 12px 16px;
    text-align: center;
    border-bottom: 1px solid #e2e8f0;
  }
  
  .opponent-table th {
    background: #f7fafc;
    color: #2d3748;
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    position: sticky;
    top: 0;
  }
  
  .opponent-table th:first-child,
  .opponent-table td:first-child {
    text-align: left;
    font-weight: 600;
  }
  
  .opponent-table tbody tr:hover {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  }
  
  .team-color-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
  }
  
  /* Game Log Section */
  .game-log-section {
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    border: 1px solid #e2e8f0;
    margin-bottom: 2rem;
  }
  
  .game-log-header {
    background: linear-gradient(135deg, #2d5016 0%, #1a6b4a 100%);
    color: white;
    padding: 1rem 1.5rem;
    font-size: 1.2rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .game-log-wrapper {
    overflow-x: auto;
  }
  
  .game-log-table {
    width: 100%;
    border-collapse: collapse;
    min-width: 800px;
  }
  
  .game-log-table th,
  .game-log-table td {
    padding: 12px 14px;
    text-align: center;
    border-bottom: 1px solid #e2e8f0;
    white-space: nowrap;
  }
  
  .game-log-table th {
    background: #f7fafc;
    color: #2d3748;
    font-weight: 700;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: pointer;
    user-select: none;
    position: sticky;
    top: 0;
    transition: background 0.2s ease;
  }
  
  .game-log-table th:hover {
    background: #edf2f7;
  }
  
  .game-log-table th.sort-asc::after {
    content: ' ‚Üë';
  }
  
  .game-log-table th.sort-desc::after {
    content: ' ‚Üì';
  }
  
  .game-log-table tbody tr:hover {
    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  }
  
  .game-type-badge {
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
  }
  
  .game-type-regular {
    background: #e2e8f0;
    color: #4a5568;
  }
  
  .game-type-playoff {
    background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
    color: #744210;
  }
  
  .home-away-badge {
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
  }
  
  .badge-home {
    background: #c6f6d5;
    color: #22543d;
  }
  
  .badge-away {
    background: #fed7d7;
    color: #742a2a;
  }
  
  /* No Data State */
  .no-data {
    padding: 3rem 2rem;
    text-align: center;
    color: #718096;
  }
  
  .no-data-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.3;
  }
  
  .no-data h3 {
    font-size: 1.3rem;
    color: #2d3748;
    margin-bottom: 0.5rem;
  }
  
  .no-data p {
    max-width: 400px;
    margin: 0 auto;
    line-height: 1.6;
  }
  
  /* Mobile Responsive */
  @media (max-width: 768px) {
    body {
      padding: 10px;
    }
    
    .page-container {
      padding: 0 1rem;
    }
    
    .player-header-compact {
      flex-direction: column;
      text-align: center;
      padding: 1.5rem;
    }
    
    .player-info-compact h1 {
      font-size: 1.5rem;
    }
    
    .header-actions {
      flex-direction: column;
      width: 100%;
    }
    
    .nav-button {
      justify-content: center;
    }
    
    .filter-bar {
      flex-direction: column;
      align-items: stretch;
    }
    
    .filter-select {
      width: 100%;
    }
    
    .filter-info {
      margin-left: 0;
      text-align: center;
    }
    
    .splits-grid {
      grid-template-columns: 1fr;
    }
    
    .split-table th,
    .split-table td {
      padding: 10px 8px;
      font-size: 0.85rem;
    }
    
    .opponent-table th,
    .opponent-table td {
      padding: 10px 8px;
      font-size: 0.85rem;
    }
  }
</style>
</head>
<body>

<div class="loading-overlay" id="loadingOverlay">
  <div class="softball-spinner"></div>
</div>

<div class="page-container">
  
  <!-- Compact Player Header -->
  <div class="player-header-compact" id="playerHeader" style="display: none;">
    <img id="playerPhoto" class="player-photo-small" alt="Player Photo" onerror="this.style.display='none'; document.getElementById('playerPhotoPlaceholder').classList.remove('hidden');">
    <div id="playerPhotoPlaceholder" class="player-photo-placeholder-small">‚öæ</div>
    
    <div class="player-info-compact">
      <h1 id="playerName">Player Name</h1>
      <div class="player-team" id="playerTeam">Team</div>
    </div>
    
    <div class="header-actions">
      <a id="fullProfileLink" class="nav-button" href="#">
        ‚Üê Full Profile
      </a>
    </div>
  </div>
  
  <!-- Filter Bar -->
  <div class="filter-bar" id="filterBar" style="display: none;">
    <span class="filter-label">üìä View Stats:</span>
    <select id="seasonFilter" class="filter-select">
      <option value="career">Career Totals</option>
    </select>
    <span class="filter-info" id="filterInfo">Showing career splits</span>
  </div>
  
  <!-- Split Cards Grid -->
  <div class="splits-grid" id="splitsGrid" style="display: none;">
    
    <!-- Playoffs vs Regular Season -->
    <div class="split-card">
      <div class="split-card-header">
        <span>üèÜ</span> Playoffs vs Regular Season
      </div>
      <div class="split-card-content" id="playoffSplitContent">
        <div class="no-data">
          <div class="no-data-icon">üìä</div>
          <p>Loading...</p>
        </div>
      </div>
    </div>
    
    <!-- Home vs Away -->
    <div class="split-card">
      <div class="split-card-header">
        <span>üè†</span> Home vs Away
      </div>
      <div class="split-card-content" id="homeAwaySplitContent">
        <div class="no-data">
          <div class="no-data-icon">üìä</div>
          <p>Loading...</p>
        </div>
      </div>
    </div>
    
  </div>
  
  <!-- Opponent Breakdown Section -->
  <div class="opponent-section" id="opponentSection" style="display: none;">
    <div class="opponent-header" id="opponentHeader" onclick="toggleOpponentSection()">
      <div style="display: flex; align-items: center; gap: 10px;">
        <span>‚öîÔ∏è</span> Performance by Opponent
      </div>
      <span class="opponent-toggle" id="opponentToggle">‚ñº</span>
    </div>
    <div class="opponent-content" id="opponentContent">
      <table class="opponent-table">
        <thead>
          <tr>
            <th>Opponent</th>
            <th>G</th>
            <th>AB</th>
            <th>H</th>
            <th>R</th>
            <th>BB</th>
            <th>AVG</th>
            <th>OBP</th>
          </tr>
        </thead>
        <tbody id="opponentTableBody">
        </tbody>
      </table>
    </div>
  </div>
  
  <!-- Game Log Section -->
  <div class="game-log-section" id="gameLogSection" style="display: none;">
    <div class="game-log-header">
      <span>üìã</span> Game Log
    </div>
    <div class="game-log-wrapper">
      <table class="game-log-table">
        <thead>
          <tr>
            <th data-sort="date">Date</th>
            <th data-sort="opponent">Opponent</th>
            <th data-sort="homeAway">H/A</th>
            <th data-sort="gameType">Type</th>
            <th data-sort="ab">AB</th>
            <th data-sort="h">H</th>
            <th data-sort="r">R</th>
            <th data-sort="bb">BB</th>
            <th data-sort="avg">AVG</th>
          </tr>
        </thead>
        <tbody id="gameLogTableBody">
        </tbody>
      </table>
    </div>
  </div>
  
  <!-- No Data Message (shown when no game-level data exists) -->
  <div class="no-data" id="noDataMessage" style="display: none;">
    <div class="no-data-icon">üìä</div>
    <h3>Game-Level Data Not Available</h3>
    <p>Detailed game-by-game statistics are available starting with the 2025 Fall season. Check back once game data has been recorded.</p>
    <a id="backToProfileLink" class="nav-button" href="#" style="margin-top: 1.5rem; background: #2d5016; color: white;">
      ‚Üê Back to Player Profile
    </a>
  </div>
  
</div>

<script type="module">
  import { 
    db, 
    doc, 
    getDoc,
    collection,
    getDocs,
    query,
    where
  } from './firebase-config.js';
  
  // Get player ID from URL
  const urlParams = new URLSearchParams(window.location.search);
  const playerId = urlParams.get('id');
  const playerName = urlParams.get('player');
  const testMode = urlParams.get('test') === 'true';
  
  // Collection names based on test mode
  const AGGREGATED_COLLECTION = testMode ? 'aggregatedPlayerStats_test' : 'aggregatedPlayerStats';
  
  // Show test mode banner if enabled
  if (testMode) {
    console.log('üß™ TEST MODE ENABLED - Reading from aggregatedPlayerStats_test');
    const banner = document.createElement('div');
    banner.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
      padding: 8px 16px;
      text-align: center;
      font-weight: 600;
      font-size: 0.9rem;
      z-index: 10000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    `;
    banner.innerHTML = 'üß™ TEST MODE - Reading from <code style="background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 4px;">aggregatedPlayerStats_test</code>';
    document.body.prepend(banner);
    document.body.style.paddingTop = '40px';
  }
  
  // Team colors for opponent display
  const teamColors = {
    'White': '#f0f0f0',
    'Blue': '#1e90ff',
    'Green': '#228b22',
    'Gray': '#808080',
    'Grey': '#808080',
    'Red': '#dc143c',
    'Orange': '#ff8c00',
    'Yellow': '#ffd700',
    'Purple': '#8b008b',
    'Black': '#333333'
  };
  
  // State
  let currentPlayer = null;
  let gameStats = [];        // Only loaded for game log
  let currentFilter = 'career';
  let currentSort = { column: 'date', direction: 'desc' };
  
  // Minimum season for game-level data
  const MIN_GAME_DATA_SEASON = '2025-fall';
  
  function hideLoadingIndicator() {
    document.getElementById('loadingOverlay').classList.add('hidden');
  }
  
  function formatDate(dateValue) {
    if (!dateValue) return 'N/A';
    
    let date;
    if (dateValue.seconds) {
      date = new Date(dateValue.seconds * 1000);
    } else if (dateValue instanceof Date) {
      date = dateValue;
    } else {
      date = new Date(dateValue);
    }
    
    if (isNaN(date.getTime())) return 'N/A';
    
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
  }
  
  function getTeamColorDot(teamName) {
    const color = teamColors[teamName] || '#888888';
    const border = teamName === 'White' ? 'border: 1px solid #ccc;' : '';
    return `<span class="team-color-dot" style="background: ${color}; ${border}"></span>`;
  }
  
  function formatAvg(value) {
    if (typeof value !== 'number' || isNaN(value)) return '.000';
    return value.toFixed(3).replace(/^0/, '');
  }
  
  function calculateAvg(hits, atBats) {
    if (atBats === 0) return '.000';
    return (hits / atBats).toFixed(3).replace(/^0/, '');
  }
  
  function calculateOBP(hits, walks, atBats) {
    const pa = atBats + walks;
    if (pa === 0) return '.000';
    return ((hits + walks) / pa).toFixed(3).replace(/^0/, '');
  }
  
  function highlightBetter(val1, val2, higherIsBetter = true) {
    if (val1 === val2) return ['', ''];
    if (higherIsBetter) {
      return val1 > val2 ? ['stat-better', 'stat-worse'] : ['stat-worse', 'stat-better'];
    } else {
      return val1 < val2 ? ['stat-better', 'stat-worse'] : ['stat-worse', 'stat-better'];
    }
  }
  
  // Toggle opponent section collapse
  window.toggleOpponentSection = function() {
    const content = document.getElementById('opponentContent');
    const toggle = document.getElementById('opponentToggle');
    content.classList.toggle('collapsed');
    toggle.classList.toggle('collapsed');
  };
  
  // Get player from aggregated collection (respects test mode)
  async function getPlayerFromAggregated(id) {
    try {
      const docRef = doc(db, AGGREGATED_COLLECTION, id);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists() && !docSnap.data().migrated) {
        return { id: docSnap.id, ...docSnap.data() };
      }
      return null;
    } catch (error) {
      console.error('Error fetching from aggregated collection:', error);
      return null;
    }
  }
  
  // Resolve player name from aggregated collection (respects test mode)
  async function resolvePlayerFromAggregated(searchName) {
    try {
      console.log(`üîç Resolving player name: "${searchName}" from ${AGGREGATED_COLLECTION}`);
      
      const statsRef = collection(db, AGGREGATED_COLLECTION);
      const snapshot = await getDocs(statsRef);
      
      const searchLower = searchName.toLowerCase();
      const searchNormalized = searchName.toLowerCase().replace(/\s+/g, '_');
      
      let foundPlayer = null;
      let bestMatch = null;
      let bestMatchScore = 0;
      
      snapshot.forEach(docSnap => {
        const data = docSnap.data();
        if (data.migrated === true) return;
        
        const dataName = (data.name || data.displayName || '').toLowerCase();
        const dataNameNormalized = dataName.replace(/\s+/g, '_');
        
        // Exact match
        if (dataName === searchLower || docSnap.id === searchNormalized) {
          foundPlayer = { id: docSnap.id, ...data };
          return;
        }
        
        // Normalized match
        if (dataNameNormalized === searchNormalized) {
          if (bestMatchScore < 90) {
            bestMatch = { id: docSnap.id, ...data };
            bestMatchScore = 90;
          }
        }
      });
      
      return foundPlayer || bestMatch;
    } catch (error) {
      console.error('Error resolving player:', error);
      return null;
    }
  }
  
  // Load player data
  async function loadPlayerData() {
    console.log(`‚ö° Loading splits for: ${playerId ? `ID=${playerId}` : `name=${playerName}`}`);
    console.log(`üìÇ Using collection: ${AGGREGATED_COLLECTION}`);
    
    try {
      let resolvedPlayer;
      
      if (playerId) {
        // Try direct lookup first
        resolvedPlayer = await getPlayerFromAggregated(playerId);
        
        if (!resolvedPlayer) {
          // Try resolving as name
          resolvedPlayer = await resolvePlayerFromAggregated(playerId);
        }
      } else if (playerName) {
        resolvedPlayer = await resolvePlayerFromAggregated(playerName);
      }
      
      if (!resolvedPlayer) {
        console.error('‚ùå Could not resolve player');
        hideLoadingIndicator();
        document.getElementById('noDataMessage').style.display = 'block';
        document.getElementById('noDataMessage').querySelector('h3').textContent = 'Player Not Found';
        document.getElementById('noDataMessage').querySelector('p').textContent = `Could not find player "${playerName || playerId}" in ${AGGREGATED_COLLECTION}`;
        return;
      }
      
      currentPlayer = resolvedPlayer;
      console.log('‚úÖ Loaded player:', currentPlayer.name);
      console.log('üìä Player data:', currentPlayer);
      
      // Update header
      updatePlayerHeader();
      
      // Check if player has any splits data
      const hasSplitsData = checkForSplitsData();
      
      if (!hasSplitsData) {
        hideLoadingIndicator();
        document.getElementById('playerHeader').style.display = 'flex';
        document.getElementById('noDataMessage').style.display = 'block';
        return;
      }
      
      // Populate season filter
      populateSeasonFilter();
      
      // Render splits from aggregated data
      renderAllSplits();
      
      // Load game stats for game log (separate query - only needed for game log)
      await loadGameStatsForLog();
      renderGameLog();
      
      // Show UI
      document.getElementById('playerHeader').style.display = 'flex';
      document.getElementById('filterBar').style.display = 'flex';
      
      hideLoadingIndicator();
      
    } catch (error) {
      console.error('‚ùå Error loading player data:', error);
      hideLoadingIndicator();
      document.getElementById('noDataMessage').style.display = 'block';
    }
  }
  
  function checkForSplitsData() {
    // Check if player has any seasons with splits data (2025-fall onwards)
    if (!currentPlayer.seasons) {
      console.log('No seasons data found');
      return false;
    }
    
    const eligibleSeasons = Object.keys(currentPlayer.seasons)
      .filter(s => s >= MIN_GAME_DATA_SEASON);
    
    console.log('Eligible seasons:', eligibleSeasons);
    
    if (eligibleSeasons.length === 0) {
      console.log('No eligible seasons (>= 2025-fall)');
      return false;
    }
    
    // Check if any season has splits data
    const hasSplits = eligibleSeasons.some(seasonId => {
      const season = currentPlayer.seasons[seasonId];
      const hasSeasonSplits = season.splits && (season.splits.home?.games > 0 || season.splits.away?.games > 0);
      console.log(`Season ${seasonId} splits:`, season.splits, 'hasSplits:', hasSeasonSplits);
      return hasSeasonSplits;
    });
    
    // Also check career splits
    const hasCareerSplits = currentPlayer.career?.splits && 
      (currentPlayer.career.splits.home?.games > 0 || currentPlayer.career.splits.away?.games > 0);
    
    console.log('Career splits:', currentPlayer.career?.splits, 'hasCareerSplits:', hasCareerSplits);
    console.log('Has any splits:', hasSplits || hasCareerSplits);
    
    return hasSplits || hasCareerSplits;
  }
  
  function updatePlayerHeader() {
    const displayName = currentPlayer.name || currentPlayer.displayName;
    document.getElementById('pageTitle').textContent = `${displayName} - Splits${testMode ? ' (TEST)' : ''}`;
    document.getElementById('playerName').textContent = displayName;
    document.getElementById('playerTeam').textContent = currentPlayer.currentTeam || currentPlayer.seasons?.['2025-fall']?.team || 'Mountainside Aces';
    
    // Set profile link (preserve test mode)
    const profileLink = document.getElementById('fullProfileLink');
    const backLink = document.getElementById('backToProfileLink');
    const profileUrl = `player.html?id=${currentPlayer.id}`;
    profileLink.href = profileUrl;
    backLink.href = profileUrl;
    
    // Try to load photo
    loadPlayerPhoto();
  }
  
  async function loadPlayerPhoto() {
    try {
      const displayName = currentPlayer.name || currentPlayer.displayName;
      let playerPhotoURL = null;
      
      // Method 1: Query users collection for linkedPlayer matching display name
      const usersRef = collection(db, 'users');
      const q = query(usersRef, where('linkedPlayer', '==', displayName));
      const querySnapshot = await getDocs(q);
      
      if (!querySnapshot.empty) {
        const userDoc = querySnapshot.docs[0];
        const userData = userDoc.data();
        
        console.log('üîó Found linked user for player:', displayName);
        
        // Check for player photo first, then fall back to profile photo
        if (userData.playerPhotoURL) {
          playerPhotoURL = userData.playerPhotoURL;
          console.log('üì∏ Using playerPhotoURL');
        } else if (userData.profilePhotoURL) {
          playerPhotoURL = userData.profilePhotoURL;
          console.log('üì∏ Using profilePhotoURL as fallback');
        }
      }
      
      // Method 2: Direct lookup if player ID matches a user document
      if (!playerPhotoURL && currentPlayer.id) {
        const directUserDoc = await getDoc(doc(db, 'users', currentPlayer.id));
        if (directUserDoc.exists()) {
          const userData = directUserDoc.data();
          if (userData.playerPhotoURL) {
            playerPhotoURL = userData.playerPhotoURL;
          } else if (userData.profilePhotoURL) {
            playerPhotoURL = userData.profilePhotoURL;
          }
        }
      }
      
      // Apply photo if found
      if (playerPhotoURL) {
        const photoEl = document.getElementById('playerPhoto');
        const placeholderEl = document.getElementById('playerPhotoPlaceholder');
        
        photoEl.src = playerPhotoURL;
        photoEl.onload = () => {
          photoEl.classList.add('loaded');
          placeholderEl.classList.add('hidden');
        };
      }
    } catch (error) {
      console.warn('Could not load player photo:', error);
    }
  }
  
  // Load game stats ONLY for game log display
  async function loadGameStatsForLog() {
    gameStats = [];
    
    // Get the legacy ID for querying game stats
    const legacyId = currentPlayer.name ? 
      currentPlayer.name.toLowerCase().replace(/\s+/g, '_') : 
      currentPlayer.id;
    
    console.log(`üìã Loading game log for legacyId: ${legacyId}`);
    
    try {
      // Game stats are always in playerStats (not a test collection)
      const gamesRef = collection(db, 'playerStats', legacyId, 'games');
      const gamesSnap = await getDocs(gamesRef);
      
      gamesSnap.forEach(docSnap => {
        const data = docSnap.data();
        // Only include games from 2025-fall onwards
        if (data.seasonId && data.seasonId >= MIN_GAME_DATA_SEASON) {
          gameStats.push({
            id: docSnap.id,
            ...data
          });
        }
      });
      
      // Sort by date descending
      gameStats.sort((a, b) => {
        const dateA = a.gameDate?.seconds || 0;
        const dateB = b.gameDate?.seconds || 0;
        return dateB - dateA;
      });
      
      console.log(`‚úÖ Loaded ${gameStats.length} games for game log`);
      
    } catch (error) {
      console.warn('Could not load game stats for log:', error);
    }
  }
  
  function populateSeasonFilter() {
    const filterSelect = document.getElementById('seasonFilter');
    
    // Get seasons with game-level data (have splits)
    const seasons = currentPlayer.seasons || {};
    const eligibleSeasons = Object.keys(seasons)
      .filter(s => s >= MIN_GAME_DATA_SEASON && seasons[s].splits)
      .sort()
      .reverse();
    
    // Add season options
    eligibleSeasons.forEach(seasonId => {
      const [year, season] = seasonId.split('-');
      const displayName = `${year} ${season.charAt(0).toUpperCase() + season.slice(1)}`;
      const option = document.createElement('option');
      option.value = seasonId;
      option.textContent = displayName;
      filterSelect.appendChild(option);
    });
    
    // Add event listener
    filterSelect.addEventListener('change', (e) => {
      currentFilter = e.target.value;
      updateFilterInfo();
      renderAllSplits();
      renderGameLog();
    });
  }
  
  function updateFilterInfo() {
    const filterInfo = document.getElementById('filterInfo');
    if (currentFilter === 'career') {
      filterInfo.textContent = 'Showing career splits (2025-Fall onwards)';
    } else {
      const [year, season] = currentFilter.split('-');
      filterInfo.textContent = `Showing ${year} ${season.charAt(0).toUpperCase() + season.slice(1)} splits`;
    }
  }
  
  // Get splits data from aggregatedPlayerStats based on filter
  function getSplitsData() {
    if (currentFilter === 'career') {
      return currentPlayer.career?.splits || null;
    }
    return currentPlayer.seasons?.[currentFilter]?.splits || null;
  }
  
  // Get vsOpponent data from aggregatedPlayerStats based on filter
  function getVsOpponentData() {
    if (currentFilter === 'career') {
      return currentPlayer.career?.vsOpponent || {};
    }
    return currentPlayer.seasons?.[currentFilter]?.vsOpponent || {};
  }
  
  // Get filtered games for game log
  function getFilteredGames() {
    if (currentFilter === 'career') {
      return gameStats;
    }
    return gameStats.filter(g => g.seasonId === currentFilter);
  }
  
  function renderAllSplits() {
    const splits = getSplitsData();
    const vsOpponent = getVsOpponentData();
    
    console.log('Rendering splits:', splits);
    console.log('Rendering vsOpponent:', vsOpponent);
    
    if (!splits || (splits.home?.games === 0 && splits.away?.games === 0)) {
      // No splits data
      document.getElementById('splitsGrid').style.display = 'none';
      document.getElementById('opponentSection').style.display = 'none';
      document.getElementById('gameLogSection').style.display = 'none';
      document.getElementById('noDataMessage').style.display = 'block';
      return;
    }
    
    // Show all sections
    document.getElementById('splitsGrid').style.display = 'grid';
    document.getElementById('opponentSection').style.display = 'block';
    document.getElementById('gameLogSection').style.display = 'block';
    document.getElementById('noDataMessage').style.display = 'none';
    
    renderPlayoffSplit(splits);
    renderHomeAwaySplit(splits);
    renderOpponentBreakdown(vsOpponent);
  }
  
  function renderPlayoffSplit(splits) {
    const content = document.getElementById('playoffSplitContent');
    
    const regular = splits.regular || { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    const playoff = splits.playoff || { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    
    if (regular.games === 0 && playoff.games === 0) {
      content.innerHTML = `
        <div class="no-data">
          <div class="no-data-icon">üìä</div>
          <p>No game data available for this selection.</p>
        </div>
      `;
      return;
    }
    
    const regularAvg = formatAvg(regular.battingAverage);
    const regularOBP = formatAvg(regular.onBasePercentage);
    const playoffAvg = formatAvg(playoff.battingAverage);
    const playoffOBP = formatAvg(playoff.onBasePercentage);
    
    // Determine better stats
    const avgClass = highlightBetter(regular.battingAverage || 0, playoff.battingAverage || 0);
    const obpClass = highlightBetter(regular.onBasePercentage || 0, playoff.onBasePercentage || 0);
    
    content.innerHTML = `
      <table class="split-table">
        <thead>
          <tr>
            <th>Split</th>
            <th>G</th>
            <th>AB</th>
            <th>H</th>
            <th>R</th>
            <th>BB</th>
            <th>AVG</th>
            <th>OBP</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <div class="split-label">
                <span class="split-icon">üìÖ</span> Regular Season
              </div>
            </td>
            <td>${regular.games}</td>
            <td>${regular.atBats}</td>
            <td>${regular.hits}</td>
            <td>${regular.runs}</td>
            <td>${regular.walks}</td>
            <td class="${avgClass[0]}">${regularAvg}</td>
            <td class="${obpClass[0]}">${regularOBP}</td>
          </tr>
          <tr>
            <td>
              <div class="split-label">
                <span class="split-icon">üèÜ</span> Playoffs
              </div>
            </td>
            <td>${playoff.games}</td>
            <td>${playoff.atBats}</td>
            <td>${playoff.hits}</td>
            <td>${playoff.runs}</td>
            <td>${playoff.walks}</td>
            <td class="${avgClass[1]}">${playoffAvg}</td>
            <td class="${obpClass[1]}">${playoffOBP}</td>
          </tr>
        </tbody>
      </table>
    `;
  }
  
  function renderHomeAwaySplit(splits) {
    const content = document.getElementById('homeAwaySplitContent');
    
    const home = splits.home || { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    const away = splits.away || { games: 0, atBats: 0, hits: 0, runs: 0, walks: 0 };
    
    if (home.games === 0 && away.games === 0) {
      content.innerHTML = `
        <div class="no-data">
          <div class="no-data-icon">üìä</div>
          <p>No game data available for this selection.</p>
        </div>
      `;
      return;
    }
    
    const homeAvg = formatAvg(home.battingAverage);
    const homeOBP = formatAvg(home.onBasePercentage);
    const awayAvg = formatAvg(away.battingAverage);
    const awayOBP = formatAvg(away.onBasePercentage);
    
    const avgClass = highlightBetter(home.battingAverage || 0, away.battingAverage || 0);
    const obpClass = highlightBetter(home.onBasePercentage || 0, away.onBasePercentage || 0);
    
    content.innerHTML = `
      <table class="split-table">
        <thead>
          <tr>
            <th>Split</th>
            <th>G</th>
            <th>AB</th>
            <th>H</th>
            <th>R</th>
            <th>BB</th>
            <th>AVG</th>
            <th>OBP</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <div class="split-label">
                <span class="split-icon">üè†</span> Home
              </div>
            </td>
            <td>${home.games}</td>
            <td>${home.atBats}</td>
            <td>${home.hits}</td>
            <td>${home.runs}</td>
            <td>${home.walks}</td>
            <td class="${avgClass[0]}">${homeAvg}</td>
            <td class="${obpClass[0]}">${homeOBP}</td>
          </tr>
          <tr>
            <td>
              <div class="split-label">
                <span class="split-icon">‚úàÔ∏è</span> Away
              </div>
            </td>
            <td>${away.games}</td>
            <td>${away.atBats}</td>
            <td>${away.hits}</td>
            <td>${away.runs}</td>
            <td>${away.walks}</td>
            <td class="${avgClass[1]}">${awayAvg}</td>
            <td class="${obpClass[1]}">${awayOBP}</td>
          </tr>
        </tbody>
      </table>
    `;
  }
  
  function renderOpponentBreakdown(vsOpponent) {
    const tbody = document.getElementById('opponentTableBody');
    
    if (!vsOpponent || Object.keys(vsOpponent).length === 0) {
      tbody.innerHTML = `
        <tr>
          <td colspan="8" style="text-align: center; padding: 2rem; color: #718096;">
            No opponent data available for this selection.
          </td>
        </tr>
      `;
      return;
    }
    
    // Sort opponents by games played (descending)
    const opponents = Object.entries(vsOpponent)
      .map(([name, stats]) => ({
        name,
        ...stats,
        avg: formatAvg(stats.battingAverage),
        obp: formatAvg(stats.onBasePercentage)
      }))
      .sort((a, b) => b.games - a.games);
    
    tbody.innerHTML = opponents.map(opp => `
      <tr>
        <td>
          ${getTeamColorDot(opp.name)}
          ${opp.name}
        </td>
        <td>${opp.games}</td>
        <td>${opp.atBats}</td>
        <td>${opp.hits}</td>
        <td>${opp.runs}</td>
        <td>${opp.walks}</td>
        <td>${opp.avg}</td>
        <td>${opp.obp}</td>
      </tr>
    `).join('');
  }
  
  function renderGameLog() {
    const tbody = document.getElementById('gameLogTableBody');
    const filteredGames = getFilteredGames();
    
    if (filteredGames.length === 0) {
      tbody.innerHTML = `
        <tr>
          <td colspan="9" style="text-align: center; padding: 2rem; color: #718096;">
            No games recorded for this selection.
          </td>
        </tr>
      `;
      return;
    }
    
    // Sort games
    const sortedGames = sortGames(filteredGames);
    
    tbody.innerHTML = sortedGames.map(g => {
      const isPlayoff = g.isPlayoff === true || g.gameType === 'playoff';
      const gameTypeClass = isPlayoff ? 'game-type-playoff' : 'game-type-regular';
      const gameTypeLabel = isPlayoff ? 'Playoff' : 'Regular';
      const homeAwayClass = g.isHome ? 'badge-home' : 'badge-away';
      const homeAwayLabel = g.isHome ? 'Home' : 'Away';
      const gameAvg = calculateAvg(g.hits || 0, g.atBats || 0);
      
      return `
        <tr>
          <td>${formatDate(g.gameDate)}</td>
          <td>${getTeamColorDot(g.opponent || 'Unknown')}${g.opponent || 'Unknown'}</td>
          <td><span class="home-away-badge ${homeAwayClass}">${homeAwayLabel}</span></td>
          <td><span class="game-type-badge ${gameTypeClass}">${gameTypeLabel}</span></td>
          <td>${g.atBats || 0}</td>
          <td>${g.hits || 0}</td>
          <td>${g.runs || 0}</td>
          <td>${g.walks || 0}</td>
          <td>${gameAvg}</td>
        </tr>
      `;
    }).join('');
  }
  
  function sortGames(games) {
    return [...games].sort((a, b) => {
      let valA, valB;
      
      switch (currentSort.column) {
        case 'date':
          valA = a.gameDate?.seconds || 0;
          valB = b.gameDate?.seconds || 0;
          break;
        case 'opponent':
          valA = (a.opponent || '').toLowerCase();
          valB = (b.opponent || '').toLowerCase();
          break;
        case 'homeAway':
          valA = a.isHome ? 1 : 0;
          valB = b.isHome ? 1 : 0;
          break;
        case 'gameType':
          valA = (a.isPlayoff || a.gameType === 'playoff') ? 1 : 0;
          valB = (b.isPlayoff || b.gameType === 'playoff') ? 1 : 0;
          break;
        case 'ab':
          valA = a.atBats || 0;
          valB = b.atBats || 0;
          break;
        case 'h':
          valA = a.hits || 0;
          valB = b.hits || 0;
          break;
        case 'r':
          valA = a.runs || 0;
          valB = b.runs || 0;
          break;
        case 'bb':
          valA = a.walks || 0;
          valB = b.walks || 0;
          break;
        case 'avg':
          valA = a.atBats > 0 ? a.hits / a.atBats : 0;
          valB = b.atBats > 0 ? b.hits / b.atBats : 0;
          break;
        default:
          valA = a.gameDate?.seconds || 0;
          valB = b.gameDate?.seconds || 0;
      }
      
      if (typeof valA === 'string') {
        return currentSort.direction === 'asc' 
          ? valA.localeCompare(valB) 
          : valB.localeCompare(valA);
      }
      
      return currentSort.direction === 'asc' ? valA - valB : valB - valA;
    });
  }
  
  // Setup sort handlers
  function setupSortHandlers() {
    const headers = document.querySelectorAll('.game-log-table th[data-sort]');
    headers.forEach(th => {
      th.addEventListener('click', () => {
        const column = th.dataset.sort;
        
        // Toggle direction if same column
        if (currentSort.column === column) {
          currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
          currentSort.column = column;
          currentSort.direction = 'desc';
        }
        
        // Update header classes
        headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
        th.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
        
        // Re-render
        renderGameLog();
      });
    });
  }
  
  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setupSortHandlers();
      loadPlayerData();
    });
  } else {
    setupSortHandlers();
    loadPlayerData();
  }
</script>

<script type="module">
  import { NavigationComponent } from './nav-component.js';
</script>
<script src="mobile-enhancements.js"></script>
</body>
</html>

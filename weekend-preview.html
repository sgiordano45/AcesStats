<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Weekend Preview - Mountainside Aces</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">

<style>
:root {
  --primary-color: #2d5016;
  --secondary-color: #1a6b4a;
  --accent-color: #ffd700;
  --card-bg: #ffffff;
  --text-dark: #2d3748;
  --text-light: #718096;
  --border-color: #e2e8f0;
  --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
  --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
}

* {
  box-sizing: border-box;
}

html {
  overflow-x: hidden;
  scroll-behavior: smooth;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  margin: 0;
  padding: 0;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  min-height: 100vh;
  overflow-x: hidden;
  color: var(--text-dark);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,255,255,0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.5s ease, visibility 0.5s ease;
}

.loading-overlay.hidden {
  opacity: 0;
  visibility: hidden;
}

.softball-spinner {
  position: relative;
}

.softball-spinner::before {
  content: '‚öæ';
  font-size: 80px;
  animation: spin 1.5s ease-in-out infinite;
  display: block;
}

@keyframes spin {
  0%, 100% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.1); }
}

#news-banner-container {
  position: relative;
  z-index: 1000;
  width: 100%;
}

/* Header */
.header {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  color: white;
  text-align: center;
  padding: 4rem 2rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
}

.header::before {
  content: '';
  position: absolute;
  top: -100px;
  right: -100px;
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
  border-radius: 50%;
}

.header::after {
  content: 'üîÆ';
  position: absolute;
  bottom: -40px;
  left: -40px;
  font-size: 200px;
  opacity: 0.05;
}

.header h1 {
  margin: 0;
  font-size: 3.5rem;
  font-weight: 800;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  position: relative;
  z-index: 1;
}

.header p {
  margin: 1rem 0 0 0;
  font-size: 1.2rem;
  opacity: 0.95;
  position: relative;
  z-index: 1;
}

/* Dashboard Container */
.dashboard-container {
  max-width: 1400px;
  margin: 3rem auto;
  padding: 0 2rem;
}

/* Navigation */
.filters-nav {
  background: var(--card-bg);
  padding: 1.5rem;
  border-radius: 16px;
  margin-bottom: 2rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
}

.nav-container {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  align-items: center;
  justify-content: center;
}

.nav-link {
  padding: 1rem 1.75rem;
  border: 2px solid var(--primary-color);
  background: white;
  color: var(--primary-color);
  text-decoration: none;
  border-radius: 12px;
  font-weight: 600;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  white-space: nowrap;
  position: relative;
  overflow: hidden;
  z-index: 1;
}

.nav-link::before {
  content: '';
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: var(--primary-color);
  transform: translateX(-100%);
  transition: transform 0.3s ease;
  z-index: -1;
}

.nav-link:hover::before {
  transform: translateX(0);
}

.nav-link:hover {
  color: white;
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.nav-link.active {
  background: var(--primary-color);
  color: white;
}

/* Section Title */
.section-title {
  font-size: 2rem;
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1.5rem;
  color: var(--text-dark);
}

.section-title::before {
  content: "";
  width: 8px;
  height: 36px;
  background: linear-gradient(180deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  border-radius: 4px;
}

.section-title::after {
  content: '';
  flex: 1;
  height: 2px;
  background: linear-gradient(90deg, var(--border-color) 0%, transparent 100%);
}

/* Weather Module */
.weather-module {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 2rem;
  margin-bottom: 2rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  position: relative;
  overflow: hidden;
}

.weather-module::before {
  content: "";
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 5px;
  background: linear-gradient(90deg, #2196F3 0%, #64B5F6 100%);
}

.weather-header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
  margin-bottom: 1.5rem;
}

.weather-header h3 {
  margin: 0;
  color: var(--text-dark);
  font-size: 1.5rem;
  font-weight: 700;
}

.weather-icon {
  font-size: 1.8rem;
}

.weather-content {
  display: grid;
  grid-template-columns: auto 1fr 2fr;
  gap: 2rem;
  align-items: center;
}

.weather-image-section {
  text-align: center;
}

.weather-image-label {
  font-size: 0.75rem;
  font-weight: 700;
  color: var(--primary-color);
  margin-bottom: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.weather-image {
  width: 100px;
  height: 100px;
  object-fit: cover;
  border-radius: 12px;
  border: 2px solid var(--border-color);
  box-shadow: var(--shadow-sm);
}

.current-weather {
  text-align: center;
  min-width: 200px;
}

.temperature {
  font-size: 2.5rem;
  font-weight: 800;
  color: var(--text-dark);
}

.weather-condition {
  font-size: 1.1rem;
  color: var(--text-light);
  margin-top: 0.25rem;
}

.weather-details {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 0.75rem;
  font-size: 0.9rem;
  color: var(--text-light);
}

.weather-forecast {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1rem;
}

.forecast-day {
  text-align: center;
  padding: 1rem;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  border-radius: 12px;
  border: 1px solid var(--border-color);
}

.forecast-day .day-name {
  font-size: 0.85rem;
  font-weight: 700;
  color: var(--text-light);
  margin-bottom: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.forecast-day .day-icon {
  font-size: 1.5rem;
  margin-bottom: 0.25rem;
}

.forecast-day .day-temp {
  font-size: 1.1rem;
  font-weight: 700;
  color: var(--text-dark);
}

.forecast-day .day-temp-low {
  font-size: 0.85rem;
  color: var(--text-light);
}

.weather-loading, .weather-error {
  text-align: center;
  padding: 2rem;
  color: var(--text-light);
}

.weather-status {
  text-align: center;
  margin-top: 1rem;
  padding: 0.5rem 1rem;
  background: #fff3cd;
  border-radius: 8px;
  font-size: 0.85rem;
  color: #856404;
}

/* Weekend Info Box */
.weekend-info {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 2rem;
  margin-bottom: 2rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  text-align: center;
  position: relative;
  overflow: hidden;
}

.weekend-info::before {
  content: "";
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 5px;
  background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
}

.weekend-info h3 {
  margin: 0 0 0.5rem 0;
  font-size: 1.75rem;
  font-weight: 800;
  color: var(--text-dark);
}

.weekend-info p {
  margin: 0;
  color: var(--text-light);
  font-size: 1.1rem;
}

.weekend-info .loading {
  padding: 2rem;
  color: var(--text-light);
}

/* Games Grid */
.games-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(360px, 1fr));
  gap: 2rem;
}

/* Game Card */
.game-card {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.5rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
  text-decoration: none;
  color: inherit;
  display: block;
  position: relative;
  overflow: hidden;
}

.game-card::before {
  content: "";
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 4px;
  background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
}

.game-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-lg);
}

.game-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.25rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.game-date {
  font-weight: 700;
  color: var(--primary-color);
  font-size: 1rem;
}

.game-type {
  font-size: 0.8rem;
  font-weight: 600;
  color: white;
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  padding: 0.3rem 0.75rem;
  border-radius: 20px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.teams-matchup {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 1rem;
  align-items: center;
  margin-bottom: 1.25rem;
}

.team-info {
  text-align: center;
}

.team-logo {
  width: 60px;
  height: 60px;
  object-fit: contain;
  margin-bottom: 0.5rem;
  border-radius: 50%;
  background: white;
  padding: 4px;
  box-shadow: var(--shadow-sm);
}

.team-name {
  font-size: 1.25rem;
  font-weight: 800;
  color: var(--text-dark);
  margin-bottom: 0.25rem;
}

.team-record {
  font-size: 1.1rem;
  font-weight: 700;
  color: var(--primary-color);
}

.team-standing {
  font-size: 0.85rem;
  color: var(--text-light);
}

.vs-section {
  text-align: center;
}

.vs-text {
  font-size: 1.5rem;
  font-weight: 800;
  color: var(--text-light);
}

.home-indicator {
  font-size: 0.75rem;
  color: var(--primary-color);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-top: 0.25rem;
}

/* Game Odds */
.game-odds {
  display: flex;
  justify-content: center;
  gap: 2rem;
  padding: 1rem;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  border-radius: 12px;
  margin-bottom: 1rem;
  border: 1px solid var(--border-color);
}

.odds-item {
  text-align: center;
}

.odds-team {
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--text-light);
  margin-bottom: 0.25rem;
}

.odds-value {
  font-size: 1.25rem;
  font-weight: 800;
  color: var(--text-dark);
}

.odds-value.favorite {
  color: var(--primary-color);
}

/* Key Players */
.key-players {
  padding-top: 1rem;
  border-top: 1px solid var(--border-color);
}

.key-players h4 {
  margin: 0 0 1rem 0;
  font-size: 0.9rem;
  font-weight: 700;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 1px;
  text-align: center;
}

.players-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
}

.team-players h5 {
  margin: 0 0 0.5rem 0;
  font-size: 0.85rem;
  font-weight: 700;
  color: var(--primary-color);
  text-align: center;
}

.player-list {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.player-name {
  font-size: 0.85rem;
  color: var(--text-dark);
  text-align: center;
  padding: 0.35rem;
  background: #f8fafc;
  border-radius: 6px;
}

/* No Games Message */
.no-games {
  grid-column: 1 / -1;
  text-align: center;
  padding: 4rem 2rem;
  background: var(--card-bg);
  border-radius: 16px;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
}

.no-games h3 {
  margin: 0 0 0.5rem 0;
  font-size: 1.5rem;
  color: var(--text-dark);
}

.no-games p {
  color: var(--text-light);
  margin-bottom: 1rem;
}

/* Connection Status */
.connection-status {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1rem;
  border-radius: 8px;
  background: #fee2e2;
  color: #991b1b;
  font-size: 0.9rem;
  font-weight: 600;
  box-shadow: var(--shadow-md);
  z-index: 1000;
  transition: all 0.3s ease;
}

.connection-status.online {
  background: #d1fae5;
  color: #065f46;
}

.connection-status.hidden {
  opacity: 0;
  visibility: hidden;
  transform: translateY(20px);
}

/* Responsive */
@media (max-width: 768px) {
  .header h1 {
    font-size: 2rem;
  }
  
  .header {
    padding: 2.5rem 1.5rem;
  }
  
  .dashboard-container {
    margin: 2rem auto;
    padding: 0 1rem;
  }
  
  .weather-content {
    grid-template-columns: 1fr;
    gap: 1.5rem;
  }
  
  .weather-forecast {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .games-grid {
    grid-template-columns: 1fr;
    gap: 1.5rem;
  }
  
  .teams-matchup {
    grid-template-columns: 1fr auto 1fr;
  }
  
  .team-logo {
    width: 50px;
    height: 50px;
  }
  
  .team-name {
    font-size: 1.1rem;
  }
  
  .nav-container {
    justify-content: center;
  }
  
  .nav-link {
    padding: 0.75rem 1.25rem;
    font-size: 0.9rem;
  }
}

@media (max-width: 480px) {
  .weather-forecast {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .forecast-day {
    padding: 0.75rem;
  }
  
  .game-odds {
    gap: 1rem;
  }
  
  .odds-value {
    font-size: 1rem;
  }
}
</style>
</head>
<body>

<div class="loading-overlay" id="loadingOverlay">
  <div class="softball-spinner"></div>
</div>

<div id="news-banner-container"></div>

<div class="filters-nav">
</div>

<header class="header">
  <h1>Weekend Preview</h1>
  <p>Upcoming matchups and game analysis</p>
</header>

<div class="connection-status hidden" id="connectionStatus">
  <span class="status-icon">üì°</span>
  <span class="status-text">You're offline</span>
</div>

<div class="dashboard-container">


  <div class="weather-module" id="weatherModule">
    <div class="weather-loading">Loading weather forecast...</div>
  </div>

  <div class="weekend-info" id="weekendInfo">
    <div class="loading">Loading weekend schedule...</div>
  </div>

  <div class="games-grid" id="gamesGrid">
    <div class="loading">Loading upcoming games...</div>
  </div>
</div>

<script src="team-colors.js"></script>
<script type="module">
// 2026+ UPDATE: Removed getSeasonPreviews import - preview data now comes from games collection
import {
  getCurrentSeason,
  getSeasonGames,
  getAllPlayerStatsOptimized
} from './firebase-data.js';

// DIAGNOSTIC CODE - ADD THIS:
setTimeout(() => {
  console.log('üîç Checking for Firebase persistence...');
  indexedDB.databases().then(dbs => {
    console.log('üîç All IndexedDB databases:', dbs.map(db => db.name));
    const fbDb = dbs.find(db => db.name === 'firebaseLocalStorageDb');
    console.log(fbDb ? '‚úÖ Firebase DB found!' : '‚ùå Firebase DB NOT found!');
  });
}, 2000);


let allGames = [];
let playerData = [];
let currentSeasonData = null;
const today = new Date();
today.setHours(0, 0, 0, 0); // Set to start of today

const WEATHER_ZIP = "07092";
const WEATHER_API_KEY = "c26153644bca587d9db1fc0256a01cf0";
let forecastOverride = null;

function toggleMobileMenu() {
  const menu = document.getElementById('mobileNavMenu');
  menu.classList.toggle('open');
}
window.toggleMobileMenu = toggleMobileMenu;

document.addEventListener('DOMContentLoaded', function() {
  loadWeekendData();
  loadWeatherData();
});

window.addEventListener('load', function() {
  setTimeout(function() {
    document.getElementById('loadingOverlay').classList.add('hidden');
  }, 800);
});

async function loadWeekendData() {
  try {
    console.log('üìä Loading weekend data from Firebase...');
    
    currentSeasonData = await getCurrentSeason();
    console.log('‚úÖ Current season:', currentSeasonData);
    
    // CHECK FOR NULL - If no cached season data, we can't load anything offline
    if (!currentSeasonData) {
      console.log('‚ö†Ô∏è No season data available');
      throw new Error('No season data cached - please visit this page online first');
    }
    
    const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
    
    // 2026+ UPDATE: Only fetch games and players - preview data is now ON the game documents
    const [games, players] = await Promise.all([
      getSeasonGames(currentSeasonData.id),
      getAllPlayerStatsOptimized()
    ]);

    console.log(`‚úÖ Loaded: ${games?.length || 0} games, ${players?.length || 0} players`);
    
    // 2026+ UPDATE: Map games including preview fields directly from game documents
    allGames = (games || []).map(g => {
      let dateString = "";
      
      // Handle Firestore Timestamp objects (playoff games)
      if (g.date && typeof g.date === 'object' && g.date.seconds) {
        const dateObj = new Date(g.date.seconds * 1000);
        dateString = dateObj.toLocaleDateString('en-US');
      } 
      // Handle Firestore Timestamp with toDate method
      else if (g.date && typeof g.date === 'object' && typeof g.date.toDate === 'function') {
        const dateObj = g.date.toDate();
        dateString = dateObj.toLocaleDateString('en-US');
      }
      // Handle string dates (regular games)
      else if (g.date && typeof g.date === 'string') {
        dateString = g.date;
      }
      // No date set yet
      else {
        dateString = "";
      }
      
      return {
        "home team": g.homeTeamName || g["home team"] || capitalize(g.homeTeamId) || "",
        "away team": g.awayTeamName || g["away team"] || capitalize(g.awayTeamId) || "",
        "home score": g.homeScore !== undefined ? g.homeScore : (g["home score"] || null),
        "away score": g.awayScore !== undefined ? g.awayScore : (g["away score"] || null),
        winner: capitalize(g.winner || ""),
        game_type: g.game_type === "Playoff" ? "Playoff" :
                   g.gameType === "regular" ? "Regular" :
                   g.gameType === "playoff" ? "Playoff" :
                   capitalize(g.gameType) || "Regular",
        date: dateString,
        year: currentSeasonData.year.toString(),
        season: capitalize(currentSeasonData.season),
        id: g.id || "",
        time: g.time || "",
        round: g.round || "",
        // 2026+ UPDATE: Include preview fields directly from game document
        "home odds": g.homeOdds || null,
        "away odds": g.awayOdds || null,
        preview: g.preview || "",
        previewStatus: g.previewStatus || g.status || "scheduled"
      };
    });
    
    playerData = [];
    players.forEach(p => {
      if (p.seasons && typeof p.seasons === 'object') {
        const matchingKeys = Object.keys(p.seasons).filter(key =>
          key.startsWith(currentSeasonData.id)
        );
        
        matchingKeys.forEach(seasonKey => {
          const seasonStats = p.seasons[seasonKey];
          playerData.push({
            name: p.name || p.displayName || p.id,
            team: seasonStats.team || p.currentTeam || "",
            year: currentSeasonData.year.toString(),
            season: capitalize(currentSeasonData.season),
            sub: "No",
            atBats: Number(seasonStats.atBats) || 0,
            AcesWar: seasonStats.acesBPI || seasonStats.AcesBPI || seasonStats.AcesWar || "N/A"
          });
        });
      }
    });
    
    console.log(`‚úÖ Mapped: ${allGames.length} games, ${playerData.length} player records`);
    
    
    generateWeekendPreview();
    
  } catch (error) {
    console.error('‚ùå Error loading weekend data:', error);
    showError();
  }
}

function parseGameDate(dateStr) {
  return new Date(dateStr);
}

function getWeekendGames() {
  const nextWeek = new Date(today);
  nextWeek.setDate(today.getDate() + 7);
  
  return allGames.filter(g => {
    const gameDate = parseGameDate(g.date);
    const isFuture = gameDate >= today;
    const isWithinWeek = gameDate <= nextWeek;
    const noWinner = !g.winner || g.winner.trim() === "";
    // Include both Regular and Playoff games
    
    return isFuture && isWithinWeek && noWinner;
  }).sort((a, b) => parseGameDate(a.date) - parseGameDate(b.date));
}

function parseTimeString(timeStr) {
  if (!timeStr) return 0;
  
  // Try to parse 12-hour format with AM/PM first (e.g., "9:00 AM", "12:30 PM")
  const ampmMatch = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
  if (ampmMatch) {
    let hours = parseInt(ampmMatch[1]);
    const minutes = parseInt(ampmMatch[2]);
    const period = ampmMatch[3].toUpperCase();
    
    // Convert to 24-hour format
    if (period === 'PM' && hours !== 12) {
      hours += 12;
    } else if (period === 'AM' && hours === 12) {
      hours = 0;
    }
    
    return hours * 60 + minutes; // Return total minutes for easy comparison
  }
  
  // Try to parse 24-hour format (e.g., "10:00", "14:30")
  const twentyFourMatch = timeStr.match(/^(\d+):(\d+)$/);
  if (twentyFourMatch) {
    const hours = parseInt(twentyFourMatch[1]);
    const minutes = parseInt(twentyFourMatch[2]);
    return hours * 60 + minutes;
  }
  
  return 0;
}

function calculateTeamRecord(teamName) {
  const currentSeasonGames = allGames.filter(g =>
    g.winner &&
    g.winner.trim() !== "" &&
    (g["home team"] === teamName || g["away team"] === teamName)
  );

  let wins = 0, losses = 0, ties = 0;
  const teamLower = teamName.toLowerCase();
  
  currentSeasonGames.forEach(game => {
    const winnerLower = (game.winner || "").toLowerCase();
    if (winnerLower.includes("tie")) {
      ties++;
    } else if (winnerLower === teamLower) {
      wins++;
    } else {
      losses++;
    }
  });

  const totalDecided = wins + losses;
  const winPct = totalDecided > 0 ? wins / totalDecided : 0;

  return { wins, losses, ties, winPct };
}

function calculateTeamStanding(teamName) {
  const completedGames = allGames.filter(g =>
    parseGameDate(g.date) < today &&
    g.winner &&
    g.winner.trim() !== "" &&
    g.game_type === 'Regular'
  );
  
  const teamStats = {};
  
  completedGames.forEach(game => {
    const homeTeam = game["home team"];
    const awayTeam = game["away team"];
    const winner = game.winner;
    const homeScore = parseInt(game["home score"]) || 0;
    const awayScore = parseInt(game["away score"]) || 0;

    if (!teamStats[homeTeam]) {
      teamStats[homeTeam] = {
        name: homeTeam, wins: 0, losses: 0, ties: 0,
        runsFor: 0, runsAgainst: 0, h2h: {}
      };
    }
    if (!teamStats[awayTeam]) {
      teamStats[awayTeam] = {
        name: awayTeam, wins: 0, losses: 0, ties: 0,
        runsFor: 0, runsAgainst: 0, h2h: {}
      };
    }

    // Track runs
    teamStats[homeTeam].runsFor += homeScore;
    teamStats[homeTeam].runsAgainst += awayScore;
    teamStats[awayTeam].runsFor += awayScore;
    teamStats[awayTeam].runsAgainst += homeScore;

    // Initialize h2h if needed
    if (!teamStats[homeTeam].h2h[awayTeam]) {
      teamStats[homeTeam].h2h[awayTeam] = { wins: 0, losses: 0, ties: 0 };
    }
    if (!teamStats[awayTeam].h2h[homeTeam]) {
      teamStats[awayTeam].h2h[homeTeam] = { wins: 0, losses: 0, ties: 0 };
    }

    if (winner === "Tie") {
      teamStats[homeTeam].ties++;
      teamStats[awayTeam].ties++;
      teamStats[homeTeam].h2h[awayTeam].ties++;
      teamStats[awayTeam].h2h[homeTeam].ties++;
    } else if (winner === homeTeam) {
      teamStats[homeTeam].wins++;
      teamStats[awayTeam].losses++;
      teamStats[homeTeam].h2h[awayTeam].wins++;
      teamStats[awayTeam].h2h[homeTeam].losses++;
    } else if (winner === awayTeam) {
      teamStats[awayTeam].wins++;
      teamStats[homeTeam].losses++;
      teamStats[awayTeam].h2h[homeTeam].wins++;
      teamStats[homeTeam].h2h[awayTeam].losses++;
    }
  });

  const preliminaryStandings = Object.values(teamStats).map(team => {
    const totalDecided = team.wins + team.losses;
    team.winPct = totalDecided > 0 ? team.wins / totalDecided : 0;
    team.runDifferential = team.runsFor - team.runsAgainst;
    return team;
  });

  // Helper function for head-to-head comparison
  function compareHeadToHead(teamA, teamB) {
    const aVsB = teamA.h2h[teamB.name];
    const bVsA = teamB.h2h[teamA.name];
    
    if (!aVsB || !bVsA) return 0;
    
    const aH2HWinPct = (aVsB.wins + aVsB.losses) > 0 ? aVsB.wins / (aVsB.wins + aVsB.losses) : 0;
    const bH2HWinPct = (bVsA.wins + bVsA.losses) > 0 ? bVsA.wins / (bVsA.wins + bVsA.losses) : 0;
    
    return bH2HWinPct - aH2HWinPct;
  }

  // Sort with proper tiebreakers (matching current-season.html)
  const standings = preliminaryStandings.sort((a, b) => {
    // First tiebreaker: Win percentage
    if (a.winPct !== b.winPct) return b.winPct - a.winPct;
    
    // Check if there are 3+ teams tied at this win percentage
    const teamsAtSameWinPct = preliminaryStandings.filter(t => t.winPct === a.winPct);
    
    // Second tiebreaker: Only use H2H if EXACTLY 2 teams are tied
    if (teamsAtSameWinPct.length === 2) {
      const h2hComp = compareHeadToHead(a, b);
      if (h2hComp !== 0) return h2hComp;
    }
    
    // Third tiebreaker: Runs Against (for 3+ teams tied, or if H2H didn't resolve)
    if (a.runsAgainst !== b.runsAgainst) return a.runsAgainst - b.runsAgainst;
    
    // Fourth tiebreaker: Run Differential
    return b.runDifferential - a.runDifferential;
  });

  const teamPosition = standings.findIndex(team => team.name === teamName) + 1;
  return teamPosition > 0 ? teamPosition : null;
}

// 2026+ UPDATE: getGamePreview now returns the game object itself (which contains preview fields)
// This is simpler since preview data is now directly on game objects
function getGamePreview(homeTeam, awayTeam, gameDate) {
  // Just return the game from allGames - it already has the preview fields
  return allGames.find(g => {
    const matchesTeams = (g["home team"] === homeTeam && g["away team"] === awayTeam);
    const matchesDate = g.date === gameDate ||
                       formatDateForComparison(g.date) === formatDateForComparison(gameDate);
    return matchesTeams && matchesDate;
  });
}

function formatDateForComparison(dateStr) {
  if (!dateStr) return '';
  const date = new Date(dateStr);
  if (isNaN(date.getTime())) return dateStr;
  return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
}

function getTeamColor(teamName) {
  const teamColors = {
    'Black': '26, 26, 26',
    'Green': '45, 125, 50',
    'Red': '211, 47, 47',
    'Blue': '25, 118, 210',
    'White': '52, 58, 64',
    'Orange': '245, 124, 0',
    'Silver': '117, 117, 117',
    'Purple': '123, 31, 162',
    'Gold': '245, 127, 23',
    'Carolina': '75, 156, 211',
    'Army': '101, 67, 33'
  };
  
  return teamColors[teamName] || null;
}

function getTopPlayers(teamName) {
  if (!playerData || playerData.length === 0) return [];
  
  const teamGames = allGames.filter(g =>
    g.winner &&
    g.winner.trim() !== "" &&
    (g["home team"] === teamName || g["away team"] === teamName)
  );
  
  const teamGamesPlayed = teamGames.length;
  const minAtBats = teamGamesPlayed * 2;
  
  const teamPlayers = playerData.filter(player =>
    player.team === teamName &&
    player.sub === "No" &&
    player.AcesWar !== "N/A" &&
    typeof player.AcesWar === 'number' &&
    player.atBats >= minAtBats
  );
  
  return teamPlayers
    .sort((a, b) => b.AcesWar - a.AcesWar)
    .slice(0, 3)
    .map(player => player.name);
}

async function loadWeatherData() {
  try {
    const forecastResponse = await fetch('forecast.json');
    if (forecastResponse.ok) {
      const forecastData = await forecastResponse.json();
      if (forecastData && forecastData.length > 0 && forecastData[0].forecast) {
        forecastOverride = forecastData[0].forecast.toLowerCase();
        console.log('Loaded forecast override:', forecastOverride);
      }
    }
  } catch (error) {
    console.log('No forecast override file found');
    forecastOverride = null;
  }

  if (WEATHER_API_KEY === "YOUR_API_KEY_HERE") {
    document.getElementById('weatherModule').innerHTML = `
      <div class="weather-error">
        <div class="weather-header">
          <span class="weather-icon">üå§Ô∏è</span>
          <h3>Weather for Mountainside, NJ</h3>
        </div>
        <p>Weather data unavailable - API key required</p>
      </div>
    `;
    return;
  }

  const cachedWeather = getCachedWeather();
  if (cachedWeather) {
    console.log('Using cached weather data');
    displayWeather(cachedWeather.current, cachedWeather.forecast);
    return;
  }

  try {
    console.log('Fetching fresh weather data from API');
    const [currentResponse, forecastResponse] = await Promise.all([
      fetch(`https://api.openweathermap.org/data/2.5/weather?zip=${WEATHER_ZIP},US&appid=${WEATHER_API_KEY}&units=imperial`),
      fetch(`https://api.openweathermap.org/data/2.5/forecast?zip=${WEATHER_ZIP},US&appid=${WEATHER_API_KEY}&units=imperial`)
    ]);

    if (!currentResponse.ok || !forecastResponse.ok) {
      throw new Error('Weather API request failed');
    }

    const currentWeather = await currentResponse.json();
    const forecastData = await forecastResponse.json();

    cacheWeatherData(currentWeather, forecastData);
    displayWeather(currentWeather, forecastData);
  } catch (error) {
    console.error('Error loading weather:', error);
    
    const staleCache = getStaleWeatherCache();
    if (staleCache) {
      console.log('Using stale cached weather due to API error');
      displayWeather(staleCache.current, staleCache.forecast, true);
      return;
    }
    
    document.getElementById('weatherModule').innerHTML = `
      <div class="weather-error">
        <div class="weather-header">
          <span class="weather-icon">‚ö†Ô∏è</span>
          <h3>Weather Unavailable</h3>
        </div>
        <p>Unable to load weather data. Please try again later.</p>
      </div>
    `;
  }
}

function getCachedWeather() {
  try {
    const cached = localStorage.getItem('weatherCache');
    if (!cached) return null;
    
    const data = JSON.parse(cached);
    const now = Date.now();
    const cacheAge = now - data.timestamp;
    const maxAge = 30 * 60 * 1000; // 30 minutes
    
    if (cacheAge > maxAge) return null;
    
    return data;
  } catch (e) {
    return null;
  }
}

function getStaleWeatherCache() {
  try {
    const cached = localStorage.getItem('weatherCache');
    if (!cached) return null;
    return JSON.parse(cached);
  } catch (e) {
    return null;
  }
}

function cacheWeatherData(current, forecast) {
  try {
    localStorage.setItem('weatherCache', JSON.stringify({
      current,
      forecast,
      timestamp: Date.now()
    }));
  } catch (e) {
    console.warn('Could not cache weather data');
  }
}

function displayWeather(currentWeather, forecastData, isStale = false) {
  const condition = currentWeather.weather[0].main;
  const description = currentWeather.weather[0].description;
  const temp = Math.round(currentWeather.main.temp);
  const humidity = currentWeather.main.humidity;
  const windSpeed = Math.round(currentWeather.wind.speed);
  
  // Get daily forecasts (noon each day)
  const dailyForecasts = [];
  const processedDates = new Set();
  
  forecastData.list.forEach(item => {
    const date = new Date(item.dt * 1000);
    const dateKey = date.toDateString();
    const hour = date.getHours();
    
    // Skip today
    if (dateKey === today.toDateString()) return;
    
    // Get forecast closest to noon for each day
    if (!processedDates.has(dateKey) && hour >= 11 && hour <= 14) {
      processedDates.add(dateKey);
      dailyForecasts.push({
        date: date,
        temp: Math.round(item.main.temp),
        tempMin: Math.round(item.main.temp_min),
        condition: item.weather[0].main
      });
    }
  });
  
  // Limit to 4 days
  const forecastDays = dailyForecasts.slice(0, 4);
  
  // Determine weather image
  let weatherImage = 'misc/sunny.jpg';
  let imageLabel = 'Clear skies expected';
  const checkCondition = forecastOverride || condition.toLowerCase();
  
  if (checkCondition.includes('rain') || checkCondition.includes('drizzle')) {
    weatherImage = 'misc/rainy.jpg';
    imageLabel = 'Rain in forecast';
  } else if (checkCondition.includes('cloud') || checkCondition.includes('overcast')) {
    weatherImage = 'misc/cloudy.jpg';
    imageLabel = 'Cloudy conditions';
  } else if (checkCondition.includes('storm') || checkCondition.includes('thunder')) {
    weatherImage = 'misc/stormy.jpg';
    imageLabel = 'Storms possible';
  }
  
  const staleWarning = isStale ? `
    <div class="weather-status">
      ‚ö†Ô∏è Showing cached data - could not refresh
    </div>
  ` : '';
  
  document.getElementById('weatherModule').innerHTML = `
    <div class="weather-header">
      <span class="weather-icon">${getWeatherIcon(condition)}</span>
      <h3>Weather for Mountainside, NJ</h3>
    </div>
    <div class="weather-content">
      <div class="weather-image-section">
        <div class="weather-image-label">${imageLabel}</div>
        <img src="${weatherImage}" alt="Weather" class="weather-image" onerror="this.style.display='none'">
      </div>
      <div class="current-weather">
        <div class="temperature">${temp}¬∞F</div>
        <div class="weather-condition">${description}</div>
        <div class="weather-details">
          <span>üíß ${humidity}%</span>
          <span>üí® ${windSpeed} mph</span>
        </div>
      </div>
      <div class="weather-forecast">
        ${forecastDays.map(day => `
          <div class="forecast-day">
            <div class="day-name">${day.date.toLocaleDateString('en-US', { weekday: 'short' })}</div>
            <div class="day-icon">${getWeatherIcon(day.condition)}</div>
            <div class="day-temp">${day.temp}¬∞</div>
          </div>
        `).join('')}
      </div>
    </div>
    ${staleWarning}
  `;
}

function getWeatherIcon(condition) {
  const iconMap = {
    'Clear': '‚òÄÔ∏è',
    'Clouds': '‚òÅÔ∏è',
    'Rain': 'üåßÔ∏è',
    'Drizzle': 'üå¶Ô∏è',
    'Thunderstorm': '‚õàÔ∏è',
    'Snow': '‚ùÑÔ∏è',
    'Mist': 'üå´Ô∏è',
    'Fog': 'üå´Ô∏è',
    'Haze': 'üå´Ô∏è'
  };
  return iconMap[condition] || 'üå§Ô∏è';
}

function generateWeekendPreview() {
  const weekendGames = getWeekendGames();
  
  // Sort games by date and time
  weekendGames.sort((a, b) => {
    const dateA = parseGameDate(a.date);
    const dateB = parseGameDate(b.date);
    
    // First sort by date
    if (dateA.getTime() !== dateB.getTime()) {
      return dateA - dateB;
    }
    
    // If same date, sort by time from game object
    const timeA = a.time;
    const timeB = b.time;
    
    if (timeA && timeB) {
      // Parse time strings (e.g., "9:00 AM", "12:30 PM", or "10:00" in 24-hour)
      const parsedTimeA = parseTimeString(timeA);
      const parsedTimeB = parseTimeString(timeB);
      return parsedTimeA - parsedTimeB;
    }
    
    return 0;
  });
  
  
  const weekendInfoElement = document.getElementById('weekendInfo');
  weekendInfoElement.classList.remove('loading');
  
  if (weekendGames.length === 0) {
    weekendInfoElement.innerHTML = `
      <h3>No Upcoming Games</h3>
      <p>No games scheduled for the next week</p>
    `;
    
    const gamesGridElement = document.getElementById('gamesGrid');
    gamesGridElement.innerHTML = `
      <div class="no-games">
        <h3>No Games This Weekend</h3>
        <p>Check back later for upcoming matchups</p>
        <a href="current-season.html" class="nav-link" style="display: inline-block; margin-top: 1rem;">
          View Full Schedule
        </a>
      </div>
    `;
    return;
  }

  const earliestDate = parseGameDate(weekendGames[0].date);
  const latestDate = parseGameDate(weekendGames[weekendGames.length - 1].date);
  
  let dateRangeText;
  if (earliestDate.toDateString() === latestDate.toDateString()) {
    dateRangeText = earliestDate.toLocaleDateString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric'
    });
  } else {
    dateRangeText = `${earliestDate.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric' 
    })} - ${latestDate.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric' 
    })}`;
  }

  weekendInfoElement.innerHTML = `
    <h3>Upcoming Games</h3>
    <p>${weekendGames.length} games scheduled for ${dateRangeText}</p>
  `;

  const gamesGridElement = document.getElementById('gamesGrid');
  const gamesHtml = weekendGames.map(game => createGameCard(game)).join('');
  gamesGridElement.innerHTML = gamesHtml;
}

function createGameCard(game) {
  const homeTeam = game["home team"];
  const awayTeam = game["away team"];
  const gameDate = parseGameDate(game.date);
  
  const homeRecord = calculateTeamRecord(homeTeam);
  const awayRecord = calculateTeamRecord(awayTeam);
  
  const homeStanding = calculateTeamStanding(homeTeam);
  const awayStanding = calculateTeamStanding(awayTeam);
  
  // 2026+ UPDATE: Preview data is now directly on the game object
  // No need to call getGamePreview() - just use the game object's fields
  const homeRecordText = `${homeRecord.wins}-${homeRecord.losses}${homeRecord.ties > 0 ? `-${homeRecord.ties}` : ''}`;
  const awayRecordText = `${awayRecord.wins}-${awayRecord.losses}${awayRecord.ties > 0 ? `-${awayRecord.ties}` : ''}`;
  
  const homeStandingText = homeStanding ? `#${homeStanding}` : 'NR';
  const awayStandingText = awayStanding ? `#${awayStanding}` : 'NR';
  
  let gameDateTime;
  // Check for time directly on game object
  const gameTime = game.time;
  
  if (gameTime) {
    const dateStr = gameDate.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric'
    });
    // If time is in 24-hour format (e.g., "10:00"), convert to 12-hour with AM/PM
    let displayTime = gameTime;
    if (gameTime.match(/^\d{1,2}:\d{2}$/)) {
      const [hours, minutes] = gameTime.split(':').map(Number);
      const period = hours >= 12 ? 'PM' : 'AM';
      const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
      displayTime = `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
    }
    gameDateTime = `${dateStr} ${displayTime}`;
  } else {
    gameDateTime = gameDate.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  }

  const homeTeamColor = getTeamColor(homeTeam);
  const cardBackgroundStyle = homeTeamColor ?
    `background: linear-gradient(135deg, rgba(${homeTeamColor}, 0.08) 0%, rgba(${homeTeamColor}, 0.02) 100%) !important;` :
    '';

  // 2026+ UPDATE: Get odds directly from game object
  let oddsHtml = '';
  if (game["home odds"] || game["away odds"]) {
    const homeOdds = parseInt(game["home odds"] || 0);
    const awayOdds = parseInt(game["away odds"] || 0);
    
    if (homeOdds !== 0 || awayOdds !== 0) {
      const homeIsFavorite = homeOdds < 0 && (awayOdds > 0 || homeOdds > awayOdds);
      const awayIsFavorite = awayOdds < 0 && (homeOdds > 0 || awayOdds > homeOdds);

      oddsHtml = `
        <div class="game-odds">
          <div class="odds-item">
            <div class="odds-team">${awayTeam}</div>
            <div class="odds-value ${awayIsFavorite ? 'favorite' : ''}">${awayOdds > 0 ? '+' : ''}${awayOdds}</div>
          </div>
          <div class="odds-item">
            <div class="odds-team">${homeTeam}</div>
            <div class="odds-value ${homeIsFavorite ? 'favorite' : ''}">${homeOdds > 0 ? '+' : ''}${homeOdds}</div>
          </div>
        </div>
      `;
    }
  }

  const homeTopPlayers = getTopPlayers(homeTeam);
  const awayTopPlayers = getTopPlayers(awayTeam);
  
  let keyPlayersHtml = '';
  if (homeTopPlayers.length > 0 || awayTopPlayers.length > 0) {
    keyPlayersHtml = `
      <div class="key-players">
        <h4>Key Players</h4>
        <div class="players-grid">
          <div class="team-players">
            <h5>${awayTeam}</h5>
            <div class="player-list">
              ${awayTopPlayers.length > 0 ? 
                awayTopPlayers.map(player => `<span class="player-name">${player}</span>`).join('') :
                '<span class="player-name">No data available</span>'
              }
            </div>
          </div>
          <div class="team-players">
            <h5>${homeTeam}</h5>
            <div class="player-list">
              ${homeTopPlayers.length > 0 ? 
                homeTopPlayers.map(player => `<span class="player-name">${player}</span>`).join('') :
                '<span class="player-name">No data available</span>'
              }
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // For playoff games with IDs, use game ID; otherwise use team names and date
  const isPlayoffGame = game.id && game.id.startsWith('playoff_');
  const previewLink = isPlayoffGame ? 
    `game-preview.html?gameId=${encodeURIComponent(game.id)}` :
    `game-preview.html?home=${encodeURIComponent(homeTeam)}&away=${encodeURIComponent(awayTeam)}&date=${encodeURIComponent(game.date)}`;

  return `
    <a href="${previewLink}" 
       class="game-card" style="${cardBackgroundStyle}">
      <div class="game-header">
        <div class="game-date">${gameDateTime}</div>
        <div class="game-type">${game.game_type} Season</div>
      </div>
      
      <div class="teams-matchup">
        <div class="team-info">
          <img class="team-logo" 
               src="logos/${awayTeam.toLowerCase().replace(/\s+/g, '_')}.png" 
               alt="${awayTeam} logo" 
               onerror="this.style.display='none'">
          <div class="team-name">${awayTeam}</div>
          <div class="team-record">${awayRecordText}</div>
          <div class="team-standing">${awayStandingText} in standings</div>
        </div>
        
        <div class="vs-section">
          <div class="vs-text">@</div>
          <div class="home-indicator">Home</div>
        </div>
        
        <div class="team-info">
          <img class="team-logo" 
               src="logos/${homeTeam.toLowerCase().replace(/\s+/g, '_')}.png" 
               alt="${homeTeam} logo" 
               onerror="this.style.display='none'">
          <div class="team-name">${homeTeam}</div>
          <div class="team-record">${homeRecordText}</div>
          <div class="team-standing">${homeStandingText} in standings</div>
        </div>
      </div>
      
      ${oddsHtml}
      ${keyPlayersHtml}
    </a>
  `;
}

function showError() {
  const weekendInfoElement = document.getElementById('weekendInfo');
  weekendInfoElement.classList.remove('loading');
  weekendInfoElement.innerHTML = `
    <h3>Error Loading Data</h3>
    <p>Unable to load weekend games. Please try again later.</p>
  `;
  
  document.getElementById('gamesGrid').innerHTML = `
    <div class="no-games">
      <h3>Error Loading Games</h3>
      <p>There was an error loading the weekend schedule.</p>
    </div>
  `;
}

function updateConnectionStatus() {
  const status = document.getElementById('connectionStatus');
  if (!status) return;
  
  const icon = status.querySelector('.status-icon');
  const text = status.querySelector('.status-text');
  
  if (navigator.onLine) {
    // Show "Back online" message
    status.classList.remove('hidden');  // SHOW IT FIRST
    status.classList.add('online');
    icon.textContent = '‚úÖ';
    text.textContent = 'Back online';
    
    // Hide after 3 seconds
    setTimeout(() => {
      status.classList.add('hidden');
    }, 3000);
  } else {
    // Show "You're offline" message
    status.classList.remove('hidden', 'online');
    icon.textContent = 'üì°';
    text.textContent = "You're offline";
  }
}

window.addEventListener('online', updateConnectionStatus);
window.addEventListener('offline', updateConnectionStatus);
if (!navigator.onLine) updateConnectionStatus();
</script>
<script type="module">
  import { NavigationComponent } from './nav-component.js';
  // Navigation auto-initializes on load!
</script>
<script src="banner.js?v=3"></script>
<script src="mobile-enhancements.js"></script>
<script src="theme-toggle.js"></script>
</body>
</html>

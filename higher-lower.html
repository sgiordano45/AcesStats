<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aces Higher or Lower - Mountainside Aces</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
:root {
  --primary-color: #2d5016;
  --secondary-color: #1a6b4a;
  --accent-color: #ffd700;
  --card-bg: #ffffff;
  --text-dark: #2d3748;
  --text-light: #718096;
  --border-color: #e2e8f0;
  --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
  --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
  --correct-color: #48bb78;
  --incorrect-color: #f56565;
  --higher-color: #3182ce;
  --lower-color: #e53e3e;
}

* { box-sizing: border-box; }

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  margin: 0;
  padding: 0;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  min-height: 100vh;
  color: var(--text-dark);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,255,255,0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.5s ease, visibility 0.5s ease;
}

.loading-overlay.hidden {
  opacity: 0;
  visibility: hidden;
}

.softball-spinner::before {
  content: '‚öæ';
  font-size: 80px;
  animation: spin 1.5s ease-in-out infinite;
  display: block;
}

@keyframes spin {
  0%, 100% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.1); }
}

/* Page Container */
.page-container {
  max-width: 800px;
  margin: 0 auto;
  padding: 1.5rem;
}

/* Page Header */
.page-header {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  color: white;
  text-align: center;
  padding: 2rem 1.5rem;
  border-radius: 16px;
  margin-bottom: 1.5rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
}

.back-link {
  position: absolute;
  top: 1rem;
  left: 1rem;
  color: rgba(255,255,255,0.85);
  text-decoration: none;
  font-size: 0.85rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.35rem 0.75rem;
  background: rgba(255,255,255,0.15);
  border-radius: 6px;
  transition: all 0.2s ease;
  z-index: 10;
}

.back-link:hover {
  background: rgba(255,255,255,0.25);
  color: white;
}

.page-header::before {
  content: '';
  position: absolute;
  top: -100px;
  right: -100px;
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
  border-radius: 50%;
}

.page-header h1 {
  margin: 0;
  font-size: 2.25rem;
  font-weight: 800;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  position: relative;
  z-index: 1;
}

.page-header p {
  margin: 0.5rem 0 0 0;
  font-size: 1rem;
  opacity: 0.95;
  position: relative;
  z-index: 1;
}

.puzzle-date {
  font-size: 0.9rem;
  opacity: 0.85;
  margin-top: 0.5rem;
}

/* Category Badge */
.category-badge {
  display: inline-block;
  background: rgba(255,255,255,0.2);
  padding: 0.5rem 1rem;
  border-radius: 20px;
  margin-top: 0.75rem;
  font-weight: 600;
  font-size: 0.95rem;
}

/* Game Stats Bar */
.game-stats-bar {
  display: flex;
  justify-content: center;
  gap: 2rem;
  background: var(--card-bg);
  padding: 1rem;
  border-radius: 12px;
  margin-bottom: 1.5rem;
  box-shadow: var(--shadow-sm);
  flex-wrap: wrap;
}

.stat-item {
  text-align: center;
}

.stat-value {
  font-size: 1.75rem;
  font-weight: 700;
  color: var(--primary-color);
}

.stat-label {
  font-size: 0.85rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* User Stats Section */
.user-stats-container {
  background: var(--card-bg);
  border-radius: 12px;
  padding: 1rem 1.25rem;
  margin-bottom: 1.5rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
}

.user-stats-content {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.user-greeting {
  font-weight: 600;
  color: var(--text-dark);
}

.sign-in-prompt {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: var(--text-light);
  font-size: 0.9rem;
}

.sign-in-prompt a {
  color: var(--primary-color);
  font-weight: 600;
  text-decoration: none;
}

.sign-in-prompt a:hover {
  text-decoration: underline;
}

.lifetime-stats {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}

.lifetime-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 50px;
}

.lifetime-value {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--primary-color);
}

.lifetime-label {
  font-size: 0.7rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

/* Game Container */
.game-container {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.5rem;
  box-shadow: var(--shadow-md);
  margin-bottom: 1.5rem;
}

/* Progress Indicator */
.progress-container {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
}

.progress-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--border-color);
  transition: all 0.3s ease;
}

.progress-dot.correct {
  background: var(--correct-color);
}

.progress-dot.incorrect {
  background: var(--incorrect-color);
}

.progress-dot.current {
  background: var(--primary-color);
  transform: scale(1.3);
}

/* Question Text */
.question-text {
  text-align: center;
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--text-dark);
  margin-bottom: 1.5rem;
}

.question-text .stat-name {
  color: var(--primary-color);
}

/* Comparison Area */
.comparison-area {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 1rem;
  align-items: center;
}

.player-card {
  background: linear-gradient(135deg, #f8fafc, #edf2f7);
  border: 3px solid var(--border-color);
  border-radius: 16px;
  padding: 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.player-card:hover:not(.revealed) {
  border-color: var(--primary-color);
  transform: translateY(-4px);
  box-shadow: var(--shadow-md);
}

.player-card.selected {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(45, 80, 22, 0.2);
}

.player-card.correct {
  border-color: var(--correct-color);
  background: linear-gradient(135deg, #c6f6d5, #9ae6b4);
}

.player-card.incorrect {
  border-color: var(--incorrect-color);
  background: linear-gradient(135deg, #fed7d7, #feb2b2);
}

.player-card.revealed {
  cursor: default;
}

.player-name {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--text-dark);
  margin-bottom: 0.5rem;
}

.player-team {
  font-size: 0.85rem;
  color: var(--text-light);
  margin-bottom: 0.75rem;
}

.player-stat {
  font-size: 2rem;
  font-weight: 800;
  color: var(--primary-color);
  opacity: 0;
  transition: opacity 0.5s ease;
}

.player-card.revealed .player-stat {
  opacity: 1;
}

.player-stat.hidden-stat {
  font-size: 1.5rem;
  opacity: 1;
  color: var(--text-light);
}

.vs-divider {
  font-size: 1.5rem;
  font-weight: 800;
  color: var(--text-light);
  padding: 0 0.5rem;
}

/* Result Overlay */
.result-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 3rem;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.player-card.correct .result-overlay,
.player-card.incorrect .result-overlay {
  opacity: 1;
}

/* Next Button */
.next-button-container {
  text-align: center;
  margin-top: 1.5rem;
  display: none;
}

.next-button-container.visible {
  display: block;
}

.next-btn {
  background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
  color: white;
  border: none;
  padding: 1rem 2.5rem;
  border-radius: 12px;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.next-btn:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

/* How to Play */
.how-to-play {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.5rem;
  box-shadow: var(--shadow-sm);
  margin-bottom: 1.5rem;
}

.how-to-play h3 {
  margin: 0 0 1rem 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
}

.how-to-play-content {
  display: none;
}

.how-to-play.expanded .how-to-play-content {
  display: block;
}

.how-to-play ul {
  margin: 0;
  padding-left: 1.5rem;
}

.how-to-play li {
  margin-bottom: 0.5rem;
  line-height: 1.5;
}

/* Action Buttons */
.action-buttons {
  display: flex;
  gap: 1rem;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 1.5rem;
}

.action-btn {
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid var(--primary-color);
  background: white;
  color: var(--primary-color);
}

.action-btn:hover {
  background: var(--primary-color);
  color: white;
}

.action-btn.primary {
  background: var(--primary-color);
  color: white;
}

.action-btn.primary:hover {
  background: var(--secondary-color);
}

/* Game Over Modal */
.modal-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
  padding: 1rem;
}

.modal-overlay.active {
  opacity: 1;
  visibility: visible;
}

.modal-content {
  background: white;
  border-radius: 16px;
  width: 100%;
  max-width: 450px;
  max-height: 80vh;
  overflow: hidden;
  box-shadow: var(--shadow-lg);
  transform: translateY(20px);
  transition: transform 0.3s ease;
}

.modal-overlay.active .modal-content {
  transform: translateY(0);
}

.game-over-content {
  text-align: center;
  padding: 2rem;
}

.game-over-content h2 {
  margin: 0 0 1rem 0;
  font-size: 1.75rem;
}

.final-score {
  font-size: 3rem;
  font-weight: 800;
  color: var(--primary-color);
  margin: 1rem 0;
}

.score-breakdown {
  display: flex;
  justify-content: center;
  gap: 2rem;
  margin: 1.5rem 0;
}

.breakdown-item {
  text-align: center;
}

.breakdown-value {
  font-size: 1.5rem;
  font-weight: 700;
}

.breakdown-label {
  font-size: 0.8rem;
  color: var(--text-light);
}

.share-section {
  margin-top: 1.5rem;
}

.share-btn {
  background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
  color: white;
  border: none;
  padding: 1rem 2rem;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.share-btn:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.share-preview {
  background: #f7fafc;
  padding: 1rem;
  border-radius: 8px;
  margin-top: 1rem;
  font-family: monospace;
  font-size: 0.85rem;
  white-space: pre-line;
  text-align: left;
}

/* Responsive */
@media (max-width: 600px) {
  .page-header h1 { font-size: 1.75rem; }
  
  .comparison-area {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }
  
  .vs-divider {
    padding: 0.25rem 0;
  }
  
  .player-card {
    padding: 1.25rem;
  }
  
  .player-name {
    font-size: 1.1rem;
  }
  
  .player-stat {
    font-size: 1.75rem;
  }
  
  .game-stats-bar { gap: 1rem; }
  .stat-value { font-size: 1.4rem; }
  
  .lifetime-stats {
    justify-content: space-between;
  }
  
  .lifetime-stat {
    min-width: 45px;
  }
  
  .lifetime-value {
    font-size: 1.1rem;
  }
}
</style>
</head>
<body>

<div class="loading-overlay" id="loadingOverlay">
  <div class="softball-spinner"></div>
</div>

<!-- Navigation placeholder -->
<nav id="main-nav"></nav>

<div class="page-container">
  <div class="page-header">
    <a href="games.html" class="back-link">‚Üê Games</a>
    <h1>üìä Higher or Lower</h1>
    <p>Which player has the higher stat?</p>
    <div class="puzzle-date" id="puzzleDate">Puzzle #1</div>
    <div class="category-badge" id="categoryBadge">Career Hits</div>
  </div>

  <div class="game-stats-bar">
    <div class="stat-item">
      <div class="stat-value" id="scoreDisplay">0/5</div>
      <div class="stat-label">Score</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="roundDisplay">1</div>
      <div class="stat-label">Round</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="streakDisplay">0</div>
      <div class="stat-label">Streak</div>
    </div>
  </div>

  <!-- User Stats Section -->
  <div class="user-stats-container" id="userStatsContainer">
    <div class="user-stats-content">
      <div class="sign-in-prompt">
        <span>üîí</span>
        <a href="signin.html">Sign in</a> to track your stats across devices
      </div>
    </div>
  </div>

  <div class="game-container">
    <div class="progress-container" id="progressContainer">
      <div class="progress-dot current"></div>
      <div class="progress-dot"></div>
      <div class="progress-dot"></div>
      <div class="progress-dot"></div>
      <div class="progress-dot"></div>
    </div>

    <div class="question-text" id="questionText">
      Who has more <span class="stat-name">Career Hits</span>?
    </div>

    <div class="comparison-area" id="comparisonArea">
      <div class="player-card" id="playerLeft" onclick="selectPlayer('left')">
        <div class="player-name" id="leftName">Player 1</div>
        <div class="player-team" id="leftTeam">Team</div>
        <div class="player-stat hidden-stat" id="leftStat">?</div>
        <div class="result-overlay" id="leftResult"></div>
      </div>
      
      <div class="vs-divider">VS</div>
      
      <div class="player-card" id="playerRight" onclick="selectPlayer('right')">
        <div class="player-name" id="rightName">Player 2</div>
        <div class="player-team" id="rightTeam">Team</div>
        <div class="player-stat hidden-stat" id="rightStat">?</div>
        <div class="result-overlay" id="rightResult"></div>
      </div>
    </div>

    <div class="next-button-container" id="nextButtonContainer">
      <button class="next-btn" onclick="nextRound()">Next Round ‚Üí</button>
    </div>
  </div>

  <div class="how-to-play" id="howToPlay">
    <h3 onclick="toggleHowToPlay()">üìñ How to Play <span id="howToPlayToggle">‚ñº</span></h3>
    <div class="how-to-play-content">
      <ul>
        <li><strong>Pick the player</strong> you think has the higher stat for today's category.</li>
        <li>Each day features a <strong>different stat</strong> - career totals or a specific season.</li>
        <li>Complete <strong>5 rounds</strong> to finish the daily challenge.</li>
        <li>Build your <strong>streak</strong> by playing every day!</li>
        <li>A new puzzle is available each day at midnight.</li>
      </ul>
    </div>
  </div>

  <div class="action-buttons">
    <button class="action-btn primary" onclick="viewResults()" id="resultsBtn" style="display:none;">üèÜ View Results</button>
    <button class="action-btn" onclick="shareResults()" id="shareBtn" style="display:none;">üì§ Share</button>
  </div>
</div>

<!-- Game Over Modal -->
<div class="modal-overlay" id="gameOverModal">
  <div class="modal-content">
    <div class="game-over-content">
      <h2 id="gameOverTitle">üéâ Game Complete!</h2>
      <div class="final-score" id="finalScore">4/5</div>
      <div class="score-breakdown">
        <div class="breakdown-item">
          <div class="breakdown-value" id="correctCount">4</div>
          <div class="breakdown-label">Correct</div>
        </div>
        <div class="breakdown-item">
          <div class="breakdown-value" id="currentStreak">3</div>
          <div class="breakdown-label">Day Streak</div>
        </div>
        <div class="breakdown-item">
          <div class="breakdown-value" id="bestStreak">7</div>
          <div class="breakdown-label">Best Streak</div>
        </div>
      </div>
      <div class="share-section">
        <button class="share-btn" onclick="shareResults()">üì§ Share Results</button>
        <div class="share-preview" id="sharePreview"></div>
      </div>
      <div class="action-buttons" style="margin-top:1rem;">
        <button class="action-btn" onclick="closeGameOverModal()">Close</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
import { 
  db, 
  collection, 
  getDocs,
  doc,
  getDoc
} from './firebase-config.js';

import {
  setDoc,
  updateDoc,
  serverTimestamp
} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

import { 
  getAllPlayerStatsOptimized,
  seasonsObjectToArray
} from './firebase-data.js';

import {
  getCurrentUser,
  onAuthChange,
  getUserProfile
} from './firebase-auth.js';

// ============================================
// CONFIGURATION
// ============================================
// Set this to the date you want Puzzle #1 to be
// TODO: Change back to '2026-01-12' before launch!
const LAUNCH_DATE = '2026-01-06';

const TOTAL_ROUNDS = 5;

// ============================================
// AUTH STATE
// ============================================
let currentUser = null;
let userStats = null;

// ============================================
// GAME STATE
// ============================================
let allPlayers = [];
let todaysPuzzle = null;
let gameState = {
  currentRound: 0,
  score: 0,
  roundResults: [], // Array of true/false for each round
  gameOver: false,
  currentStreak: 0
};

// ============================================
// CATEGORY DEFINITIONS
// ============================================
const STAT_CATEGORIES = [
  // Career stats
  { id: 'career_hits', label: 'Career Hits', type: 'career', field: 'hits', format: 'number' },
  { id: 'career_runs', label: 'Career Runs', type: 'career', field: 'runs', format: 'number' },
  { id: 'career_walks', label: 'Career Walks', type: 'career', field: 'walks', format: 'number' },
  { id: 'career_games', label: 'Career Games', type: 'career', field: 'games', format: 'number' },
  { id: 'career_ba', label: 'Career Batting Avg', type: 'career', field: 'battingAverage', format: 'avg' },
  
  // 2022 Season stats
  { id: '2022_summer_hits', label: '2022 Summer Hits', type: 'season', seasonId: '2022-summer', field: 'hits', format: 'number' },
  { id: '2022_summer_runs', label: '2022 Summer Runs', type: 'season', seasonId: '2022-summer', field: 'runs', format: 'number' },
  { id: '2022_summer_walks', label: '2022 Summer Walks', type: 'season', seasonId: '2022-summer', field: 'walks', format: 'number' },
  { id: '2022_summer_games', label: '2022 Summer Games', type: 'season', seasonId: '2022-summer', field: 'games', format: 'number' },
  { id: '2022_summer_ba', label: '2022 Summer BA', type: 'season', seasonId: '2022-summer', field: 'battingAverage', format: 'avg', minAB: 20 },
  { id: '2022_fall_hits', label: '2022 Fall Hits', type: 'season', seasonId: '2022-fall', field: 'hits', format: 'number' },
  { id: '2022_fall_runs', label: '2022 Fall Runs', type: 'season', seasonId: '2022-fall', field: 'runs', format: 'number' },
  { id: '2022_fall_walks', label: '2022 Fall Walks', type: 'season', seasonId: '2022-fall', field: 'walks', format: 'number' },
  { id: '2022_fall_games', label: '2022 Fall Games', type: 'season', seasonId: '2022-fall', field: 'games', format: 'number' },
  { id: '2022_fall_ba', label: '2022 Fall BA', type: 'season', seasonId: '2022-fall', field: 'battingAverage', format: 'avg', minAB: 20 },
  
  // 2023 Season stats
  { id: '2023_summer_hits', label: '2023 Summer Hits', type: 'season', seasonId: '2023-summer', field: 'hits', format: 'number' },
  { id: '2023_summer_runs', label: '2023 Summer Runs', type: 'season', seasonId: '2023-summer', field: 'runs', format: 'number' },
  { id: '2023_summer_walks', label: '2023 Summer Walks', type: 'season', seasonId: '2023-summer', field: 'walks', format: 'number' },
  { id: '2023_summer_games', label: '2023 Summer Games', type: 'season', seasonId: '2023-summer', field: 'games', format: 'number' },
  { id: '2023_summer_ba', label: '2023 Summer BA', type: 'season', seasonId: '2023-summer', field: 'battingAverage', format: 'avg', minAB: 20 },
  { id: '2023_fall_hits', label: '2023 Fall Hits', type: 'season', seasonId: '2023-fall', field: 'hits', format: 'number' },
  { id: '2023_fall_runs', label: '2023 Fall Runs', type: 'season', seasonId: '2023-fall', field: 'runs', format: 'number' },
  { id: '2023_fall_walks', label: '2023 Fall Walks', type: 'season', seasonId: '2023-fall', field: 'walks', format: 'number' },
  { id: '2023_fall_games', label: '2023 Fall Games', type: 'season', seasonId: '2023-fall', field: 'games', format: 'number' },
  { id: '2023_fall_ba', label: '2023 Fall BA', type: 'season', seasonId: '2023-fall', field: 'battingAverage', format: 'avg', minAB: 20 },
  
  // 2024 Season stats
  { id: '2024_summer_hits', label: '2024 Summer Hits', type: 'season', seasonId: '2024-summer', field: 'hits', format: 'number' },
  { id: '2024_summer_runs', label: '2024 Summer Runs', type: 'season', seasonId: '2024-summer', field: 'runs', format: 'number' },
  { id: '2024_summer_walks', label: '2024 Summer Walks', type: 'season', seasonId: '2024-summer', field: 'walks', format: 'number' },
  { id: '2024_summer_games', label: '2024 Summer Games', type: 'season', seasonId: '2024-summer', field: 'games', format: 'number' },
  { id: '2024_summer_ba', label: '2024 Summer BA', type: 'season', seasonId: '2024-summer', field: 'battingAverage', format: 'avg', minAB: 20 },
  { id: '2024_fall_hits', label: '2024 Fall Hits', type: 'season', seasonId: '2024-fall', field: 'hits', format: 'number' },
  { id: '2024_fall_runs', label: '2024 Fall Runs', type: 'season', seasonId: '2024-fall', field: 'runs', format: 'number' },
  { id: '2024_fall_walks', label: '2024 Fall Walks', type: 'season', seasonId: '2024-fall', field: 'walks', format: 'number' },
  { id: '2024_fall_games', label: '2024 Fall Games', type: 'season', seasonId: '2024-fall', field: 'games', format: 'number' },
  { id: '2024_fall_ba', label: '2024 Fall BA', type: 'season', seasonId: '2024-fall', field: 'battingAverage', format: 'avg', minAB: 20 },
  
  // 2025 Season stats
  { id: '2025_summer_hits', label: '2025 Summer Hits', type: 'season', seasonId: '2025-summer', field: 'hits', format: 'number' },
  { id: '2025_summer_runs', label: '2025 Summer Runs', type: 'season', seasonId: '2025-summer', field: 'runs', format: 'number' },
  { id: '2025_summer_walks', label: '2025 Summer Walks', type: 'season', seasonId: '2025-summer', field: 'walks', format: 'number' },
  { id: '2025_summer_games', label: '2025 Summer Games', type: 'season', seasonId: '2025-summer', field: 'games', format: 'number' },
  { id: '2025_summer_ba', label: '2025 Summer BA', type: 'season', seasonId: '2025-summer', field: 'battingAverage', format: 'avg', minAB: 20 },
  { id: '2025_fall_hits', label: '2025 Fall Hits', type: 'season', seasonId: '2025-fall', field: 'hits', format: 'number' },
  { id: '2025_fall_runs', label: '2025 Fall Runs', type: 'season', seasonId: '2025-fall', field: 'runs', format: 'number' },
  { id: '2025_fall_walks', label: '2025 Fall Walks', type: 'season', seasonId: '2025-fall', field: 'walks', format: 'number' },
  { id: '2025_fall_games', label: '2025 Fall Games', type: 'season', seasonId: '2025-fall', field: 'games', format: 'number' },
  { id: '2025_fall_ba', label: '2025 Fall BA', type: 'season', seasonId: '2025-fall', field: 'battingAverage', format: 'avg', minAB: 20 },
];

// ============================================
// SEEDED RANDOM FOR DAILY PUZZLES
// ============================================
function seededRandom(seed) {
  const x = Math.sin(seed) * 10000;
  return x - Math.floor(x);
}

function getDayNumber() {
  const [launchYear, launchMonth, launchDay] = LAUNCH_DATE.split('-').map(Number);
  const start = new Date(launchYear, launchMonth - 1, launchDay).setHours(0, 0, 0, 0);
  const now = new Date().setHours(0, 0, 0, 0);
  const daysSinceLaunch = Math.floor((now - start) / (1000 * 60 * 60 * 24));
  return Math.max(1, daysSinceLaunch + 1);
}

function shuffleWithSeed(array, seed) {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    seed++;
    const j = Math.floor(seededRandom(seed) * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

// ============================================
// STAT HELPERS
// ============================================
function getPlayerStat(player, category) {
  if (category.type === 'career') {
    const value = player.career?.[category.field];
    return value !== undefined ? value : null;
  } else if (category.type === 'season') {
    const season = player.seasons?.[category.seasonId];
    if (!season) return null;
    
    // Check minimum at-bats for batting average
    if (category.minAB && (season.atBats || 0) < category.minAB) {
      return null;
    }
    
    return season[category.field] !== undefined ? season[category.field] : null;
  }
  return null;
}

function formatStat(value, format) {
  if (value === null || value === undefined) return '?';
  
  if (format === 'avg') {
    return value.toFixed(3).replace(/^0/, '');
  }
  return Math.round(value).toString();
}

function getPlayerTeam(player, category) {
  if (category.type === 'season' && category.seasonId) {
    const season = player.seasons?.[category.seasonId];
    return season?.team || player.currentTeam || '?';
  }
  return player.currentTeam || '?';
}

// ============================================
// PUZZLE GENERATION
// ============================================
function generateDailyPuzzle() {
  const dayNum = getDayNumber();
  const seed = dayNum * 54322;
  
  // Pick today's category
  const categoryIndex = dayNum % STAT_CATEGORIES.length;
  const category = STAT_CATEGORIES[categoryIndex];
  
  // Find players with valid stats for this category
  const validPlayers = allPlayers.filter(p => {
    const stat = getPlayerStat(p, category);
    return stat !== null && stat !== undefined;
  });
  
  // Shuffle players
  const shuffledPlayers = shuffleWithSeed(validPlayers, seed);
  
  // Generate 5 matchups with interesting stat differences
  const matchups = [];
  const usedPlayers = new Set();
  
  for (let i = 0; i < shuffledPlayers.length - 1 && matchups.length < TOTAL_ROUNDS; i++) {
    const player1 = shuffledPlayers[i];
    
    if (usedPlayers.has(player1.name)) continue;
    
    // Find a good opponent
    for (let j = i + 1; j < shuffledPlayers.length; j++) {
      const player2 = shuffledPlayers[j];
      
      if (usedPlayers.has(player2.name)) continue;
      
      const stat1 = getPlayerStat(player1, category);
      const stat2 = getPlayerStat(player2, category);
      
      // Make sure stats are different (more interesting)
      if (stat1 !== stat2) {
        matchups.push({
          left: player1,
          right: player2,
          leftStat: stat1,
          rightStat: stat2
        });
        usedPlayers.add(player1.name);
        usedPlayers.add(player2.name);
        break;
      }
    }
  }
  
  return {
    dayNum,
    category,
    matchups
  };
}

// ============================================
// UI RENDERING
// ============================================
function renderRound() {
  const round = gameState.currentRound;
  const matchup = todaysPuzzle.matchups[round];
  const category = todaysPuzzle.category;
  
  // Update question text
  document.getElementById('questionText').innerHTML = 
    `Who has more <span class="stat-name">${category.label}</span>?`;
  
  // Update category badge
  document.getElementById('categoryBadge').textContent = category.label;
  
  // Update player cards
  document.getElementById('leftName').textContent = matchup.left.name;
  document.getElementById('leftTeam').textContent = getPlayerTeam(matchup.left, category);
  
  document.getElementById('rightName').textContent = matchup.right.name;
  document.getElementById('rightTeam').textContent = getPlayerTeam(matchup.right, category);
  
  // Get card elements
  const leftCard = document.getElementById('playerLeft');
  const rightCard = document.getElementById('playerRight');
  
  // Check if this round was already completed (game over or reviewing past round)
  if (gameState.gameOver && gameState.roundResults.length > round) {
    // Show revealed stats for completed game
    const leftStat = matchup.leftStat;
    const rightStat = matchup.rightStat;
    const wasCorrect = gameState.roundResults[round];
    const correctSide = leftStat >= rightStat ? 'left' : 'right';
    
    document.getElementById('leftStat').textContent = formatStat(leftStat, category.format);
    document.getElementById('leftStat').classList.remove('hidden-stat');
    document.getElementById('rightStat').textContent = formatStat(rightStat, category.format);
    document.getElementById('rightStat').classList.remove('hidden-stat');
    
    // Show revealed state on cards
    leftCard.className = 'player-card revealed';
    rightCard.className = 'player-card revealed';
    
    // Mark the winning side
    if (leftStat >= rightStat) {
      document.getElementById('leftResult').textContent = '‚úì';
      leftCard.classList.add('correct');
    } else {
      document.getElementById('rightResult').textContent = '‚úì';
      rightCard.classList.add('correct');
    }
  } else {
    // Show hidden stats for active game
    document.getElementById('leftStat').textContent = '?';
    document.getElementById('leftStat').classList.add('hidden-stat');
    document.getElementById('rightStat').textContent = '?';
    document.getElementById('rightStat').classList.add('hidden-stat');
    
    // Reset card states
    leftCard.className = 'player-card';
    rightCard.className = 'player-card';
    
    document.getElementById('leftResult').textContent = '';
    document.getElementById('rightResult').textContent = '';
  }
  
  // Hide next button
  document.getElementById('nextButtonContainer').classList.remove('visible');
  
  // Update progress dots
  updateProgressDots();
  
  // Update stats display
  updateStats();
}

function updateProgressDots() {
  const dots = document.querySelectorAll('.progress-dot');
  dots.forEach((dot, i) => {
    dot.className = 'progress-dot';
    if (i < gameState.roundResults.length) {
      dot.classList.add(gameState.roundResults[i] ? 'correct' : 'incorrect');
    } else if (i === gameState.currentRound) {
      dot.classList.add('current');
    }
  });
}

function updateStats() {
  document.getElementById('scoreDisplay').textContent = `${gameState.score}/${TOTAL_ROUNDS}`;
  document.getElementById('roundDisplay').textContent = Math.min(gameState.currentRound + 1, TOTAL_ROUNDS);
  document.getElementById('streakDisplay').textContent = gameState.currentStreak;
}

// ============================================
// GAME LOGIC
// ============================================
window.selectPlayer = function(side) {
  if (gameState.gameOver) return;
  
  const matchup = todaysPuzzle.matchups[gameState.currentRound];
  const category = todaysPuzzle.category;
  
  // Check if already revealed
  const leftCard = document.getElementById('playerLeft');
  if (leftCard.classList.contains('revealed')) return;
  
  // Determine correct answer
  const leftStat = matchup.leftStat;
  const rightStat = matchup.rightStat;
  const correctSide = leftStat >= rightStat ? 'left' : 'right';
  const isCorrect = side === correctSide;
  
  // Handle tie - either answer is correct
  const isTie = leftStat === rightStat;
  const actuallyCorrect = isTie ? true : isCorrect;
  
  // Update game state
  gameState.roundResults.push(actuallyCorrect);
  if (actuallyCorrect) {
    gameState.score++;
    gameState.currentStreak++;
  }
  
  // Reveal stats
  document.getElementById('leftStat').textContent = formatStat(leftStat, category.format);
  document.getElementById('leftStat').classList.remove('hidden-stat');
  document.getElementById('rightStat').textContent = formatStat(rightStat, category.format);
  document.getElementById('rightStat').classList.remove('hidden-stat');
  
  // Update card states
  const rightCard = document.getElementById('playerRight');
  
  leftCard.classList.add('revealed');
  rightCard.classList.add('revealed');
  
  if (side === 'left') {
    leftCard.classList.add('selected');
    leftCard.classList.add(actuallyCorrect ? 'correct' : 'incorrect');
    document.getElementById('leftResult').textContent = actuallyCorrect ? '‚úì' : '‚úó';
  } else {
    rightCard.classList.add('selected');
    rightCard.classList.add(actuallyCorrect ? 'correct' : 'incorrect');
    document.getElementById('rightResult').textContent = actuallyCorrect ? '‚úì' : '‚úó';
  }
  
  // Update progress and stats
  updateProgressDots();
  updateStats();
  
  // Show next button or end game
  if (gameState.currentRound < TOTAL_ROUNDS - 1) {
    document.getElementById('nextButtonContainer').classList.add('visible');
  } else {
    // Game over
    setTimeout(() => {
      gameState.gameOver = true;
      saveGameState();
      showGameOver();
    }, 1000);
  }
  
  saveGameState();
};

window.nextRound = function() {
  gameState.currentRound++;
  renderRound();
};

// ============================================
// GAME OVER
// ============================================
function showGameOver() {
  document.getElementById('finalScore').textContent = `${gameState.score}/${TOTAL_ROUNDS}`;
  document.getElementById('correctCount').textContent = gameState.score;
  document.getElementById('currentStreak').textContent = userStats?.currentStreak || gameState.currentStreak;
  document.getElementById('bestStreak').textContent = userStats?.longestStreak || gameState.currentStreak;
  
  if (gameState.score === TOTAL_ROUNDS) {
    document.getElementById('gameOverTitle').textContent = 'üéâ Perfect!';
  } else if (gameState.score >= 4) {
    document.getElementById('gameOverTitle').textContent = '‚≠ê Great Job!';
  } else if (gameState.score >= 3) {
    document.getElementById('gameOverTitle').textContent = 'üëç Nice Try!';
  } else {
    document.getElementById('gameOverTitle').textContent = 'üí™ Keep Practicing!';
  }
  
  updateSharePreview();
  
  document.getElementById('gameOverModal').classList.add('active');
  document.getElementById('resultsBtn').style.display = 'inline-block';
  document.getElementById('shareBtn').style.display = 'inline-block';
}

window.closeGameOverModal = function() {
  document.getElementById('gameOverModal').classList.remove('active');
};

window.viewResults = function() {
  document.getElementById('finalScore').textContent = `${gameState.score}/${TOTAL_ROUNDS}`;
  document.getElementById('correctCount').textContent = gameState.score;
  document.getElementById('currentStreak').textContent = userStats?.currentStreak || 1;
  document.getElementById('bestStreak').textContent = userStats?.longestStreak || 1;
  updateSharePreview();
  document.getElementById('gameOverModal').classList.add('active');
};

// ============================================
// SHARING
// ============================================
function updateSharePreview() {
  const results = gameState.roundResults.map(r => r ? 'üü©' : 'üü•').join('');
  
  const shareText = `üìä Aces Higher or Lower #${todaysPuzzle.dayNum}
${todaysPuzzle.category.label}

${gameState.score}/${TOTAL_ROUNDS} ${results}

acessoftballreference.com/higher-lower.html`;
  
  document.getElementById('sharePreview').textContent = shareText;
}

window.shareResults = function() {
  const shareText = document.getElementById('sharePreview').textContent;
  
  if (navigator.share) {
    navigator.share({ text: shareText }).catch(() => copyToClipboard(shareText));
  } else {
    copyToClipboard(shareText);
  }
};

function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    alert('Results copied to clipboard!');
  }).catch(() => {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
    alert('Results copied to clipboard!');
  });
}

// ============================================
// HOW TO PLAY TOGGLE
// ============================================
window.toggleHowToPlay = function() {
  const section = document.getElementById('howToPlay');
  const toggle = document.getElementById('howToPlayToggle');
  section.classList.toggle('expanded');
  toggle.textContent = section.classList.contains('expanded') ? '‚ñ≤' : '‚ñº';
};

// ============================================
// PERSISTENCE - LOCAL STORAGE
// ============================================
function saveGameStateLocal() {
  const saveData = {
    dayNum: todaysPuzzle.dayNum,
    currentRound: gameState.currentRound,
    score: gameState.score,
    roundResults: gameState.roundResults,
    gameOver: gameState.gameOver,
    currentStreak: gameState.currentStreak
  };
  localStorage.setItem('acesHigherLower', JSON.stringify(saveData));
  console.log('üíæ Game state saved to localStorage');
}

function loadGameStateLocal() {
  try {
    const saved = JSON.parse(localStorage.getItem('acesHigherLower'));
    
    if (saved && saved.dayNum === todaysPuzzle.dayNum) {
      applyLoadedGameState(saved);
      console.log('‚úÖ Game state restored from localStorage');
      return true;
    }
  } catch (e) {
    console.log('No local saved state:', e);
  }
  return false;
}

// ============================================
// PERSISTENCE - FIREBASE
// ============================================
async function saveGameStateFirebase() {
  if (!currentUser) return;
  
  try {
    const puzzleDocId = `puzzle_${todaysPuzzle.dayNum}`;
    const puzzleRef = doc(db, 'acesHigherLowerGames', currentUser.uid, 'puzzles', puzzleDocId);
    
    await setDoc(puzzleRef, {
      puzzleNum: todaysPuzzle.dayNum,
      category: todaysPuzzle.category.id,
      currentRound: gameState.currentRound,
      score: gameState.score,
      roundResults: gameState.roundResults,
      gameOver: gameState.gameOver,
      lastUpdated: serverTimestamp()
    }, { merge: true });
    
    console.log('‚òÅÔ∏è Game state saved to Firebase');
    
    if (gameState.gameOver) {
      await updateLifetimeStats();
    }
  } catch (error) {
    console.error('‚ùå Error saving to Firebase:', error);
  }
}

async function loadGameStateFirebase() {
  if (!currentUser) return false;
  
  try {
    const puzzleDocId = `puzzle_${todaysPuzzle.dayNum}`;
    const puzzleRef = doc(db, 'acesHigherLowerGames', currentUser.uid, 'puzzles', puzzleDocId);
    const puzzleDoc = await getDoc(puzzleRef);
    
    if (puzzleDoc.exists()) {
      const saved = puzzleDoc.data();
      applyLoadedGameState(saved);
      console.log('‚òÅÔ∏è Game state restored from Firebase');
      return true;
    }
  } catch (error) {
    console.error('‚ùå Error loading from Firebase:', error);
  }
  return false;
}

async function updateLifetimeStats() {
  if (!currentUser) return;
  
  try {
    const statsRef = doc(db, 'acesHigherLowerGames', currentUser.uid);
    const statsDoc = await getDoc(statsRef);
    
    const isPerfect = gameState.score === TOTAL_ROUNDS;
    
    let stats = statsDoc.exists() ? statsDoc.data() : {
      gamesPlayed: 0,
      perfectGames: 0,
      totalCorrect: 0,
      totalRounds: 0,
      currentStreak: 0,
      longestStreak: 0,
      lastPlayedPuzzle: 0
    };
    
    if (stats.lastPlayedPuzzle === todaysPuzzle.dayNum) {
      console.log('‚ÑπÔ∏è Stats already recorded for this puzzle');
      return;
    }
    
    const isConsecutive = stats.lastPlayedPuzzle === todaysPuzzle.dayNum - 1;
    const newStreak = isConsecutive ? stats.currentStreak + 1 : 1;
    
    const updatedStats = {
      gamesPlayed: stats.gamesPlayed + 1,
      perfectGames: stats.perfectGames + (isPerfect ? 1 : 0),
      totalCorrect: stats.totalCorrect + gameState.score,
      totalRounds: stats.totalRounds + TOTAL_ROUNDS,
      currentStreak: newStreak,
      longestStreak: Math.max(stats.longestStreak, newStreak),
      lastPlayedPuzzle: todaysPuzzle.dayNum,
      lastPlayedAt: serverTimestamp(),
      displayName: currentUser.displayName || 'Anonymous'
    };
    
    await setDoc(statsRef, updatedStats, { merge: true });
    userStats = updatedStats;
    updateUserStatsDisplay();
    
    console.log('üìä Lifetime stats updated:', updatedStats);
  } catch (error) {
    console.error('‚ùå Error updating lifetime stats:', error);
  }
}

async function loadLifetimeStats() {
  if (!currentUser) return null;
  
  try {
    const statsRef = doc(db, 'acesHigherLowerGames', currentUser.uid);
    const statsDoc = await getDoc(statsRef);
    
    if (statsDoc.exists()) {
      userStats = statsDoc.data();
      console.log('üìä Lifetime stats loaded:', userStats);
      return userStats;
    }
  } catch (error) {
    console.error('‚ùå Error loading lifetime stats:', error);
  }
  return null;
}

// ============================================
// UNIFIED SAVE/LOAD
// ============================================
function saveGameState() {
  saveGameStateLocal();
  if (currentUser) {
    saveGameStateFirebase();
  }
}

async function loadGameState() {
  if (currentUser) {
    const loaded = await loadGameStateFirebase();
    if (loaded) return true;
  }
  return loadGameStateLocal();
}

function applyLoadedGameState(saved) {
  gameState = {
    ...gameState,
    currentRound: saved.currentRound,
    score: saved.score,
    roundResults: saved.roundResults || [],
    gameOver: saved.gameOver,
    currentStreak: saved.currentStreak || 0
  };
  
  if (gameState.gameOver) {
    document.getElementById('resultsBtn').style.display = 'inline-block';
    document.getElementById('shareBtn').style.display = 'inline-block';
  }
}

// ============================================
// USER STATS DISPLAY
// ============================================
function updateUserStatsDisplay() {
  const container = document.getElementById('userStatsContainer');
  if (!container) return;
  
  if (!currentUser) {
    container.innerHTML = `
      <div class="user-stats-content">
        <div class="sign-in-prompt">
          <span>üîí</span>
          <a href="signin.html">Sign in</a> to track your stats across devices
        </div>
      </div>
    `;
    return;
  }
  
  if (!userStats) {
    container.innerHTML = `
      <div class="user-stats-content">
        <div class="user-greeting">üëã Welcome, ${currentUser.displayName || 'Player'}!</div>
        <div style="font-size: 0.85rem; color: var(--text-light);">Complete a puzzle to start tracking your stats.</div>
      </div>
    `;
    return;
  }
  
  const avgScore = userStats.gamesPlayed > 0 
    ? (userStats.totalCorrect / userStats.gamesPlayed).toFixed(1) 
    : '0';
  
  container.innerHTML = `
    <div class="user-stats-content">
      <div class="user-greeting">üëã ${currentUser.displayName || 'Player'}</div>
      <div class="lifetime-stats">
        <div class="lifetime-stat">
          <span class="lifetime-value">${userStats.gamesPlayed}</span>
          <span class="lifetime-label">Played</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${userStats.perfectGames}</span>
          <span class="lifetime-label">Perfect</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${avgScore}</span>
          <span class="lifetime-label">Avg Score</span>
        </div>
        <div class="lifetime-stat">
          <span class="lifetime-value">${userStats.currentStreak}</span>
          <span class="lifetime-label">Streak</span>
        </div>
      </div>
    </div>
  `;
}

// ============================================
// AUTH STATE HANDLING
// ============================================
function setupAuthListener() {
  onAuthChange(async (user) => {
    currentUser = user;
    console.log(user ? `‚úÖ User signed in: ${user.displayName}` : 'üë§ No user signed in');
    
    if (user && todaysPuzzle) {
      await loadLifetimeStats();
      const firebaseHasState = await loadGameStateFirebase();
      
      if (firebaseHasState) {
        // Re-render the game state (whether in progress or completed)
        renderRound();
        updateStats();
        if (gameState.gameOver) {
          updateProgressDots();
        }
      }
    }
    
    updateUserStatsDisplay();
  });
}

// ============================================
// INITIALIZATION
// ============================================
async function init() {
  try {
    const [launchYear, launchMonth, launchDay] = LAUNCH_DATE.split('-').map(Number);
    const launchDate = new Date(launchYear, launchMonth - 1, launchDay).setHours(0, 0, 0, 0);
    const now = new Date().setHours(0, 0, 0, 0);
    
    if (now < launchDate) {
      document.getElementById('loadingOverlay').classList.add('hidden');
      const displayDate = new Date(launchYear, launchMonth - 1, launchDay);
      document.getElementById('puzzleDate').textContent = `Launching ${displayDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}`;
      document.getElementById('gameContainer')?.remove();
      return;
    }
    
    currentUser = getCurrentUser();
    if (currentUser) {
      console.log(`‚úÖ User already signed in: ${currentUser.displayName}`);
    }
    
    console.log('Loading player data...');
    const rawPlayers = await getAllPlayerStatsOptimized();
    
    allPlayers = rawPlayers.filter(p => p.migrated !== true);
    console.log(`Loaded ${allPlayers.length} players`);
    
    todaysPuzzle = generateDailyPuzzle();
    console.log('Generated puzzle:', todaysPuzzle);
    
    const today = new Date();
    const puzzleNum = todaysPuzzle.dayNum;
    document.getElementById('puzzleDate').textContent = 
      `Puzzle #${puzzleNum} ‚Ä¢ ${today.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' })}`;
    
    if (currentUser) {
      await loadLifetimeStats();
    }
    
    await loadGameState();
    updateUserStatsDisplay();
    setupAuthListener();
    
    // Render current state
    if (gameState.gameOver) {
      // Show completed game
      renderRound();
      updateProgressDots();
    } else {
      renderRound();
    }
    
    // Click outside modal to close
    document.getElementById('gameOverModal').addEventListener('click', (e) => {
      if (e.target.id === 'gameOverModal') closeGameOverModal();
    });
    
    document.getElementById('loadingOverlay').classList.add('hidden');
    
  } catch (error) {
    console.error('Error initializing game:', error);
    document.getElementById('loadingOverlay').innerHTML = `
      <div style="text-align: center; padding: 2rem;">
        <p>Error loading game data</p>
        <p style="color: var(--text-light); font-size: 0.9rem;">${error.message}</p>
        <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.75rem 1.5rem; cursor: pointer;">Retry</button>
      </div>
    `;
  }
}

init();
</script>

<script type="module">
  import { NavigationComponent } from './nav-component.js';
</script>
<script src="team-colors.js"></script>
<script src="mobile-enhancements.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Submit Stats - Mountainside Aces</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
:root {
  --primary-color: #2d5016;
  --secondary-color: #1a6b4a;
  --accent-color: #ffd700;
  --card-bg: #ffffff;
  --text-dark: #2d3748;
  --text-light: #718096;
  --border-color: #e2e8f0;
  --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
  --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
  --success-color: #22c55e;
  --warning-color: #f59e0b;
  --danger-color: #ef4444;
  --info-color: #3b82f6;
}

* {
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  margin: 0;
  padding: 0;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  min-height: 100vh;
  color: var(--text-dark);
}

.header {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  color: white;
  text-align: center;
  padding: 2rem 1.5rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
}

.header::before {
  content: '';
  position: absolute;
  top: -100px;
  right: -100px;
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
  border-radius: 50%;
}

.header h1 {
  margin: 0;
  font-size: 2rem;
  font-weight: 800;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  position: relative;
  z-index: 1;
}

.header p {
  margin: 0.5rem 0 0 0;
  font-size: 1rem;
  opacity: 0.95;
  position: relative;
  z-index: 1;
}

.back-home-btn {
  position: absolute;
  top: 2rem;
  right: 2rem;
  background: rgba(255,255,255,0.2);
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  text-decoration: none;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  border: 2px solid rgba(255,255,255,0.3);
  z-index: 2;
}

.back-home-btn:hover {
  background: rgba(255,255,255,0.3);
  transform: translateX(-5px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 2rem 1.5rem;
}

/* Tab Navigation */
.tab-nav {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
  background: var(--card-bg);
  padding: 0.5rem;
  border-radius: 12px;
  box-shadow: var(--shadow-sm);
}

.tab-btn {
  flex: 1;
  min-width: 180px;
  padding: 1rem 1.5rem;
  border: none;
  background: transparent;
  color: var(--text-light);
  font-weight: 600;
  font-size: 0.95rem;
  cursor: pointer;
  border-radius: 8px;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.tab-btn:hover {
  background: #f1f5f9;
  color: var(--text-dark);
}

.tab-btn.active {
  background: var(--primary-color);
  color: white;
}

.tab-btn .icon {
  font-size: 1.2rem;
}

/* Tab Content */
.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

.controls-section {
  background: var(--card-bg);
  padding: 1.5rem;
  border-radius: 12px;
  margin-bottom: 2rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
}

.control-group {
  margin-bottom: 1.5rem;
}

.control-group:last-child {
  margin-bottom: 0;
}

.control-group label {
  display: block;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-dark);
  margin-bottom: 0.5rem;
}

.control-group select,
.control-group input {
  width: 100%;
  max-width: 400px;
  padding: 0.75rem 1rem;
  border: 2px solid var(--border-color);
  border-radius: 8px;
  font-size: 14px;
  background: white;
  transition: all 0.2s;
}

.control-group select:focus,
.control-group input:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(45, 80, 22, 0.1);
}

.info-box {
  background: #eff6ff;
  border: 2px solid #3b82f6;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.info-box svg {
  width: 24px;
  height: 24px;
  color: #3b82f6;
  flex-shrink: 0;
}

.warning-box {
  background: #fef3c7;
  border: 2px solid #f59e0b;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.warning-box svg {
  width: 24px;
  height: 24px;
  color: #f59e0b;
  flex-shrink: 0;
}

.error-box {
  background: #fee2e2;
  border: 2px solid #ef4444;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.error-box svg {
  width: 24px;
  height: 24px;
  color: #ef4444;
  flex-shrink: 0;
}

.success-box {
  background: #d1fae5;
  border: 2px solid #10b981;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.success-box svg {
  width: 24px;
  height: 24px;
  color: #10b981;
  flex-shrink: 0;
}

.edit-mode-banner {
  background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
  border: 2px solid #f59e0b;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1.5rem;
  display: none;
  align-items: center;
  gap: 0.75rem;
}

.edit-mode-banner svg {
  width: 24px;
  height: 24px;
  color: #d97706;
  flex-shrink: 0;
}

.edit-mode-banner .banner-content {
  flex: 1;
}

.edit-mode-banner .banner-title {
  font-weight: 700;
  color: #92400e;
  margin-bottom: 0.25rem;
}

.edit-mode-banner .banner-text {
  color: #b45309;
  font-size: 14px;
}

.stats-grid-container {
  background: var(--card-bg);
  border-radius: 12px;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  overflow: hidden;
  margin-bottom: 2rem;
}

.stats-grid-header {
  background: var(--primary-color);
  color: white;
  padding: 1rem 1.5rem;
  font-size: 1.25rem;
  font-weight: 700;
}

.table-scroll-container {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

.stats-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

.stats-table thead th {
  background: #f8fafc;
  color: var(--text-dark);
  font-weight: 600;
  padding: 12px 8px;
  text-align: center;
  border-bottom: 2px solid var(--border-color);
  position: sticky;
  top: 0;
  z-index: 10;
  white-space: nowrap;
}

.stats-table thead th.player-col {
  text-align: left;
  position: sticky;
  left: 0;
  z-index: 20;
  background: #f8fafc;
}

.stats-table tbody td {
  padding: 8px;
  border-bottom: 1px solid var(--border-color);
  text-align: center;
}

.stats-table tbody td.player-cell {
  position: sticky;
  left: 0;
  background: white;
  z-index: 5;
  text-align: left;
  font-weight: 500;
}

.stats-table tbody tr:hover td {
  background: #f8fafc;
}

.stats-table tbody tr:hover td.player-cell {
  background: #f1f5f9;
}

.stats-input {
  width: 70px;
  padding: 6px 8px;
  border: 2px solid var(--border-color);
  border-radius: 6px;
  text-align: center;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s;
}

.stats-input:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(45, 80, 22, 0.1);
}

.stats-input:disabled {
  background: #f1f5f9;
  cursor: not-allowed;
}

.checkbox-cell {
  padding: 8px;
}

.checkbox-cell input[type="checkbox"] {
  width: 20px;
  height: 20px;
  cursor: pointer;
  accent-color: var(--primary-color);
}

.action-buttons {
  display: flex;
  gap: 1rem;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 2rem;
}

.btn {
  padding: 0.875rem 2rem;
  border: none;
  border-radius: 8px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  text-decoration: none;
}

.btn-primary {
  background: var(--primary-color);
  color: white;
  box-shadow: 0 4px 6px rgba(45, 80, 22, 0.3);
}

.btn-primary:hover {
  background: #234010;
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(45, 80, 22, 0.4);
}

.btn-primary:disabled {
  background: #cbd5e0;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.btn-secondary {
  background: white;
  color: var(--text-dark);
  border: 2px solid var(--border-color);
}

.btn-secondary:hover {
  background: #f8fafc;
  border-color: var(--primary-color);
}

.btn-success {
  background: var(--success-color);
  color: white;
}

.btn-success:hover {
  background: #16a34a;
}

.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.95);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.loading-overlay.hidden {
  display: none;
}

.spinner {
  font-size: 48px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.page-header {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  padding: 4rem 2rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
  color: white;
  text-align: center;
}

.loading-text {
  margin-top: 1rem;
  font-size: 1.125rem;
  color: var(--text-dark);
  font-weight: 600;
}

/* CSV Upload Styles */
.upload-area {
  border: 3px dashed var(--border-color);
  border-radius: 12px;
  padding: 3rem 2rem;
  text-align: center;
  transition: all 0.3s ease;
  cursor: pointer;
  margin-top: 1rem;
}

.upload-area:hover,
.upload-area.dragover {
  border-color: var(--primary-color);
  background: rgba(45, 80, 22, 0.05);
}

.upload-area .icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.upload-area input[type="file"] {
  display: none;
}

.template-link {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  color: var(--primary-color);
  font-weight: 600;
  text-decoration: none;
  margin-top: 1rem;
  padding: 0.5rem 1rem;
  background: rgba(45, 80, 22, 0.1);
  border-radius: 8px;
  transition: all 0.2s;
}

.template-link:hover {
  background: rgba(45, 80, 22, 0.2);
}

.template-link.disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

/* CSV Preview Table */
.csv-preview-section {
  background: var(--card-bg);
  border-radius: 12px;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  overflow: hidden;
  margin-top: 1.5rem;
}

.csv-preview-header {
  background: var(--primary-color);
  color: white;
  padding: 1rem 1.5rem;
  font-size: 1.1rem;
  font-weight: 700;
}

.csv-preview-content {
  padding: 1.5rem;
}

.csv-preview {
  max-height: 400px;
  overflow: auto;
  border: 1px solid var(--border-color);
  border-radius: 8px;
}

.csv-preview table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}

.csv-preview th,
.csv-preview td {
  padding: 8px 12px;
  border-bottom: 1px solid var(--border-color);
  text-align: left;
  white-space: nowrap;
}

.csv-preview th {
  background: var(--primary-color);
  color: white;
  position: sticky;
  top: 0;
  font-weight: 600;
}

.csv-preview tr:nth-child(even) {
  background: #f8fafc;
}

.csv-preview .status-valid {
  color: var(--success-color);
}

.csv-preview .status-warning {
  color: var(--warning-color);
}

.csv-preview .status-error {
  color: var(--danger-color);
}

.stats-summary {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 1rem;
  padding: 1rem;
  background: #f8fafc;
  border-radius: 8px;
  margin-bottom: 1rem;
}

.stats-summary-item {
  text-align: center;
}

.stats-summary-item .value {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--primary-color);
}

.stats-summary-item .label {
  font-size: 0.75rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.hint {
  font-size: 0.85rem;
  color: var(--text-light);
  margin-top: 0.25rem;
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  bottom: 2rem;
  right: 2rem;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.toast {
  background: var(--card-bg);
  padding: 1rem 1.5rem;
  border-radius: 8px;
  box-shadow: var(--shadow-lg);
  display: flex;
  align-items: center;
  gap: 0.75rem;
  min-width: 280px;
  animation: slideIn 0.3s ease;
}

.toast-success { border-left: 4px solid var(--success-color); }
.toast-error { border-left: 4px solid var(--danger-color); }
.toast-warning { border-left: 4px solid var(--warning-color); }
.toast-info { border-left: 4px solid var(--info-color); }

@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@media (max-width: 768px) {
  .header h1 {
    font-size: 1.5rem;
  }

  .back-home-btn {
    position: static;
    margin-bottom: 1rem;
    justify-content: center;
  }

  .container {
    padding: 1rem;
  }

  .tab-btn {
    min-width: 140px;
    padding: 0.75rem 1rem;
    font-size: 0.85rem;
  }

  .stats-input {
    width: 60px;
    padding: 4px 6px;
    font-size: 13px;
  }

  .stats-table thead th,
  .stats-table tbody td {
    padding: 6px 4px;
    font-size: 12px;
  }

  .action-buttons {
    flex-direction: column;
  }

  .btn {
    width: 100%;
    justify-content: center;
  }

  .toast-container {
    left: 1rem;
    right: 1rem;
    bottom: 1rem;
  }

  .toast {
    min-width: auto;
  }
}
</style>
</head>
<body>

<div id="loadingOverlay" class="loading-overlay">
  <div class="spinner">üßÆ</div>
  <div class="loading-text">Loading stats submission...</div>
</div>

<div class="page-container">
<div class="header">
  <a href="profile.html" class="back-home-btn">
    <span>‚Üê</span> Back to Profile
  </a>
  <h1>Submit Stats</h1>
  <p>Enter game statistics for your team</p>
</div>

<div class="container">
  <div id="accessDenied" class="error-box" style="display: none;">
    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
    </svg>
    <div>
      <div style="font-weight: 600; color: #7f1d1d; margin-bottom: 0.25rem;">Access Denied</div>
      <div style="color: #991b1b;">You must be a Team Captain, Team Staff, League Staff, or Admin to submit stats.</div>
    </div>
  </div>

  <div id="mainContent" style="display: none;">
    <!-- Team Selection (Admin/League Staff only) -->
    <div id="teamSelectionSection" class="controls-section" style="display: none;">
      <div class="control-group">
        <label for="teamSelect">Select Team:</label>
        <select id="teamSelect">
          <option value="">-- Select a team --</option>
        </select>
      </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-nav">
      <button class="tab-btn active" onclick="switchTab('single')">
        <span class="icon">üìù</span> Game-by-Game
      </button>
      <button class="tab-btn" onclick="switchTab('bulk')">
        <span class="icon">üì§</span> CSV Bulk Upload
      </button>
    </div>

    <!-- Messages (shared) -->
    <div id="infoMessage" class="info-box" style="display: none;">
      <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      <div id="infoMessageText"></div>
    </div>

    <div id="warningMessage" class="warning-box" style="display: none;">
      <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
      </svg>
      <div id="warningMessageText"></div>
    </div>

    <div id="errorMessage" class="error-box" style="display: none;">
      <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      <div id="errorMessageText"></div>
    </div>

    <div id="successMessage" class="success-box" style="display: none;">
      <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      <div id="successMessageText"></div>
    </div>

    <!-- SINGLE GAME TAB -->
    <div id="singleTab" class="tab-content active">
      <!-- Game Selection -->
      <div class="controls-section">
        <div class="control-group">
          <label for="gameSelect">Select Game:</label>
          <select id="gameSelect" required>
            <option value="">-- Select a game --</option>
          </select>
        </div>
        <div id="gameDetails" style="display: none; padding: 1rem; background: #f8fafc; border-radius: 8px; margin-top: 1rem;">
          <div style="display: grid; grid-template-columns: auto 1fr; gap: 0.5rem 1rem; font-size: 14px;">
            <strong>Date:</strong> <span id="selectedGameDate"></span>
            <strong>Opponent:</strong> <span id="selectedGameOpponent"></span>
            <strong>Location:</strong> <span id="selectedGameLocation"></span>
          </div>
        </div>
      </div>

      <div id="editModeBanner" class="edit-mode-banner">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
        </svg>
        <div class="banner-content">
          <div class="banner-title">üìù EDIT MODE</div>
          <div class="banner-text" id="editModeBannerText">Existing stats have been loaded. You can edit and resubmit.</div>
        </div>
      </div>

      <!-- Stats Grid -->
      <div id="statsGridContainer" class="stats-grid-container" style="display: none;">
        <div class="stats-grid-header">Team Roster - Enter Statistics</div>
        <div class="table-scroll-container">
          <table class="stats-table" id="statsTable">
            <thead>
              <tr>
                <th class="player-col">Player</th>
                <th>Played</th>
                <th>At Bats</th>
                <th>Hits</th>
                <th>Runs</th>
                <th>Walks</th>
                <th>IP</th>
                <th>Runs Allowed</th>
              </tr>
            </thead>
            <tbody id="statsTableBody">
              <!-- Rows will be populated by JavaScript -->
            </tbody>
          </table>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="action-buttons" id="actionButtons" style="display: none;">
        <button class="btn btn-secondary" id="clearBtn">
          <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
          </svg>
          Clear All Stats
        </button>
        <button class="btn btn-primary" id="submitBtn">
          <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>
          Submit Stats
        </button>
      </div>
    </div>

    <!-- BULK UPLOAD TAB -->
    <div id="bulkTab" class="tab-content">
      <div class="controls-section">
        <h3 style="margin-top: 0; margin-bottom: 1rem;">üì§ CSV Bulk Upload</h3>
        <p style="color: var(--text-light); margin-bottom: 1rem;">
          Upload a CSV file with stats for multiple games at once. Download the template below to get started with your roster pre-filled.
        </p>

        <a href="#" class="template-link" id="downloadTemplateBtn" onclick="downloadRosterTemplate(); return false;">
          <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
          </svg>
          Download Template with Your Roster
        </a>

        <div class="upload-area" id="uploadArea" onclick="document.getElementById('csvFileInput').click()">
          <input type="file" id="csvFileInput" accept=".csv" onchange="handleCSVUpload(event)">
          <div class="icon">üìÅ</div>
          <div><strong>Click to upload</strong> or drag and drop</div>
          <div style="color: var(--text-light); margin-top: 0.5rem;">CSV file with player stats</div>
        </div>

        <div style="margin-top: 1.5rem;">
          <label style="font-weight: 600; display: block; margin-bottom: 0.5rem;">Expected CSV Format:</label>
          <div class="hint">
            <code style="background: #f1f5f9; padding: 0.75rem; border-radius: 4px; display: block; overflow-x: auto; white-space: pre; font-size: 12px;">Player,GameDate,Opponent,IsHome,AB,H,R,BB,IP,RA
John Smith,2025-09-15,Blue,true,4,2,1,0,0,0
Jane Doe,2025-09-15,Blue,true,3,1,0,1,2,1</code>
          </div>
        </div>
      </div>

      <!-- CSV Preview -->
      <div id="csvPreviewSection" class="csv-preview-section" style="display: none;">
        <div class="csv-preview-header">
          üëÅÔ∏è Preview Upload (<span id="csvRowCount">0</span> rows)
        </div>
        <div class="csv-preview-content">
          <div id="csvValidationSummary" class="stats-summary" style="display: none;">
            <div class="stats-summary-item">
              <div class="value" id="validRowCount">0</div>
              <div class="label">Valid</div>
            </div>
            <div class="stats-summary-item">
              <div class="value" id="warningRowCount">0</div>
              <div class="label">Warnings</div>
            </div>
            <div class="stats-summary-item">
              <div class="value" id="errorRowCount">0</div>
              <div class="label">Errors</div>
            </div>
            <div class="stats-summary-item">
              <div class="value" id="uniqueGamesCount">0</div>
              <div class="label">Games</div>
            </div>
          </div>

          <div class="csv-preview" id="csvPreviewTable">
            <!-- Populated by JavaScript -->
          </div>

          <div class="action-buttons">
            <button type="button" class="btn btn-success" id="bulkSubmitBtn" onclick="submitBulkStats()">
              <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
              Upload All Stats
            </button>
            <button type="button" class="btn btn-secondary" onclick="clearBulkUpload()">
              <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
              </svg>
              Clear Upload
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="toastContainer" class="toast-container"></div>

<script type="module">
import { onAuthChange, getCurrentUser, getUserProfile } from './firebase-auth.js';
import { getCurrentSeason, getAllTeams, getSeasonPlayerStatsOptimized } from './firebase-data.js';
import { db, collection, doc, getDoc, query, where } from './firebase-config.js';
import { 
  updateDoc, 
  setDoc,
  increment,
  serverTimestamp,
  getDocs
} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
import './nav-component.js';

let currentUser = null;
let userProfile = null;
let currentSeason = null;
let selectedTeam = null;
let rosterPlayers = [];
let teamGames = [];
let isAdmin = false;
let isLeagueStaff = false;
let csvData = [];
let csvValidation = [];

// ============================================
// TAB SWITCHING
// ============================================
window.switchTab = function(tab) {
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
  
  if (tab === 'single') {
    document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
    document.getElementById('singleTab').classList.add('active');
  } else {
    document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
    document.getElementById('bulkTab').classList.add('active');
  }
};

// ============================================
// ORIGINAL FUNCTIONS (Game-by-Game)
// ============================================

// Load all games for a team (including past games)
async function getAllTeamGames(teamId, seasonId) {
  try {
    const gamesRef = collection(db, 'seasons', seasonId, 'games');
    
    console.log(`üîç Loading ALL games for team: "${teamId}" in season: ${seasonId}`);
    
    const allGamesSnap = await getDocs(gamesRef);
    
    const games = [];
    const teamIdLower = teamId.toLowerCase();
    
    allGamesSnap.forEach(doc => {
      const data = doc.data();
      
      let gameDate = null;
      if (data.date?.seconds) {
        gameDate = new Date(data.date.seconds * 1000);
      } else if (data.date && typeof data.date === 'string' && data.date.trim() !== '') {
        gameDate = new Date(data.date);
        if (isNaN(gameDate.getTime())) {
          gameDate = null;
        }
      }

      const isPlayoffGame = 
        data.game_type === 'Playoff' || 
        data.gameType === 'playoff' || 
        data.gameType === 'Playoff';

      const homeTeam = data.homeTeamName || data['home team'] || data.homeTeam || 'TBD';
      const awayTeam = data.awayTeamName || data['away team'] || data.awayTeam || 'TBD';
      
      const homeTeamMatch = homeTeam.toLowerCase() === teamIdLower;
      const awayTeamMatch = awayTeam.toLowerCase() === teamIdLower;
      
      if (!homeTeamMatch && !awayTeamMatch) {
        return;
      }
      
      let opponent = 'Unknown Opponent';
      let isHome = false;
      
      if (homeTeamMatch) {
        opponent = awayTeam;
        isHome = true;
      } else {
        opponent = homeTeam;
        isHome = false;
      }
      
      games.push({
        id: doc.id,
        ...data,
        dateObj: gameDate || new Date(0),
        date: data.date,
        isHome: isHome,
        opponent: opponent,
        isPlayoff: isPlayoffGame,
        gameType: data.game_type || data.gameType || 'Regular',
        round: data.round || null
      });
    });
    
    games.sort((a, b) => {
      const timeA = a.dateObj.getTime();
      const timeB = b.dateObj.getTime();
      return timeB - timeA;
    });
    
    const playoffCount = games.filter(g => g.isPlayoff).length;
    const regularCount = games.length - playoffCount;
    
    console.log(`‚úÖ Loaded ${games.length} total games for ${teamId} (${regularCount} regular season, ${playoffCount} playoff)`);
    return games;
  } catch (error) {
    console.error('‚ùå Error loading team games:', error);
    return [];
  }
}

function showMessage(type, text) {
  document.getElementById('infoMessage').style.display = 'none';
  document.getElementById('warningMessage').style.display = 'none';
  document.getElementById('errorMessage').style.display = 'none';
  document.getElementById('successMessage').style.display = 'none';

  const messageMap = {
    'info': { box: 'infoMessage', text: 'infoMessageText' },
    'warning': { box: 'warningMessage', text: 'warningMessageText' },
    'error': { box: 'errorMessage', text: 'errorMessageText' },
    'success': { box: 'successMessage', text: 'successMessageText' }
  };

  if (messageMap[type]) {
    document.getElementById(messageMap[type].text).textContent = text;
    document.getElementById(messageMap[type].box).style.display = 'flex';
  }
}

function showToast(message, type = 'success') {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  
  const icon = type === 'success' ? '‚úì' : type === 'error' ? '‚úï' : '‚ö†';
  toast.innerHTML = `<span>${icon}</span> ${message}`;
  
  container.appendChild(toast);
  
  setTimeout(() => {
    toast.style.opacity = '0';
    setTimeout(() => toast.remove(), 300);
  }, 4000);
}

function hasStatsSubmissionAccess(profile) {
  if (profile.isCaptain) {
    return { hasAccess: true, role: 'captain', teamId: profile.linkedTeam };
  }

  if (profile.role === 'admin') {
    return { hasAccess: true, role: 'admin', teamId: null };
  }

  if (profile.role === 'league-staff' || profile.role === 'staff') {
    return { hasAccess: true, role: 'league-staff', teamId: null };
  }

  if (profile.role === 'team-staff' && profile.linkedTeam) {
    return { hasAccess: true, role: 'team-staff', teamId: profile.linkedTeam };
  }

  return { hasAccess: false };
}

async function loadTeamRoster(teamId) {
  try {
    console.log('üîç Loading roster for team:', teamId);

    const seasonPlayers = await getSeasonPlayerStatsOptimized(currentSeason.id);
    
    // Case-insensitive matching
    const teamIdLower = teamId.toLowerCase();
    const filteredPlayers = seasonPlayers.filter(p => {
      return (p.team || '').toLowerCase() === teamIdLower && !p.migrated;
    });

    const players = filteredPlayers.map(player => {
      const name = player.name || player.playerName;
      
      let legacyId;
      if (player.isAuthUser && player.linkedPlayer) {
        legacyId = player.linkedPlayer.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_');
      } else {
        legacyId = player.playerId;
      }
      
      return {
        id: player.playerId,
        legacyId: legacyId,
        name: name,
        displayName: name,
        linkedPlayer: player.linkedPlayer || null,
        isAuthUser: player.isAuthUser || false
      };
    });

    players.sort((a, b) => a.name.localeCompare(b.name));

    console.log(`‚úÖ Loaded ${players.length} players for team ${teamId}`);
    
    teamGames = await getAllTeamGames(teamId, currentSeason.id);
    populateGameDropdown();
    
    return players;
  } catch (error) {
    console.error('‚ùå Error loading team roster:', error);
    throw error;
  }
}

function populateGameDropdown() {
  const gameSelect = document.getElementById('gameSelect');
  
  gameSelect.innerHTML = '<option value="">-- Select a game --</option>';
  
  if (teamGames.length === 0) {
    const option = document.createElement('option');
    option.value = '';
    option.textContent = 'No games found for this team';
    option.disabled = true;
    gameSelect.appendChild(option);
    return;
  }
  
  teamGames.forEach(game => {
    const option = document.createElement('option');
    option.value = game.id;
    
    let dateStr = 'Unknown Date';
    if (game.dateObj && game.dateObj.getTime() !== 0) {
      dateStr = game.dateObj.toLocaleDateString('en-US', { 
        weekday: 'short', 
        month: 'short', 
        day: 'numeric' 
      });
    } else if (game.dateObj && game.dateObj.getTime() === 0) {
      dateStr = 'TBD';
    }
    
    const location = game.isHome ? 'vs' : '@';
    const playoffIndicator = game.isPlayoff ? 'üèÜ ' : '';
    const roundInfo = game.round ? ` (${game.round})` : '';
    
    option.textContent = `${playoffIndicator}${dateStr} ${location} ${game.opponent}${roundInfo}`;
    option.dataset.gameData = JSON.stringify(game);
    
    gameSelect.appendChild(option);
  });
  
  console.log(`‚úÖ Populated ${teamGames.length} games in dropdown`);
}

function renderStatsTable(players) {
  const tbody = document.getElementById('statsTableBody');
  tbody.innerHTML = '';

  if (players.length === 0) {
    tbody.innerHTML = `
      <tr>
        <td colspan="8" style="text-align: center; padding: 2rem; color: #718096;">
          No players found for this team. Players need to be linked to the team in their user profile.
        </td>
      </tr>
    `;
    document.getElementById('statsGridContainer').style.display = 'block';
    document.getElementById('actionButtons').style.display = 'flex';
    return;
  }

  players.forEach((player, index) => {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td class="player-cell">${player.name}</td>
      <td class="checkbox-cell">
        <input type="checkbox" id="played_${index}" data-player-id="${player.id}" checked>
      </td>
      <td>
        <input type="number" class="stats-input" id="ab_${index}" data-player-id="${player.id}" 
               data-stat="atBats" min="0" value="0">
      </td>
      <td>
        <input type="number" class="stats-input" id="hits_${index}" data-player-id="${player.id}" 
               data-stat="hits" min="0" value="0">
      </td>
      <td>
        <input type="number" class="stats-input" id="runs_${index}" data-player-id="${player.id}" 
               data-stat="runs" min="0" value="0">
      </td>
      <td>
        <input type="number" class="stats-input" id="walks_${index}" data-player-id="${player.id}" 
               data-stat="walks" min="0" value="0">
      </td>
      <td>
        <input type="number" class="stats-input" id="ip_${index}" data-player-id="${player.id}" 
               data-stat="inningsPitched" min="0" step="0.1" value="0">
      </td>
      <td>
        <input type="number" class="stats-input" id="ra_${index}" data-player-id="${player.id}" 
               data-stat="runsAllowed" min="0" value="0">
      </td>
    `;
    tbody.appendChild(row);

    const playedCheckbox = document.getElementById(`played_${index}`);
    const inputs = [
      document.getElementById(`ab_${index}`),
      document.getElementById(`hits_${index}`),
      document.getElementById(`runs_${index}`),
      document.getElementById(`walks_${index}`),
      document.getElementById(`ip_${index}`),
      document.getElementById(`ra_${index}`)
    ];

    playedCheckbox.addEventListener('change', () => {
      const isChecked = playedCheckbox.checked;
      inputs.forEach(input => {
        input.disabled = !isChecked;
        if (!isChecked) {
          input.value = '0';
        }
      });
    });
  });

  document.getElementById('statsGridContainer').style.display = 'block';
  document.getElementById('actionButtons').style.display = 'flex';
}

async function loadExistingStatsForGame(gameId) {
  try {
    const seasonId = currentSeason.id;
    const gameDocId = `${seasonId}_${gameId}`;
    
    console.log('üîç Loading existing stats for game:', gameId);
    showMessage('info', 'Loading existing stats for this game...');
    
    const existingStats = {};
    
    for (const player of rosterPlayers) {
      const legacyId = player.legacyId;
      const playerId = player.id;
      
      try {
        const battingRef = doc(db, 'playerStats', legacyId, 'games', gameDocId);
        const battingDoc = await getDoc(battingRef);
        
        if (battingDoc.exists()) {
          const battingData = battingDoc.data();
          existingStats[playerId] = {
            atBats: battingData.atBats || 0,
            hits: battingData.hits || 0,
            runs: battingData.runs || 0,
            walks: battingData.walks || 0,
            inningsPitched: 0,
            runsAllowed: 0,
            hasBattingStats: true
          };
        }
      } catch (error) {}
      
      try {
        const pitchingRef = doc(db, 'pitchingStats', legacyId, 'games', gameDocId);
        const pitchingDoc = await getDoc(pitchingRef);
        
        if (pitchingDoc.exists()) {
          const pitchingData = pitchingDoc.data();
          if (!existingStats[playerId]) {
            existingStats[playerId] = {
              atBats: 0, hits: 0, runs: 0, walks: 0,
              inningsPitched: 0, runsAllowed: 0
            };
          }
          existingStats[playerId].inningsPitched = pitchingData.inningsPitched || 0;
          existingStats[playerId].runsAllowed = pitchingData.runsAllowed || 0;
        }
      } catch (error) {}
    }
    
    rosterPlayers.forEach((player, index) => {
      const playerId = player.id;
      const stats = existingStats[playerId];
      
      const playedCheckbox = document.getElementById(`played_${index}`);
      const inputs = [
        document.getElementById(`ab_${index}`),
        document.getElementById(`hits_${index}`),
        document.getElementById(`runs_${index}`),
        document.getElementById(`walks_${index}`),
        document.getElementById(`ip_${index}`),
        document.getElementById(`ra_${index}`)
      ];
      
      if (stats) {
        inputs[0].value = stats.atBats;
        inputs[1].value = stats.hits;
        inputs[2].value = stats.runs;
        inputs[3].value = stats.walks;
        inputs[4].value = stats.inningsPitched;
        inputs[5].value = stats.runsAllowed;
        playedCheckbox.checked = true;
        inputs.forEach(input => input.disabled = false);
      } else {
        inputs.forEach(input => { input.value = '0'; input.disabled = false; });
        playedCheckbox.checked = true;
      }
    });
    
    const statsCount = Object.keys(existingStats).length;
    if (statsCount > 0) {
      document.getElementById('editModeBanner').style.display = 'flex';
      document.getElementById('editModeBannerText').textContent = 
        `Loaded existing stats for ${statsCount} player(s). Edit any values and click Submit to update.`;
      showMessage('info', `‚úÖ Edit mode: Stats loaded for ${statsCount} player(s).`);
    } else {
      document.getElementById('editModeBanner').style.display = 'none';
      showMessage('info', 'No existing stats found. Enter new stats for this game.');
    }
    
  } catch (error) {
    console.error('‚ùå Error loading existing stats:', error);
    showMessage('error', 'Failed to load existing stats. You can still enter new stats.');
  }
}

async function submitStats() {
  const selectedGameId = document.getElementById('gameSelect').value;
  
  if (!selectedGameId) {
    showMessage('error', 'Please select a game before submitting.');
    return;
  }

  const submitBtn = document.getElementById('submitBtn');
  const originalBtnText = submitBtn.innerHTML;
  submitBtn.disabled = true;
  submitBtn.innerHTML = `<span class="spinner">‚è≥</span> Submitting...`;

  try {
    const seasonId = currentSeason.id;
    const gameOption = document.querySelector(`#gameSelect option[value="${selectedGameId}"]`);
    const gameData = JSON.parse(gameOption.dataset.gameData);
    
    // Reconstruct dateObj
    if (gameData.dateObj) {
      gameData.dateObj = new Date(gameData.dateObj);
    }

    let gameDateFormatted = 'Unknown';
    if (gameData?.dateObj && !isNaN(gameData.dateObj.getTime()) && gameData.dateObj.getTime() !== 0) {
      gameDateFormatted = gameData.dateObj.toISOString().split('T')[0];
    }

    let successCount = 0;
    let errorCount = 0;

    for (let i = 0; i < rosterPlayers.length; i++) {
      const player = rosterPlayers[i];
      const isPlayed = document.getElementById(`played_${i}`).checked;
      
      if (!isPlayed) continue;

      const playerStats = {
        playerName: player.name,
        legacyId: player.legacyId,
        atBats: parseInt(document.getElementById(`ab_${i}`).value) || 0,
        hits: parseInt(document.getElementById(`hits_${i}`).value) || 0,
        runs: parseInt(document.getElementById(`runs_${i}`).value) || 0,
        walks: parseInt(document.getElementById(`walks_${i}`).value) || 0,
        inningsPitched: parseFloat(document.getElementById(`ip_${i}`).value) || 0,
        runsAllowed: parseInt(document.getElementById(`ra_${i}`).value) || 0
      };

      const hasStats = playerStats.atBats > 0 || playerStats.hits > 0 || 
                       playerStats.runs > 0 || playerStats.walks > 0 ||
                       playerStats.inningsPitched > 0 || playerStats.runsAllowed > 0;

      if (!hasStats) continue;

      const legacyId = playerStats.legacyId;

      try {
        const gameDocId = `${seasonId}_${selectedGameId}`;

        if (playerStats.atBats > 0 || playerStats.hits > 0 || playerStats.runs > 0 || playerStats.walks > 0) {
          const gameBattingRef = doc(db, 'playerStats', legacyId, 'games', gameDocId);
          
          await setDoc(gameBattingRef, {
            gameId: selectedGameId,
            gameDocId: gameDocId,
            playerId: legacyId,
            playerName: playerStats.playerName,
            seasonId: seasonId,
            teamId: selectedTeam,
            gameDate: gameData.date || null,
            gameDateFormatted: gameDateFormatted,
            opponent: gameData.opponent || 'Unknown',
            isHome: gameData.isHome || false,
            gameType: gameData.gameType || 'Regular',
            isPlayoff: gameData.isPlayoff || false,
            atBats: playerStats.atBats,
            hits: playerStats.hits,
            runs: playerStats.runs,
            walks: playerStats.walks,
            doubles: 0, triples: 0, homeRuns: 0, rbi: 0,
            strikeouts: 0, stolenBases: 0, caughtStealing: 0,
            submittedBy: currentUser.uid,
            submittedByName: currentUser.displayName || currentUser.email,
            submittedAt: serverTimestamp(),
            lastModified: serverTimestamp(),
            dataVersion: 1
          }, { merge: true });
        }

        if (playerStats.inningsPitched > 0 || playerStats.runsAllowed > 0) {
          const gamePitchingRef = doc(db, 'pitchingStats', legacyId, 'games', gameDocId);
          
          await setDoc(gamePitchingRef, {
            gameId: selectedGameId,
            gameDocId: gameDocId,
            playerId: legacyId,
            playerName: playerStats.playerName,
            seasonId: seasonId,
            teamId: selectedTeam,
            gameDate: gameData.date || null,
            gameDateFormatted: gameDateFormatted,
            opponent: gameData.opponent || 'Unknown',
            isHome: gameData.isHome || false,
            gameType: gameData.gameType || 'Regular',
            isPlayoff: gameData.isPlayoff || false,
            inningsPitched: playerStats.inningsPitched,
            runsAllowed: playerStats.runsAllowed,
            earnedRuns: 0, strikeouts: 0, walks: 0, hits: 0,
            wins: 0, losses: 0, saves: 0,
            submittedBy: currentUser.uid,
            submittedByName: currentUser.displayName || currentUser.email,
            submittedAt: serverTimestamp(),
            lastModified: serverTimestamp(),
            dataVersion: 1
          }, { merge: true });
        }

        successCount++;
      } catch (error) {
        console.error(`‚ùå Error saving stats for ${playerStats.playerName}:`, error);
        errorCount++;
      }
    }

    if (errorCount === 0) {
      showMessage('success', `Successfully submitted stats for ${successCount} player(s)!`);
      showToast(`Stats saved for ${successCount} players`, 'success');
      
      // Mark the game as having stats submitted
      try {
        const gameRef = doc(db, 'seasons', seasonId, 'games', selectedGameId);
        await updateDoc(gameRef, {
          statsSubmitted: true,
          statsSubmittedBy: currentUser.uid,
          statsSubmittedByName: currentUser.displayName || currentUser.email,
          statsSubmittedAt: serverTimestamp(),
          statsSubmittedForTeam: selectedTeam
        });
        console.log(`‚úÖ Marked game ${selectedGameId} as having stats submitted`);
      } catch (gameUpdateError) {
        console.warn('‚ö†Ô∏è Could not update game document with statsSubmitted flag:', gameUpdateError);
        // Don't fail the whole operation if this update fails
      }
      
      setTimeout(() => clearAllStats(), 3000);
    } else {
      showMessage('warning', `Submitted ${successCount} player(s), but ${errorCount} failed.`);
    }

    submitBtn.disabled = false;
    submitBtn.innerHTML = originalBtnText;

  } catch (error) {
    console.error('‚ùå Error submitting stats:', error);
    showMessage('error', `Error submitting stats: ${error.message}`);
    
    submitBtn.disabled = false;
    submitBtn.innerHTML = originalBtnText;
  }
}

function clearAllStats() {
  const inputs = document.querySelectorAll('.stats-input');
  inputs.forEach(input => input.value = '0');
  
  const checkboxes = document.querySelectorAll('input[type="checkbox"][id^="played_"]');
  checkboxes.forEach(checkbox => checkbox.checked = true);
  
  document.getElementById('gameSelect').value = '';
  document.getElementById('gameDetails').style.display = 'none';
  document.getElementById('editModeBanner').style.display = 'none';
  
  showMessage('info', 'All stats cleared.');
}

// ============================================
// CSV BULK UPLOAD FUNCTIONS
// ============================================

window.downloadRosterTemplate = function() {
  if (rosterPlayers.length === 0) {
    showMessage('warning', 'No roster loaded yet. Please wait for the roster to load or select a team first.');
    return;
  }

  // Build CSV with player names pre-filled
  let csv = 'Player,GameDate,Opponent,IsHome,AB,H,R,BB,IP,RA\n';
  
  // Add a row for each player with sample data
  const sampleDate = new Date().toISOString().split('T')[0]; // Today's date
  
  rosterPlayers.forEach(player => {
    // Pre-fill player name, leave other fields as placeholders
    csv += `${player.name},${sampleDate},OPPONENT,true,0,0,0,0,0,0\n`;
  });

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `stats_template_${selectedTeam || 'team'}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  showToast('Template downloaded with your roster!', 'success');
};

window.handleCSVUpload = function(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    parseCSV(e.target.result);
  };
  reader.readAsText(file);
};

function parseCSV(content) {
  const lines = content.trim().split('\n');
  if (lines.length < 2) {
    showMessage('error', 'CSV file must have a header row and at least one data row.');
    return;
  }
  
  const header = lines[0].split(',').map(h => h.trim().toLowerCase());
  
  const requiredColumns = ['player', 'gamedate', 'opponent'];
  const missingColumns = requiredColumns.filter(col => !header.includes(col));
  
  if (missingColumns.length > 0) {
    showMessage('error', `Missing required columns: ${missingColumns.join(', ')}`);
    return;
  }
  
  csvData = [];
  csvValidation = [];
  
  // Build a lookup map of roster names for validation
  const rosterNameMap = {};
  rosterPlayers.forEach(p => {
    rosterNameMap[p.name.toLowerCase()] = p;
  });
  
  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i]);
    if (values.length === 0 || values.every(v => !v.trim())) continue;
    
    const row = {};
    header.forEach((col, idx) => {
      row[col] = values[idx]?.trim() || '';
    });
    
    const validation = validateCSVRow(row, i, rosterNameMap);
    
    csvData.push(row);
    csvValidation.push(validation);
  }
  
  renderCSVPreview();
  document.getElementById('csvPreviewSection').style.display = 'block';
}

function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }
  result.push(current);
  
  return result;
}

function validateCSVRow(row, rowIndex, rosterNameMap) {
  const errors = [];
  const warnings = [];
  let matchedPlayer = null;
  
  if (!row.player) errors.push('Missing player name');
  if (!row.gamedate) errors.push('Missing game date');
  if (!row.opponent) errors.push('Missing opponent');
  
  if (row.gamedate) {
    const date = new Date(row.gamedate);
    if (isNaN(date.getTime())) {
      errors.push('Invalid date format');
    }
  }
  
  // Validate player exists in roster
  if (row.player) {
    const playerLower = row.player.toLowerCase();
    if (rosterNameMap[playerLower]) {
      matchedPlayer = rosterNameMap[playerLower];
    } else {
      // Try fuzzy match
      const rosterNames = Object.keys(rosterNameMap);
      const fuzzyMatch = rosterNames.find(name => 
        name.includes(playerLower) || playerLower.includes(name)
      );
      if (fuzzyMatch) {
        matchedPlayer = rosterNameMap[fuzzyMatch];
        warnings.push(`Matched to "${matchedPlayer.name}"`);
      } else {
        warnings.push('Player not found in roster');
      }
    }
  }
  
  // Validate numeric fields
  const numericFields = ['ab', 'h', 'r', 'bb', 'ip', 'ra'];
  numericFields.forEach(field => {
    if (row[field] && isNaN(parseFloat(row[field]))) {
      warnings.push(`Invalid ${field.toUpperCase()} value`);
    }
  });
  
  return {
    row: rowIndex,
    valid: errors.length === 0,
    errors: errors,
    warnings: warnings,
    matchedPlayer: matchedPlayer
  };
}

function renderCSVPreview() {
  const previewEl = document.getElementById('csvPreviewTable');
  const validCount = csvValidation.filter(v => v.valid && v.warnings.length === 0).length;
  const warningCount = csvValidation.filter(v => v.valid && v.warnings.length > 0).length;
  const errorCount = csvValidation.filter(v => !v.valid).length;
  
  const uniqueGames = new Set();
  csvData.forEach(row => {
    uniqueGames.add(`${row.gamedate}_${row.opponent}`);
  });
  
  document.getElementById('csvRowCount').textContent = csvData.length;
  document.getElementById('validRowCount').textContent = validCount;
  document.getElementById('warningRowCount').textContent = warningCount;
  document.getElementById('errorRowCount').textContent = errorCount;
  document.getElementById('uniqueGamesCount').textContent = uniqueGames.size;
  document.getElementById('csvValidationSummary').style.display = 'grid';
  
  if (csvData.length === 0) {
    previewEl.innerHTML = '<p style="padding: 1rem; color: var(--text-light);">No data to preview</p>';
    return;
  }
  
  let html = '<table><thead><tr>';
  html += '<th>Status</th>';
  html += '<th>Player</th>';
  html += '<th>Date</th>';
  html += '<th>Opponent</th>';
  html += '<th>Home</th>';
  html += '<th>AB</th>';
  html += '<th>H</th>';
  html += '<th>R</th>';
  html += '<th>BB</th>';
  html += '<th>IP</th>';
  html += '<th>RA</th>';
  html += '</tr></thead><tbody>';
  
  csvData.forEach((row, idx) => {
    const validation = csvValidation[idx];
    let statusClass = 'status-valid';
    let statusIcon = '‚úì';
    
    if (!validation.valid) {
      statusClass = 'status-error';
      statusIcon = '‚úï';
    } else if (validation.warnings.length > 0) {
      statusClass = 'status-warning';
      statusIcon = '‚ö†';
    }
    
    const errorText = [...validation.errors, ...validation.warnings].join(', ');
    
    html += `<tr>`;
    html += `<td class="${statusClass}" title="${errorText}">${statusIcon}</td>`;
    html += `<td>${row.player || '-'}</td>`;
    html += `<td>${row.gamedate || '-'}</td>`;
    html += `<td>${row.opponent || '-'}</td>`;
    html += `<td>${row.ishome || '-'}</td>`;
    html += `<td>${row.ab || '0'}</td>`;
    html += `<td>${row.h || '0'}</td>`;
    html += `<td>${row.r || '0'}</td>`;
    html += `<td>${row.bb || '0'}</td>`;
    html += `<td>${row.ip || '0'}</td>`;
    html += `<td>${row.ra || '0'}</td>`;
    html += `</tr>`;
  });
  
  html += '</tbody></table>';
  previewEl.innerHTML = html;
}

window.submitBulkStats = async function() {
  if (!selectedTeam) {
    showMessage('error', 'No team selected.');
    return;
  }
  
  if (csvData.length === 0) {
    showMessage('error', 'No CSV data to upload. Please upload a file first.');
    return;
  }
  
  const errorRows = csvValidation.filter(v => !v.valid);
  if (errorRows.length > 0) {
    showMessage('error', `Cannot upload: ${errorRows.length} row(s) have errors. Please fix and re-upload.`);
    return;
  }
  
  const bulkSubmitBtn = document.getElementById('bulkSubmitBtn');
  const originalBtnText = bulkSubmitBtn.innerHTML;
  bulkSubmitBtn.disabled = true;
  bulkSubmitBtn.innerHTML = '<span class="spinner">‚è≥</span> Uploading...';
  
  try {
    const seasonId = currentSeason.id;
    let successCount = 0;
    let errorCount = 0;
    
    // Group by game
    const gameGroups = {};
    csvData.forEach((row, idx) => {
      const gameKey = `${row.gamedate}_${row.opponent}`;
      if (!gameGroups[gameKey]) {
        gameGroups[gameKey] = {
          date: row.gamedate,
          opponent: row.opponent,
          isHome: row.ishome?.toLowerCase() === 'true',
          rows: []
        };
      }
      gameGroups[gameKey].rows.push({ row, validation: csvValidation[idx] });
    });
    
    for (const gameKey of Object.keys(gameGroups)) {
      const game = gameGroups[gameKey];
      
      const gameDate = new Date(game.date);
      const dateStr = `${gameDate.getMonth() + 1}-${gameDate.getDate()}-${gameDate.getFullYear()}`;
      const gameId = `${dateStr}_${selectedTeam.toLowerCase()}_vs_${game.opponent.toLowerCase()}`.replace(/\s+/g, '_');
      const gameDocId = `${seasonId}_${gameId}`;
      
      for (const { row, validation } of game.rows) {
        try {
          // Use matched player's legacyId if available, otherwise generate from name
          let playerLegacyId;
          if (validation.matchedPlayer) {
            playerLegacyId = validation.matchedPlayer.legacyId;
          } else {
            playerLegacyId = row.player.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_');
          }
          
          const ab = parseInt(row.ab) || 0;
          const h = parseInt(row.h) || 0;
          const r = parseInt(row.r) || 0;
          const bb = parseInt(row.bb) || 0;
          
          if (ab > 0 || h > 0 || r > 0 || bb > 0) {
            const battingRef = doc(db, 'playerStats', playerLegacyId, 'games', gameDocId);
            
            await setDoc(battingRef, {
              gameId: gameId,
              gameDocId: gameDocId,
              playerId: playerLegacyId,
              playerName: validation.matchedPlayer?.name || row.player,
              seasonId: seasonId,
              teamId: selectedTeam,
              gameDateFormatted: game.date,
              opponent: game.opponent,
              isHome: game.isHome,
              gameType: 'Regular',
              isPlayoff: false,
              atBats: ab,
              hits: h,
              runs: r,
              walks: bb,
              doubles: 0, triples: 0, homeRuns: 0, rbi: 0,
              strikeouts: 0, stolenBases: 0, caughtStealing: 0,
              submittedBy: currentUser.uid,
              submittedByName: currentUser.displayName || currentUser.email,
              submittedAt: serverTimestamp(),
              lastModified: serverTimestamp(),
              dataVersion: 1,
              bulkImport: true
            }, { merge: true });
          }
          
          const ip = parseFloat(row.ip) || 0;
          const ra = parseInt(row.ra) || 0;
          
          if (ip > 0 || ra > 0) {
            const pitchingRef = doc(db, 'pitchingStats', playerLegacyId, 'games', gameDocId);
            
            await setDoc(pitchingRef, {
              gameId: gameId,
              gameDocId: gameDocId,
              playerId: playerLegacyId,
              playerName: validation.matchedPlayer?.name || row.player,
              seasonId: seasonId,
              teamId: selectedTeam,
              gameDateFormatted: game.date,
              opponent: game.opponent,
              isHome: game.isHome,
              gameType: 'Regular',
              isPlayoff: false,
              inningsPitched: ip,
              runsAllowed: ra,
              earnedRuns: 0, strikeouts: 0, walks: 0, hits: 0,
              wins: 0, losses: 0, saves: 0,
              submittedBy: currentUser.uid,
              submittedByName: currentUser.displayName || currentUser.email,
              submittedAt: serverTimestamp(),
              lastModified: serverTimestamp(),
              dataVersion: 1,
              bulkImport: true
            }, { merge: true });
          }
          
          successCount++;
        } catch (error) {
          console.error(`‚ùå Error saving stats for ${row.player}:`, error);
          errorCount++;
        }
      }
    }
    
    if (errorCount === 0) {
      showMessage('success', `Successfully uploaded stats for ${successCount} player-game combinations across ${Object.keys(gameGroups).length} games!`);
      showToast(`Bulk upload complete: ${successCount} records`, 'success');
      
      // Mark all uploaded games as having stats submitted
      for (const gameKey of Object.keys(gameGroups)) {
        const game = gameGroups[gameKey];
        const gameDate = new Date(game.date);
        const dateStr = `${gameDate.getMonth() + 1}-${gameDate.getDate()}-${gameDate.getFullYear()}`;
        const gameId = `${dateStr}_${selectedTeam.toLowerCase()}_vs_${game.opponent.toLowerCase()}`.replace(/\s+/g, '_');
        
        try {
          const gameRef = doc(db, 'seasons', seasonId, 'games', gameId);
          await updateDoc(gameRef, {
            statsSubmitted: true,
            statsSubmittedBy: currentUser.uid,
            statsSubmittedByName: currentUser.displayName || currentUser.email,
            statsSubmittedAt: serverTimestamp(),
            statsSubmittedForTeam: selectedTeam,
            statsSubmittedViaBulkUpload: true
          });
          console.log(`‚úÖ Marked game ${gameId} as having stats submitted`);
        } catch (gameUpdateError) {
          console.warn(`‚ö†Ô∏è Could not update game ${gameId} with statsSubmitted flag:`, gameUpdateError);
        }
      }
      
      setTimeout(() => clearBulkUpload(), 2000);
    } else {
      showMessage('warning', `Uploaded ${successCount} records, but ${errorCount} failed.`);
    }
    
  } catch (error) {
    console.error('‚ùå Error in bulk upload:', error);
    showMessage('error', `Error during bulk upload: ${error.message}`);
  }
  
  bulkSubmitBtn.disabled = false;
  bulkSubmitBtn.innerHTML = originalBtnText;
};

window.clearBulkUpload = function() {
  csvData = [];
  csvValidation = [];
  document.getElementById('csvFileInput').value = '';
  document.getElementById('csvPreviewSection').style.display = 'none';
  showMessage('info', 'Upload cleared.');
};

// Drag and drop support
const uploadArea = document.getElementById('uploadArea');
if (uploadArea) {
  uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
  });
  
  uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
  });
  
  uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file && file.name.endsWith('.csv')) {
      document.getElementById('csvFileInput').files = e.dataTransfer.files;
      handleCSVUpload({ target: { files: [file] } });
    } else {
      showMessage('error', 'Please upload a CSV file.');
    }
  });
}

// ============================================
// INITIALIZATION
// ============================================
async function initializePage(user) {
  if (!user) {
    window.location.href = 'signin.html';
    return;
  }

  console.log('üöÄ Initializing submit-stats page for:', user.displayName);

  try {
    currentUser = user;

    const profileResult = await getUserProfile(user.uid);
    if (!profileResult.success) {
      throw new Error('Could not load user profile');
    }

    userProfile = profileResult.data;
    console.log('üë§ User profile loaded:', userProfile);

    const access = hasStatsSubmissionAccess(userProfile);
    console.log('üîê Access check:', access);

    if (!access.hasAccess) {
      document.getElementById('accessDenied').style.display = 'flex';
      document.getElementById('loadingOverlay').classList.add('hidden');
      return;
    }

    currentSeason = await getCurrentSeason();
    if (!currentSeason) {
      throw new Error('No active season found');
    }

    console.log('üìÖ Current season:', currentSeason.id);

    document.getElementById('mainContent').style.display = 'block';

    if (access.role === 'admin' || access.role === 'league-staff') {
      isAdmin = access.role === 'admin';
      isLeagueStaff = access.role === 'league-staff';
      
      document.getElementById('teamSelectionSection').style.display = 'block';
      
      const teams = await getAllTeams();
      const teamSelect = document.getElementById('teamSelect');
      
      teams.forEach(team => {
        const option = document.createElement('option');
        option.value = team.id;
        option.textContent = team.name;
        teamSelect.appendChild(option);
      });

      teamSelect.addEventListener('change', async (e) => {
        const teamId = e.target.value;
        if (teamId) {
          selectedTeam = teamId;
          showMessage('info', 'Loading team roster...');
          try {
            rosterPlayers = await loadTeamRoster(teamId);
            renderStatsTable(rosterPlayers);
            showMessage('info', `Loaded ${rosterPlayers.length} players. Select a game or use CSV upload.`);
          } catch (error) {
            showMessage('error', `Error loading roster: ${error.message}`);
          }
        } else {
          document.getElementById('statsGridContainer').style.display = 'none';
          document.getElementById('actionButtons').style.display = 'none';
        }
      });

    } else {
      selectedTeam = access.teamId;
      showMessage('info', 'Loading your team roster...');
      
      try {
        rosterPlayers = await loadTeamRoster(selectedTeam);
        renderStatsTable(rosterPlayers);
        showMessage('info', `Loaded ${rosterPlayers.length} players. Select a game or use CSV upload.`);
      } catch (error) {
        showMessage('error', `Error loading roster: ${error.message}`);
      }
    }

    // Set up event listeners
    document.getElementById('submitBtn').addEventListener('click', submitStats);
    document.getElementById('clearBtn').addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all entered stats?')) {
        clearAllStats();
      }
    });
    
    document.getElementById('gameSelect').addEventListener('change', async (e) => {
      const selectedOption = e.target.options[e.target.selectedIndex];
      if (selectedOption.value) {
        const gameData = JSON.parse(selectedOption.dataset.gameData);
        
        // Reconstruct dateObj
        if (gameData.dateObj) {
          gameData.dateObj = new Date(gameData.dateObj);
        }
        
        const gameDetails = document.getElementById('gameDetails');
        const hasValidDate = gameData.dateObj && 
                            !isNaN(gameData.dateObj.getTime()) && 
                            gameData.dateObj.getTime() !== 0;
        
        const dateStr = hasValidDate
          ? gameData.dateObj.toLocaleDateString('en-US', { 
              weekday: 'long', 
              year: 'numeric',
              month: 'long', 
              day: 'numeric' 
            })
          : 'TBD';
        
        document.getElementById('selectedGameDate').textContent = dateStr;
        document.getElementById('selectedGameOpponent').textContent = gameData.opponent || 'Unknown';
        document.getElementById('selectedGameLocation').textContent = gameData.isHome ? 'Home' : 'Away';
        
        gameDetails.style.display = 'block';
        
        await loadExistingStatsForGame(selectedOption.value);
      } else {
        document.getElementById('gameDetails').style.display = 'none';
        clearAllStats();
      }
    });

    document.getElementById('loadingOverlay').classList.add('hidden');

  } catch (error) {
    console.error('‚ùå Error initializing page:', error);
    showMessage('error', `Error loading page: ${error.message}`);
    document.getElementById('loadingOverlay').classList.add('hidden');
  }
}

onAuthChange((user) => {
  if (user) {
    initializePage(user);
  } else {
    window.location.href = 'signin.html';
  }
});
</script>

</div><!-- Close page-container -->
<script src="mobile-enhancements.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Legacy Stats Aggregator - Mountainside Aces Admin</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background: #f5f5f5;
  }
  .container {
    background: white;
    border-radius: 8px;
    padding: 30px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  }
  h1 {
    color: #333;
    margin-top: 0;
  }
  .info-box {
    background: #e3f2fd;
    border-left: 4px solid #2196f3;
    padding: 15px;
    margin: 20px 0;
  }
  .warning-box {
    background: #fff3e0;
    border-left: 4px solid #ff9800;
    padding: 15px;
    margin: 20px 0;
  }
  .success-box {
    background: #e8f5e9;
    border-left: 4px solid #4caf50;
    padding: 15px;
    margin: 20px 0;
  }
  button {
    background: #2196f3;
    color: white;
    border: none;
    padding: 12px 24px;
    font-size: 16px;
    border-radius: 4px;
    cursor: pointer;
    margin: 10px 5px 10px 0;
  }
  button:hover {
    background: #1976d2;
  }
  button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
  #output {
    background: #263238;
    color: #aed581;
    padding: 20px;
    border-radius: 4px;
    max-height: 500px;
    overflow-y: auto;
    font-family: 'Monaco', 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.6;
    white-space: pre-wrap;
    margin-top: 20px;
  }
  .stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin: 20px 0;
  }
  .stat-card {
    background: #f5f5f5;
    padding: 15px;
    border-radius: 4px;
    text-align: center;
  }
  .stat-number {
    font-size: 32px;
    font-weight: bold;
    color: #2196f3;
  }
  .stat-label {
    font-size: 14px;
    color: #666;
    margin-top: 5px;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>üìÅ Legacy Stats Aggregator</h1>
    
    <div class="info-box">
      <strong>‚ÑπÔ∏è When to use this tool:</strong>
      <ul>
        <li>Re-aggregate stats for a <strong>newly authenticated user</strong> who linked their account</li>
        <li>Creates new <code>aggregatedPlayerStats/{authUID}</code> document from their legacy <code>playerStats</code> data</li>
        <li>Works with <strong>2025 and earlier</strong> season-level data (not game-based)</li>
      </ul>
    </div>
    
    <div class="success-box">
      <strong>‚úÖ NO DUPLICATES - HYBRID APPROACH:</strong>
      <ul>
        <li><strong>Auth users:</strong> Aggregates from their linked player stats</li>
        <li><strong>Legacy players (not migrated):</strong> Aggregates normally</li>
        <li><strong>Migrated legacy profiles:</strong> SKIPPED (prevents duplicates)</li>
        <li><strong>Optional auth:</strong> Works whether players sign in or not!</li>
      </ul>
    </div>

    <div class="info-box">
      <strong>How the migration flag works:</strong>
      <ul>
        <li>When someone links their account, their old legacy profile gets marked: <code>migrated: true</code></li>
        <li>This script skips any profile with <code>migrated: true</code></li>
        <li>If a player never signs in, their legacy profile keeps working</li>
        <li>Result: No duplicates, works for everyone!</li>
      </ul>
    </div>

    <div class="warning-box">
      <strong>Before running:</strong> Make sure you've updated firebase-auth.js with the migration marking code.
    </div>

    <div class="stats" id="statsDisplay" style="display: none;">
      <div class="stat-card">
        <div class="stat-number" id="playersProcessed">0</div>
        <div class="stat-label">Players Processed</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="legacyCount">0</div>
        <div class="stat-label">Unmigrated Legacy</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="authCount">0</div>
        <div class="stat-label">Auth Users</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="skippedCount">0</div>
        <div class="stat-label">Migrated (Skipped)</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="errorCount">0</div>
        <div class="stat-label">Errors</div>
      </div>
    </div>

    <button id="aggregateBtn" onclick="runAggregation()">üöÄ Aggregate All Player Stats</button>
    <button id="verifyBtn" onclick="verifyAggregation()" style="background: #4caf50;">‚úì Verify Collection</button>
    <button onclick="clearOutput()" style="background: #757575;">Clear Output</button>

    <div id="output"></div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import {
      getFirestore,
      collection,
      doc,
      getDocs,
      getDoc,
      setDoc,
	  updateDoc,
      query,
      where
    } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyCAEWkrTcprzJ2KPPJu-vFJPvYOVU4ky20",
      authDomain: "acessoftballreference-84791.firebaseapp.com",
      projectId: "acessoftballreference-84791",
      storageBucket: "acessoftballreference-84791.firebasestorage.app",
      messagingSenderId: "777699560175",
      appId: "1:777699560175:web:4092b422e7d7116352e91a"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Make functions globally available
    window.db = db;
    window.collection = collection;
    window.doc = doc;
    window.getDocs = getDocs;
    window.getDoc = getDoc;
    window.setDoc = setDoc;
	window.updateDoc = updateDoc;
    window.query = query;
    window.where = where;

    log('‚úì Firebase initialized successfully');

    // Utility functions
    function log(message, type = 'info') {
      const output = document.getElementById('output');
      const timestamp = new Date().toLocaleTimeString();
      let prefix = '‚óÜ';
      
      if (type === 'success') prefix = '‚úì';
      if (type === 'error') prefix = '‚úó';
      if (type === 'header') prefix = '‚ïê‚ïê‚ïê';
      if (type === 'auth') prefix = 'üîê';
      if (type === 'legacy') prefix = 'üìÅ';
      if (type === 'skip') prefix = '‚è≠Ô∏è';
      
      const line = `[${timestamp}] ${prefix} ${message}\n`;
      output.textContent += line;
      output.scrollTop = output.scrollHeight;
    }

    function updateStats(processed, legacy, auth, skipped, errors) {
      document.getElementById('statsDisplay').style.display = 'grid';
      document.getElementById('playersProcessed').textContent = processed;
      document.getElementById('legacyCount').textContent = legacy;
      document.getElementById('authCount').textContent = auth;
      document.getElementById('skippedCount').textContent = skipped;
      document.getElementById('errorCount').textContent = errors;
    }

    window.clearOutput = function() {
      document.getElementById('output').textContent = '';
      document.getElementById('statsDisplay').style.display = 'none';
    };

    // FINAL: Main aggregation function - NO DUPLICATES
    window.runAggregation = async function() {
      const btn = document.getElementById('aggregateBtn');
      btn.disabled = true;
      btn.textContent = '‚è≥ Processing...';
      
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('FINAL Player Stats Aggregation (NO DUPLICATES)', 'header');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      
      try {
        // Get all users
        log('Fetching all users...');
        const usersRef = window.collection(window.db, 'users');
        const allUsersSnapshot = await window.getDocs(usersRef);
        
        log(`Found ${allUsersSnapshot.size} total users`);
        
        // CRITICAL: Filter out migrated legacy profiles to prevent duplicates
        const playerDocs = allUsersSnapshot.docs.filter(doc => {
          const data = doc.data();
          const role = data.role;
          const linkedPlayer = data.linkedPlayer;
          const migrated = data.migrated;
          
          // Skip migrated legacy profiles (someone already linked this account)
          if (migrated) {
            return false;
          }
          
          // Include unmigrated legacy players (have 'role' field, not migrated)
          if (role) {
            const roleLower = role.toLowerCase();
            if (roleLower === 'player' || roleLower === 'captain') return true;
          }
          
          // Include auth users who linked to a player
          if (linkedPlayer) return true;
          
          return false;
        });
        
        // Count how many were skipped
        const migratedCount = allUsersSnapshot.docs.filter(doc => doc.data().migrated).length;
        
        log(`Filtered to ${playerDocs.length} players (skipped ${migratedCount} migrated)`);
        log(`  üìÅ Legacy profiles (not migrated)`);
        log(`  üîê Auth users (linked to players)`);
        log(`  ‚è≠Ô∏è Migrated profiles: ${migratedCount} (SKIPPED)`);
        
        let successCount = 0;
        let errorCount = 0;
        let processed = 0;
        let legacyCount = 0;
        let authCount = 0;
        
        // Process each player
        for (const userDoc of playerDocs) {
          const userId = userDoc.id;
          const userData = userDoc.data();
          
          // Determine if this is legacy or auth user
          const isAuthUser = !!userData.linkedPlayer;
          const playerType = isAuthUser ? 'AUTH' : 'LEGACY';
          
          try {
            log(`Processing ${playerType}: ${userData.name || userId}...`, isAuthUser ? 'auth' : 'legacy');
            processed++;
            
            if (isAuthUser) {
              authCount++;
            } else {
              legacyCount++;
            }
            
            // CRITICAL: Determine the correct stats lookup ID
            let statsLookupId = userId; // Default for legacy players
            
            // If this is an auth user with linkedPlayer, use the player name for stats lookup
            if (userData.linkedPlayer) {
              // Remove periods (Jr. ‚Üí Jr) before converting spaces to underscores
              statsLookupId = userData.linkedPlayer.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_');
              log(`  ‚Üí Stats from: playerStats/${statsLookupId}/`);
            }
            
            // Get all season documents using the correct stats ID
            const seasonsRef = window.collection(window.db, 'playerStats', statsLookupId, 'seasons');
            const seasonsSnapshot = await window.getDocs(seasonsRef);
            
            // Store seasons as OBJECT with seasonId keys
            const seasonStatsObject = {};
            let calculatedCareerStats = {
              games: 0,
              atBats: 0,
              hits: 0,
              runs: 0,
              walks: 0,
              acesBPITotal: 0,
              acesBPICount: 0
            };
            
            seasonsSnapshot.forEach(seasonDoc => {
              const data = seasonDoc.data();
              const seasonId = seasonDoc.id;
              
              const games = data.games || 0;
              const atBats = data.atBats || 0;
              const hits = data.hits || 0;
              const runs = data.runs || 0;
              const walks = data.walks || 0;
              const acesBPI = data.acesBPI || data.acesWar || 0;
              const sub = data.sub || data.Sub || "No";
              const team = data.team || "";
              
              // Add to career totals
              calculatedCareerStats.games += games;
              calculatedCareerStats.atBats += atBats;
              calculatedCareerStats.hits += hits;
              calculatedCareerStats.runs += runs;
              calculatedCareerStats.walks += walks;
              if (acesBPI !== 0 && sub.toLowerCase() !== "yes") {
                calculatedCareerStats.acesBPITotal += acesBPI;
                calculatedCareerStats.acesBPICount++;
              }
              
              // Store with seasonId as KEY (not array index)
              seasonStatsObject[seasonId] = {
                team: team,
                games: games,
                atBats: atBats,
                hits: hits,
                runs: runs,
                walks: walks,
                battingAverage: atBats > 0 ? (hits / atBats) : 0,
                onBasePercentage: (atBats + walks) > 0
                  ? ((hits + walks) / (atBats + walks))
                  : 0,
                acesBPI: acesBPI,
                sub: sub
              };
            });
            
            // Calculate career stats
            const careerBattingAverage = calculatedCareerStats.atBats > 0
              ? (calculatedCareerStats.hits / calculatedCareerStats.atBats)
              : 0;
            const careerOnBasePercentage = (calculatedCareerStats.atBats + calculatedCareerStats.walks) > 0
              ? ((calculatedCareerStats.hits + calculatedCareerStats.walks) / (calculatedCareerStats.atBats + calculatedCareerStats.walks))
              : 0;
            const careerAcesBPI = calculatedCareerStats.acesBPICount > 0
              ? (calculatedCareerStats.acesBPITotal / calculatedCareerStats.acesBPICount)
              : 0;
            
            // Get pitching stats using the same statsLookupId
            const pitchingSeasonsRef = window.collection(window.db, 'pitchingStats', statsLookupId, 'seasons');
            let pitchingSeasonsSnapshot;
            let hasPitchingData = false;
            
            try {
              pitchingSeasonsSnapshot = await window.getDocs(pitchingSeasonsRef);
              hasPitchingData = !pitchingSeasonsSnapshot.empty;
            } catch (error) {
              hasPitchingData = false;
            }
            
            const pitchingSeasonStatsObject = {};
            let calculatedPitchingCareer = {
              games: 0,
              inningsPitched: 0,
              earnedRuns: 0,
              strikeouts: 0,
              walks: 0
            };
            
            if (hasPitchingData) {
              pitchingSeasonsSnapshot.forEach(seasonDoc => {
                const data = seasonDoc.data();
                const seasonId = seasonDoc.id;
                
                const games = data.games || 0;
                const ip = data.inningsPitched || data.IP || data.ip || 0;
                const era = data.era || data.ERA || data.earnedRunAverage || 0;
                const runsAllowed = data.runsAllowed || 0;
                const strikeouts = data.strikeouts || data.K || data.k || data.SO || 0;
                const walks = data.walks || data.BB || data.bb || 0;
                
                const earnedRuns = runsAllowed > 0 ? runsAllowed : (ip > 0 && era > 0 ? (era * ip) / 7 : 0);
                
                calculatedPitchingCareer.games += games;
                calculatedPitchingCareer.inningsPitched += ip;
                calculatedPitchingCareer.earnedRuns += earnedRuns;
                calculatedPitchingCareer.strikeouts += strikeouts;
                calculatedPitchingCareer.walks += walks;
                
                pitchingSeasonStatsObject[seasonId] = {
                  team: data.team || '',
                  games: games,
                  inningsPitched: ip,
                  earnedRunAverage: era,
                  runsAllowed: runsAllowed,
                  strikeouts: strikeouts,
                  walks: walks
                };
              });
            }
            
            const careerEarnedRunAverage = calculatedPitchingCareer.inningsPitched > 0
              ? (calculatedPitchingCareer.earnedRuns * 7) / calculatedPitchingCareer.inningsPitched
              : 0;
            
            // Create aggregated document
            const aggregatedData = {
              userId: userId,
              name: userData.name || userData.displayName || '',
              email: userData.email || '',
              currentTeam: userData.currentTeam || userData.linkedTeam || '',
              photoURL: userData.photoURL || '',
              
              // Mark player type for debugging
              isAuthUser: isAuthUser,
              linkedPlayer: userData.linkedPlayer || null,
              
              // CRITICAL: Copy migrated flag to prevent duplicates
              migrated: userData.migrated || false,
              
              // Career stats
              career: {
                games: calculatedCareerStats.games,
                atBats: calculatedCareerStats.atBats,
                hits: calculatedCareerStats.hits,
                runs: calculatedCareerStats.runs,
                walks: calculatedCareerStats.walks,
                battingAverage: careerBattingAverage,
                onBasePercentage: careerOnBasePercentage,
                acesBPI: careerAcesBPI,
                
                pitching: {
                  games: calculatedPitchingCareer.games,
                  inningsPitched: calculatedPitchingCareer.inningsPitched,
                  earnedRunAverage: careerEarnedRunAverage,
                  runsAllowed: calculatedPitchingCareer.earnedRuns,
                  strikeouts: calculatedPitchingCareer.strikeouts,
                  walks: calculatedPitchingCareer.walks
                }
              },
              
              // Store as OBJECT with seasonId keys
              seasons: seasonStatsObject,
              pitchingSeasons: pitchingSeasonStatsObject,
              
              // Metadata
              totalSeasons: Object.keys(seasonStatsObject).length,
              hasPitchingStats: Object.keys(pitchingSeasonStatsObject).length > 0,
              lastUpdated: new Date()
            };
            
            // Write to aggregated collection (use original userId as document ID)
            const aggregatedRef = window.doc(window.db, 'aggregatedPlayerStats', userId);
            await window.setDoc(aggregatedRef, aggregatedData);
            
			// NEW: Mark legacy profile in aggregatedPlayerStats as migrated (if exists)
			if (isAuthUser && userData.linkedPlayer) {
				// Remove periods (Jr. ‚Üí Jr) before converting spaces to underscores
				const playerUserId = userData.linkedPlayer.toLowerCase().replace(/\./g, '').replace(/\s+/g, '_');
			if (playerUserId !== userId) {
			try {
				const legacyAggregatedRef = window.doc(window.db, 'aggregatedPlayerStats', playerUserId);
				const legacyAggregatedDoc = await window.getDoc(legacyAggregatedRef);
      
			if (legacyAggregatedDoc.exists()) {
				await window.updateDoc(legacyAggregatedRef, {
			migrated: true,
			migratedTo: userId,
				migratedAt: new Date()
        });
        log(`    ‚Üí Marked legacy aggregated profile ${playerUserId} as migrated`);
      }
    } catch (error) {
      // Silently continue if legacy aggregated profile doesn't exist
    }
  }
}
			
            log(`  ‚úì ${userData.name || userId} (${Object.keys(seasonStatsObject).length} seasons)`, 'success');
            successCount++;
            updateStats(processed, legacyCount, authCount, migratedCount, errorCount);
            
          } catch (error) {
            log(`  ‚úó Error with ${userData.name || userId}: ${error.message}`, 'error');
            console.error('Full error:', error);
            errorCount++;
            updateStats(processed, legacyCount, authCount, migratedCount, errorCount);
          }
        }
        
        log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
        log('Aggregation Complete!', 'header');
        log(`‚úì Successful: ${successCount} players`, 'success');
        log(`üìÅ Unmigrated legacy: ${legacyCount}`, 'legacy');
        log(`üîê Auth users: ${authCount}`, 'auth');
        log(`‚è≠Ô∏è Migrated (skipped): ${migratedCount}`, 'skip');
        if (errorCount > 0) {
          log(`‚úó Errors: ${errorCount} players`, 'error');
        }
        log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
        log('‚úÖ NO DUPLICATES - Each player aggregated once!');
        
      } catch (error) {
        log(`Fatal error: ${error.message}`, 'error');
        console.error('Aggregation error:', error);
      } finally {
        btn.disabled = false;
        btn.textContent = 'üöÄ Aggregate All Player Stats';
      }
    };

    // Verify aggregation function
    window.verifyAggregation = async function() {
      const btn = document.getElementById('verifyBtn');
      btn.disabled = true;
      
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      log('Verifying Aggregated Collection', 'header');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'header');
      
      try {
        const statsRef = window.collection(window.db, 'aggregatedPlayerStats');
        const snapshot = await window.getDocs(statsRef);
        
        log(`Found ${snapshot.size} documents in aggregatedPlayerStats`, 'success');
        
        // Count auth users vs legacy
        let authUserCount = 0;
        let legacyCount = 0;
        
        snapshot.docs.forEach(doc => {
          const data = doc.data();
          if (data.isAuthUser) {
            authUserCount++;
          } else {
            legacyCount++;
          }
        });
        
        log(`\nüìä Breakdown:`);
        log(`  üìÅ Unmigrated legacy: ${legacyCount}`);
        log(`  üîê Auth users: ${authUserCount}`);
        log(`  üìà Total: ${snapshot.size}`);
        
        // Check for potential duplicates by name
        const nameMap = new Map();
        snapshot.docs.forEach(doc => {
          const name = doc.data().name;
          if (name) {
            if (!nameMap.has(name)) {
              nameMap.set(name, []);
            }
            nameMap.get(name).push(doc.id);
          }
        });
        
        const duplicates = Array.from(nameMap.entries()).filter(([name, ids]) => ids.length > 1);
        
        if (duplicates.length > 0) {
          log(`\n‚ö†Ô∏è Potential duplicates found:`, 'error');
          duplicates.forEach(([name, ids]) => {
            log(`  ${name}: ${ids.length} entries (${ids.join(', ')})`, 'error');
          });
        } else {
          log(`\n‚úÖ No duplicates found!`, 'success');
        }
        
        if (snapshot.size > 0) {
          const firstDoc = snapshot.docs[0];
          const data = firstDoc.data();
          
          if (data.seasons) {
            const seasonKeys = Object.keys(data.seasons);
            log(`\n‚úì Seasons stored as OBJECT with ${seasonKeys.length} keys`);
          }
          
          log('\n‚úì Collection structure verified!', 'success');
        }
        
      } catch (error) {
        log(`Verification error: ${error.message}`, 'error');
        console.error('Verification error:', error);
      } finally {
        btn.disabled = false;
      }
    };
  </script>
</body>
</html>

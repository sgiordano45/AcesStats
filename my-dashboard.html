<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>My Dashboard - Mountainside Aces</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">

<style>
:root {
  --primary-color: #2d5016;
  --secondary-color: #1a6b4a;
  --accent-color: #ffd700;
  --card-bg: #ffffff;
  --text-dark: #2d3748;
  --text-light: #718096;
  --border-color: #e2e8f0;
  --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
  --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
  --success-color: #10b981;
  --warning-color: #f59e0b;
  --danger-color: #ef4444;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  min-height: 100vh;
  color: var(--text-dark);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,255,255,0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.3s ease;
}

.loading-overlay.hidden {
  opacity: 0;
  pointer-events: none;
}

.softball-spinner::before {
  content: '‚öæ';
  font-size: 80px;
  animation: spin 1.5s ease-in-out infinite;
}

@keyframes spin {
  0%, 100% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.1); }
}

/* Header */
.header {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  padding: 2rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
}

.header::before {
  content: '';
  position: absolute;
  top: -50px;
  right: -50px;
  width: 250px;
  height: 250px;
  background: rgba(255,255,255,0.05);
  border-radius: 50%;
}

.header::after {
  content: '‚öæ';
  position: absolute;
  bottom: -30px;
  left: -30px;
  font-size: 150px;
  opacity: 0.05;
}

.header-content {
  max-width: 1400px;
  margin: 0 auto;
  position: relative;
  z-index: 1;
}

.greeting-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1.5rem;
}

.greeting {
  color: white;
}

.greeting h1 {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
}

.greeting p {
  font-size: 1.1rem;
  opacity: 0.9;
}

.time-display {
  font-size: 0.9rem;
  opacity: 0.8;
  margin-top: 0.25rem;
}

.header-actions {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}

.header-btn {
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  text-decoration: none;
  font-weight: 600;
  font-size: 0.95rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: all 0.3s ease;
  border: 2px solid rgba(255,255,255,0.3);
  cursor: pointer;
}

.header-btn.primary {
  background: white;
  color: var(--primary-color);
}

.header-btn.primary:hover {
  background: var(--accent-color);
  border-color: var(--accent-color);
  transform: translateY(-2px);
}

.header-btn.secondary {
  background: rgba(255,255,255,0.15);
  color: white;
}

.header-btn.secondary:hover {
  background: rgba(255,255,255,0.25);
  transform: translateY(-2px);
}

/* Main Content */
.dashboard-container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 2rem;
}

/* Dashboard Grid */
.dashboard-grid {
  display: grid;
  grid-template-columns: 1fr 1fr 350px;
  gap: 2rem;
}

@media (max-width: 1200px) {
  .dashboard-grid {
    grid-template-columns: 1fr 1fr;
  }
  .sidebar {
    grid-column: span 2;
  }
}

@media (max-width: 768px) {
  .dashboard-grid {
    grid-template-columns: 1fr;
  }
  .sidebar {
    grid-column: span 1;
  }
}

/* Cards */
.card {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 1.5rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
}

.card:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.25rem;
  padding-bottom: 1rem;
  border-bottom: 2px solid var(--border-color);
  position: relative;
  z-index: 5;
}

.card-title {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--text-dark);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.card-action {
  color: var(--primary-color);
  text-decoration: none;
  font-weight: 600;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  transition: all 0.3s ease;
}

.card-action:hover {
  color: var(--secondary-color);
  transform: translateX(3px);
}

/* Next Game Card - Featured */
.next-game-card {
  grid-column: span 2;
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  color: white;
  position: relative;
  overflow: hidden;
}

.next-game-card::before {
  content: '';
  position: absolute;
  top: -50px;
  right: -50px;
  width: 200px;
  height: 200px;
  background: rgba(255,255,255,0.05);
  border-radius: 50%;
}

.next-game-card .card-header {
  border-bottom-color: rgba(255,255,255,0.2);
}

.next-game-card .card-title {
  color: white;
}

.next-game-card .card-action {
  color: var(--accent-color);
  position: relative;
  z-index: 10;
  cursor: pointer;
}

.next-game-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 2rem;
  flex-wrap: wrap;
}

.game-matchup {
  flex: 1;
  min-width: 250px;
}

.matchup-teams {
  display: flex;
  align-items: center;
  gap: 1.5rem;
  margin-bottom: 1rem;
}

.team-info {
  text-align: center;
}

.team-name {
  font-size: 1.5rem;
  font-weight: 700;
}

.team-label {
  font-size: 0.8rem;
  opacity: 0.8;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.vs-badge {
  font-size: 1.2rem;
  font-weight: 700;
  opacity: 0.7;
}

.game-details {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem;
  margin-top: 1rem;
}

.game-detail {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.95rem;
  opacity: 0.95;
}

.game-actions {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.rsvp-buttons {
  display: flex;
  gap: 0.5rem;
}

.rsvp-btn {
  padding: 0.6rem 1rem;
  border: 2px solid rgba(255,255,255,0.3);
  background: rgba(255,255,255,0.1);
  color: white;
  border-radius: 8px;
  font-weight: 600;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.3s ease;
  font-family: inherit;
}

.rsvp-btn:hover {
  background: rgba(255,255,255,0.2);
  transform: translateY(-2px);
}

.rsvp-btn.active {
  background: white;
  color: var(--primary-color);
  border-color: white;
}

.rsvp-btn.yes.active { background: var(--success-color); color: white; border-color: var(--success-color); }
.rsvp-btn.maybe.active { background: var(--warning-color); color: white; border-color: var(--warning-color); }
.rsvp-btn.no.active { background: var(--danger-color); color: white; border-color: var(--danger-color); }

.countdown {
  text-align: center;
  padding: 1rem;
  background: rgba(255,255,255,0.1);
  border-radius: 12px;
}

.countdown-number {
  font-size: 2.5rem;
  font-weight: 800;
  line-height: 1;
}

.countdown-label {
  font-size: 0.85rem;
  opacity: 0.8;
  margin-top: 0.25rem;
}

@media (max-width: 768px) {
  .next-game-card {
    grid-column: span 1;
  }
}

/* Quick Stats */
.quick-stats {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

.stat-item {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  padding: 1rem;
  border-radius: 12px;
  text-align: center;
  border: 2px solid var(--border-color);
  transition: all 0.3s ease;
}

.stat-item:hover {
  border-color: var(--primary-color);
  transform: translateY(-2px);
}

.stat-value {
  font-size: 1.75rem;
  font-weight: 700;
  color: var(--primary-color);
}

.stat-label {
  font-size: 0.8rem;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: 0.25rem;
}

/* Upcoming Games List */
.games-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.game-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: #f8f9fa;
  border-radius: 12px;
  border: 2px solid transparent;
  transition: all 0.3s ease;
  text-decoration: none;
  color: inherit;
}

.game-item:hover {
  border-color: var(--primary-color);
  background: white;
  transform: translateX(5px);
}

.game-date-box {
  background: var(--primary-color);
  color: white;
  padding: 0.75rem;
  border-radius: 10px;
  text-align: center;
  min-width: 60px;
}

.game-date-day {
  font-size: 1.25rem;
  font-weight: 700;
  line-height: 1;
}

.game-date-month {
  font-size: 0.7rem;
  text-transform: uppercase;
  opacity: 0.9;
  margin-top: 0.25rem;
}

.game-info {
  flex: 1;
}

.game-opponent {
  font-weight: 600;
  color: var(--text-dark);
  margin-bottom: 0.25rem;
}

.game-meta {
  font-size: 0.85rem;
  color: var(--text-light);
  display: flex;
  gap: 1rem;
}

.game-rsvp-status {
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
}

.game-rsvp-status.yes { background: #d1fae5; color: #065f46; }
.game-rsvp-status.maybe { background: #fef3c7; color: #92400e; }
.game-rsvp-status.no { background: #fee2e2; color: #991b1b; }
.game-rsvp-status.pending { background: #e2e8f0; color: #475569; }

/* Action Items */
.action-items {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.action-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: #fffbeb;
  border: 2px solid #fcd34d;
  border-radius: 12px;
  text-decoration: none;
  color: inherit;
  transition: all 0.3s ease;
}

.action-item:hover {
  background: #fef3c7;
  transform: translateX(5px);
}

.action-item.urgent {
  background: #fef2f2;
  border-color: #fca5a5;
}

.action-item.urgent:hover {
  background: #fee2e2;
}

.action-icon {
  font-size: 1.5rem;
}

.action-content {
  flex: 1;
}

.action-title {
  font-weight: 600;
  color: var(--text-dark);
}

.action-description {
  font-size: 0.85rem;
  color: var(--text-light);
}

.action-arrow {
  color: var(--text-light);
  font-size: 1.25rem;
}

/* Notification Feed */
.notification-feed {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  max-height: 400px;
  overflow-y: auto;
}

.notification-item {
  display: flex;
  align-items: flex-start;
  gap: 0.75rem;
  padding: 0.875rem;
  background: #f8fafc;
  border-radius: 10px;
  border-left: 3px solid var(--primary-color);
  transition: all 0.2s ease;
  cursor: pointer;
  position: relative;
}

.notification-item:hover {
  background: #f1f5f9;
}

.notification-item.unread {
  background: #eff6ff;
  border-left-color: #3b82f6;
}

.notification-item.unread::before {
  content: '';
  position: absolute;
  top: 0.75rem;
  right: 0.75rem;
  width: 8px;
  height: 8px;
  background: #3b82f6;
  border-radius: 50%;
}

.notification-icon {
  font-size: 1.25rem;
  flex-shrink: 0;
}

.notification-content {
  flex: 1;
  min-width: 0;
}

.notification-title {
  font-weight: 600;
  color: var(--text-dark);
  font-size: 0.9rem;
  margin-bottom: 0.25rem;
}

.notification-body {
  font-size: 0.85rem;
  color: var(--text-light);
  line-height: 1.4;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.notification-time {
  font-size: 0.75rem;
  color: var(--text-light);
  margin-top: 0.25rem;
}

.notification-clear-btn {
  background: none;
  border: none;
  color: var(--text-light);
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 4px;
  transition: all 0.2s ease;
  font-size: 1rem;
  opacity: 0;
}

.notification-item:hover .notification-clear-btn {
  opacity: 1;
}

.notification-clear-btn:hover {
  background: #fee2e2;
  color: #ef4444;
}

.notification-actions {
  display: flex;
  gap: 0.5rem;
  margin-top: 0.75rem;
  padding-top: 0.75rem;
  border-top: 1px solid var(--border-color);
}

.notification-action-btn {
  flex: 1;
  padding: 0.5rem;
  border: none;
  border-radius: 6px;
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.notification-action-btn.mark-read {
  background: #dbeafe;
  color: #1d4ed8;
}

.notification-action-btn.mark-read:hover {
  background: #bfdbfe;
}

.notification-action-btn.clear-all {
  background: #fee2e2;
  color: #dc2626;
}

.notification-action-btn.clear-all:hover {
  background: #fecaca;
}

.notification-empty {
  text-align: center;
  padding: 1.5rem;
  color: var(--text-light);
}

.notification-empty-icon {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  opacity: 0.5;
}

.notification-badge-count {
  background: #3b82f6;
  color: white;
  font-size: 0.7rem;
  padding: 0.15rem 0.4rem;
  border-radius: 10px;
  margin-left: 0.5rem;
}

/* Empty State */
.empty-state {
  text-align: center;
  padding: 2rem;
  color: var(--text-light);
}

.empty-state-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
  opacity: 0.5;
}

.empty-state h3 {
  color: var(--text-dark);
  margin-bottom: 0.5rem;
}

/* Quick Links */
.quick-links-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.75rem;
}

.quick-link {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 1rem;
  background: #f8f9fa;
  border-radius: 10px;
  text-decoration: none;
  color: var(--text-dark);
  font-weight: 600;
  font-size: 0.9rem;
  transition: all 0.3s ease;
  border: 2px solid transparent;
}

.quick-link:hover {
  background: white;
  border-color: var(--primary-color);
  color: var(--primary-color);
  transform: translateY(-2px);
}

.quick-link-icon {
  font-size: 1.25rem;
}

/* Games progress badge */
.games-progress {
  background: var(--success-color);
  color: white;
  font-size: 0.7rem;
  font-weight: 700;
  padding: 2px 6px;
  border-radius: 10px;
  margin-left: auto;
}

.games-progress.partial {
  background: var(--warning-color);
}

.games-progress.none {
  background: var(--text-light);
}

/* Favorites Section */
.favorites-row {
  display: flex;
  gap: 0.75rem;
  overflow-x: auto;
  padding-bottom: 0.5rem;
  scrollbar-width: thin;
}

.favorite-chip {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  background: #f8f9fa;
  border-radius: 20px;
  text-decoration: none;
  color: var(--text-dark);
  font-size: 0.9rem;
  font-weight: 500;
  white-space: nowrap;
  transition: all 0.3s ease;
  border: 2px solid transparent;
}

.favorite-chip:hover {
  background: white;
  border-color: var(--primary-color);
  color: var(--primary-color);
}

/* Recent Activity */
.activity-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.activity-item {
  display: flex;
  align-items: flex-start;
  gap: 0.75rem;
  padding: 0.75rem;
  border-radius: 8px;
  transition: background 0.3s ease;
}

.activity-item:hover {
  background: #f8f9fa;
}

.activity-icon {
  font-size: 1.25rem;
  padding-top: 0.125rem;
}

.activity-content {
  flex: 1;
}

.activity-text {
  font-size: 0.9rem;
  color: var(--text-dark);
}

.activity-time {
  font-size: 0.8rem;
  color: var(--text-light);
  margin-top: 0.25rem;
}

/* Not Signed In State */
.not-signed-in {
  min-height: 60vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2rem;
}

.signin-prompt {
  text-align: center;
  max-width: 500px;
}

.signin-prompt-icon {
  font-size: 5rem;
  margin-bottom: 1.5rem;
}

.signin-prompt h2 {
  font-size: 2rem;
  color: var(--text-dark);
  margin-bottom: 1rem;
}

.signin-prompt p {
  color: var(--text-light);
  margin-bottom: 2rem;
  font-size: 1.1rem;
  line-height: 1.6;
}

.signin-buttons {
  display: flex;
  gap: 1rem;
  justify-content: center;
  flex-wrap: wrap;
}

.signin-btn {
  padding: 1rem 2rem;
  border-radius: 12px;
  font-weight: 600;
  font-size: 1rem;
  text-decoration: none;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.signin-btn.primary {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  color: white;
  box-shadow: var(--shadow-md);
}

.signin-btn.primary:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg);
}

.signin-btn.secondary {
  background: white;
  color: var(--primary-color);
  border: 2px solid var(--primary-color);
}

.signin-btn.secondary:hover {
  background: var(--primary-color);
  color: white;
}

/* Weather Widget */
.weather-widget {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
  border-radius: 12px;
}

.weather-icon {
  font-size: 2.5rem;
}

.weather-info {
  flex: 1;
}

.weather-temp {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-dark);
}

.weather-desc {
  font-size: 0.85rem;
  color: var(--text-light);
}

/* Notifications Badge */
.notification-badge {
  background: var(--danger-color);
  color: white;
  font-size: 0.7rem;
  font-weight: 700;
  padding: 2px 6px;
  border-radius: 10px;
  margin-left: 0.25rem;
}

/* Debug Banner */
.debug-banner {
  background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%);
  color: white;
  padding: 0.75rem 1.5rem;
  text-align: center;
  font-weight: 600;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
}

.debug-banner code {
  background: rgba(255,255,255,0.2);
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-family: monospace;
}

/* Mobile Adjustments */
@media (max-width: 768px) {
  .header {
    padding: 1.5rem;
  }
  
  .greeting h1 {
    font-size: 1.5rem;
  }
  
  .header-actions {
    width: 100%;
  }
  
  .header-btn {
    flex: 1;
    justify-content: center;
  }
  
  .dashboard-container {
    padding: 1rem;
  }
  
  .card {
    padding: 1.25rem;
  }
  
  .next-game-content {
    flex-direction: column;
    align-items: stretch;
  }
  
  .game-actions {
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  }
  
  .countdown {
    padding: 0.75rem 1rem;
  }
  
  .quick-links-grid {
    grid-template-columns: 1fr;
  }
  
  .quick-stats {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* Continue Banner - shown when user was redirected to dashboard */
.continue-banner {
  background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
  color: white;
  padding: 0.75rem 1rem;
  margin: -1.5rem -1.5rem 1.5rem -1.5rem;
  border-radius: 12px 12px 0 0;
}

.continue-content {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.continue-text {
  flex: 1;
  font-size: 0.95rem;
}

.continue-text strong {
  font-weight: 600;
}

.continue-btn {
  background: white;
  color: #1e40af;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  text-decoration: none;
  font-weight: 600;
  font-size: 0.9rem;
  transition: all 0.2s ease;
}

.continue-btn:hover {
  background: #f0f9ff;
  transform: translateX(2px);
}

.continue-dismiss {
  background: transparent;
  border: none;
  color: white;
  font-size: 1.25rem;
  cursor: pointer;
  padding: 0.25rem;
  opacity: 0.7;
  line-height: 1;
}

.continue-dismiss:hover {
  opacity: 1;
}

@media (max-width: 480px) {
  .continue-banner {
    margin: -1rem -1rem 1rem -1rem;
    padding: 0.6rem 0.75rem;
  }
  
  .continue-text {
    font-size: 0.85rem;
  }
  
  .continue-btn {
    padding: 0.4rem 0.75rem;
    font-size: 0.8rem;
  }
}

/* App Setup Banner - shown when user has no FCM tokens */
.setup-banner {
  background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
  color: white;
  padding: 1rem 1.5rem;
  margin-bottom: 1.5rem;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
  display: none;
}

.setup-banner.visible {
  display: block;
}

.setup-banner-content {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex-wrap: wrap;
}

.setup-banner-icon {
  font-size: 2rem;
  flex-shrink: 0;
}

.setup-banner-text {
  flex: 1;
  min-width: 200px;
}

.setup-banner-title {
  font-size: 1.1rem;
  font-weight: 700;
  margin-bottom: 0.25rem;
}

.setup-banner-desc {
  font-size: 0.9rem;
  opacity: 0.9;
}

.setup-banner-btn {
  background: white;
  color: #7c3aed;
  padding: 0.6rem 1.25rem;
  border-radius: 8px;
  text-decoration: none;
  font-weight: 700;
  font-size: 0.95rem;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.setup-banner-btn:hover {
  background: #faf5ff;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.setup-banner-dismiss {
  background: rgba(255,255,255,0.2);
  border: none;
  color: white;
  font-size: 1.25rem;
  cursor: pointer;
  padding: 0.25rem 0.5rem;
  border-radius: 6px;
  line-height: 1;
  transition: background 0.2s ease;
}

.setup-banner-dismiss:hover {
  background: rgba(255,255,255,0.3);
}

@media (max-width: 480px) {
  .setup-banner {
    padding: 0.875rem 1rem;
    margin-bottom: 1rem;
  }
  
  .setup-banner-icon {
    font-size: 1.5rem;
  }
  
  .setup-banner-title {
    font-size: 1rem;
  }
  
  .setup-banner-desc {
    font-size: 0.8rem;
  }
  
  .setup-banner-btn {
    padding: 0.5rem 1rem;
    font-size: 0.85rem;
  }
}
</style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="softball-spinner"></div>
  </div>

  <!-- Not Signed In State -->
  <div class="not-signed-in" id="notSignedInState" style="display: none;">
    <div class="signin-prompt">
      <div class="signin-prompt-icon">üè†</div>
      <h2>Your Personal Dashboard</h2>
      <p>Sign in to access your personalized dashboard with upcoming games, RSVP status, your stats, and quick actions tailored just for you.</p>
      <div class="signin-buttons">
        <a href="signin.html" class="signin-btn primary">
          <span>üîê</span> Sign In
        </a>
        <a href="signup.html" class="signin-btn secondary">
          <span>‚ú®</span> Create Account
        </a>
      </div>
    </div>
  </div>

  <!-- Debug Banner (only shown in debug mode) -->
  <div class="debug-banner" id="debugBanner" style="display: none;">
    üîß DEBUG MODE: Viewing dashboard as of <code id="debugDateDisplay"></code>
    <span style="opacity: 0.8;">‚Ä¢ Edit DEBUG_DATE in script to change</span>
  </div>

  <!-- Signed In Content -->
  <div id="signedInContent" style="display: none;">
    <!-- Header -->
    <header class="header">
      <div class="header-content">
        <div class="greeting-section">
          <div class="greeting">
            <h1 id="greetingText">Good morning, Player!</h1>
            <p id="teamContext">Loading your dashboard...</p>
            <div class="time-display" id="timeDisplay"></div>
          </div>
          <div class="header-actions">
            <a href="roster-management.html" class="header-btn primary" id="rsvpHeaderBtn">
              <span>‚úâÔ∏è</span> RSVP to Games
            </a>
            <a href="index.html" class="header-btn secondary">
              <span>üè†</span> Home
            </a>
            <a href="profile.html" class="header-btn secondary">
              <span>üë§</span> My Profile
            </a>
          </div>
        </div>
      </div>
    </header>

    <!-- Dashboard Content -->
    <main class="dashboard-container">
      <!-- App Setup Banner - shown when no FCM tokens -->
      <div class="setup-banner" id="setupBanner">
        <div class="setup-banner-content">
          <div class="setup-banner-icon">üì±</div>
          <div class="setup-banner-text">
            <div class="setup-banner-title">Get Aces Alerts on Your Phone</div>
            <div class="setup-banner-desc">Install the app and enable notifications so you never miss a game update</div>
          </div>
          <a href="profile-setup-guide.html?step=2" class="setup-banner-btn">Set Up Now ‚Üí</a>
          <button class="setup-banner-dismiss" onclick="dismissSetupBanner()" title="Remind me later">‚úï</button>
        </div>
      </div>

      <div class="dashboard-grid">
        
        <!-- Next Game Card (Featured) -->
        <div class="card next-game-card" id="nextGameCard">
          <div class="card-header">
            <h2 class="card-title">
              <span>üéØ</span> Next Game
            </h2>
            <a href="game-preview.html" class="card-action" id="nextGamePreviewLink" style="display: none;">
              Preview ‚Üí
            </a>
          </div>
          <div class="next-game-content" id="nextGameContent">
            <!-- Populated by JavaScript -->
            <div class="empty-state">
              <div class="empty-state-icon">üìÖ</div>
              <h3>No Upcoming Games</h3>
              <p>Check back when the schedule is posted!</p>
            </div>
          </div>
        </div>

        <!-- Quick Stats Card -->
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">
              <span>üìä</span> My Stats
            </h2>
            <a href="player.html" class="card-action" id="viewFullStatsLink" style="display: none;">
              Full Stats ‚Üí
            </a>
          </div>
          <div class="quick-stats" id="quickStats">
            <div class="stat-item">
              <div class="stat-value" id="statAvg">.---</div>
              <div class="stat-label">Batting Avg</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="statHits">--</div>
              <div class="stat-label">Hits</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="statRuns">--</div>
              <div class="stat-label">Runs</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="statGames">--</div>
              <div class="stat-label">Games</div>
            </div>
          </div>
          <div id="noStatsMessage" style="display: none;">
            <div class="empty-state">
              <p>Link your player profile to see your stats!</p>
              <a href="link-player.html" style="color: var(--primary-color); font-weight: 600;">Link Player ‚Üí</a>
            </div>
          </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
          <!-- Action Items -->
          <div class="card" id="actionItemsCard">
            <div class="card-header">
              <h2 class="card-title">
                <span>‚ö°</span> Action Needed
                <span class="notification-badge" id="actionCount" style="display: none;">0</span>
              </h2>
            </div>
            <div class="action-items" id="actionItems">
              <!-- Populated by JavaScript -->
            </div>
          </div>

          <!-- Notification Feed -->
          <div class="card" id="notificationFeedCard">
            <div class="card-header">
              <h2 class="card-title">
                <span>üîî</span> Notifications
                <span class="notification-badge-count" id="unreadNotificationCount" style="display: none;">0</span>
              </h2>
              <a href="profile.html#notifications" class="card-action">
                Settings ‚Üí
              </a>
            </div>
            <div class="notification-feed" id="notificationFeed">
              <!-- Populated by JavaScript -->
            </div>
          </div>

          <!-- Quick Links -->
          <div class="card">
            <div class="card-header">
              <h2 class="card-title">
                <span>üîó</span> Quick Links
              </h2>
            </div>
            <div class="quick-links-grid">
              <a href="current-season.html" class="quick-link" id="currentSeasonLink">
                <span class="quick-link-icon">üçÇ</span> <span id="currentSeasonLabel">Current Season</span>
              </a>
              <a href="#" class="quick-link" id="myTeamLink">
                <span class="quick-link-icon">üèÜ</span> My Team
              </a>
              <a href="trophy-case.html" class="quick-link">
                <span class="quick-link-icon">üèÖ</span> Trophy Case
              </a>
              <a href="weekend-preview.html" class="quick-link">
                <span class="quick-link-icon">üîÆ</span> Weekend Preview
              </a>
              <a href="games.html" class="quick-link">
                <span class="quick-link-icon">üéÆ</span> Daily Games
                <span class="games-progress" id="gamesProgress" style="display: none;"></span>
              </a>
              <a href="pictures.html" class="quick-link">
                <span class="quick-link-icon">üì∑</span> Photo Gallery
              </a>
            </div>
          </div>
        </div>

        <!-- Upcoming Games List -->
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">
              <span>üìÖ</span> Upcoming Games
            </h2>
            <a href="roster-management.html" class="card-action">
              Manage RSVPs ‚Üí
            </a>
          </div>
          <div class="games-list" id="upcomingGamesList">
            <!-- Populated by JavaScript -->
          </div>
        </div>

        <!-- Favorites -->
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">
              <span>‚≠ê</span> My Favorites
            </h2>
            <a href="favorites.html" class="card-action">
              Manage ‚Üí
            </a>
          </div>
          <div id="favoritesContent">
            <h4 style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.75rem;">Teams</h4>
            <div class="favorites-row" id="favoriteTeams">
              <!-- Populated by JavaScript -->
            </div>
            <h4 style="font-size: 0.9rem; color: var(--text-light); margin: 1rem 0 0.75rem;">Players</h4>
            <div class="favorites-row" id="favoritePlayers">
              <!-- Populated by JavaScript -->
            </div>
          </div>
          <div id="noFavoritesMessage" style="display: none;">
            <div class="empty-state">
              <div class="empty-state-icon">‚≠ê</div>
              <h3>No Favorites Yet</h3>
              <p>Add teams and players you want to follow!</p>
              <a href="favorites.html" style="color: var(--primary-color); font-weight: 600;">Add Favorites ‚Üí</a>
            </div>
          </div>
        </div>

        <!-- Captain Section (shown only for captains) -->
        <div class="card" id="captainCard" style="display: none;">
          <div class="card-header">
            <h2 class="card-title">
              <span>üéñÔ∏è</span> Captain Tools
            </h2>
          </div>
          <div class="quick-links-grid">
            <a href="roster-management.html" class="quick-link">
              <span class="quick-link-icon">üìã</span> Manage Roster
            </a>
            <a href="game-tracker.html" class="quick-link">
              <span class="quick-link-icon">üî∂</span> Game Tracker
            </a>
            <a href="submit-stats.html" class="quick-link">
              <span class="quick-link-icon">üßÆ</span> Submit Stats
            </a>
            <a href="submit-score.html" class="quick-link">
              <span class="quick-link-icon">üì¢</span> Submit Score
            </a>
          </div>
          <div id="captainRsvpSummary" style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border-color);">
            <h4 style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.75rem;">Next Game RSVPs</h4>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span style="color: var(--success-color); font-weight: 700;" id="rsvpYesCount">0</span>
                <span style="font-size: 0.85rem; color: var(--text-light);">Yes</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span style="color: var(--warning-color); font-weight: 700;" id="rsvpMaybeCount">0</span>
                <span style="font-size: 0.85rem; color: var(--text-light);">Maybe</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span style="color: var(--danger-color); font-weight: 700;" id="rsvpNoCount">0</span>
                <span style="font-size: 0.85rem; color: var(--text-light);">No</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span style="color: var(--text-light); font-weight: 700;" id="rsvpPendingCount">0</span>
                <span style="font-size: 0.85rem; color: var(--text-light);">Pending</span>
              </div>
            </div>
          </div>
        </div>

      </div>
    </main>
  </div>

  <script type="module">
    import { onAuthChange, getCurrentUser, getUserProfile, isUserCaptain, USER_ROLES } from './firebase-auth.js';
    import { 
      getCurrentSeason, 
      getSeasonPlayerStatsOptimized,
      getAllTeams,
      getSeasonGames,
      db
    } from './firebase-data.js';
    import { getUpcomingTeamGames, getGameRSVPs, updateRSVP } from './firebase-roster.js';
    import { collection, getDocs, query, where, orderBy, limit, doc, updateDoc, deleteDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    let currentUser = null;
    let userProfile = null;
    let currentSeason = null;
    let linkedTeam = null;
    let linkedPlayer = null;
    let upcomingGames = [];
    
    // Captain action tracking
    let gamesNeedingScores = [];
    let gamesNeedingStats = [];
    let isCaptainOrStaff = false;
    
    // Notification tracking
    let notificationUnsubscribe = null;
    let userNotifications = [];

    // ============================================
    // DEBUG MODE - Set to true to test with a fixed date
    // ============================================
    const DEBUG_MODE = false;
    const DEBUG_DATE = new Date('2025-11-02T10:00:00'); // November 2 - late season / playoff time for Fall
    // ============================================

    function getDebugNow() {
      return DEBUG_MODE ? new Date(DEBUG_DATE) : new Date();
    }

    // Helper to capitalize team name
    const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() : '';
    
    // Helper to get default location based on season
    function getDefaultLocation(game) {
      // First check if game has a specific location
      if (game.field || game.location) {
        return game.field || game.location;
      }
      // Default based on season type
      const seasonId = currentSeason?.id?.toLowerCase() || '';
      if (seasonId.includes('fall')) {
        return 'Deerfield School';
      } else if (seasonId.includes('summer')) {
        return 'Field of Dreams';
      }
      return 'TBD';
    }

    // Helper to generate game-preview URL
    // game-preview.html accepts either:
    //   - gameId (for playoff games)
    //   - home, away, date (for regular games)
    function getGamePreviewUrl(game) {
      const isPlayoff = game.gameType?.toLowerCase() === 'playoff';
      
      if (isPlayoff && game.id) {
        // Playoff games use gameId
        return `game-preview.html?gameId=${encodeURIComponent(game.id)}`;
      } else {
        // Regular games use home, away, date
        // Capitalize team names to match game-preview.html expectations
        const homeTeam = capitalize(game.isHome ? (linkedTeam || game.homeTeam) : game.opponent);
        const awayTeam = capitalize(game.isHome ? game.opponent : (linkedTeam || game.awayTeam));
        
        // Format date as M/D/YYYY
        let dateStr = '';
        if (game.date?.seconds) {
          const d = new Date(game.date.seconds * 1000);
          dateStr = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
        } else if (game.date) {
          const d = new Date(game.date);
          dateStr = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
        }
        
        return `game-preview.html?home=${encodeURIComponent(homeTeam)}&away=${encodeURIComponent(awayTeam)}&date=${encodeURIComponent(dateStr)}`;
      }
    }

    console.log('üìä Dashboard loading...');
    if (DEBUG_MODE) {
      console.log('üîß DEBUG MODE ENABLED - Using fixed date:', DEBUG_DATE.toDateString());
      document.getElementById('debugBanner').style.display = 'flex';
      document.getElementById('debugDateDisplay').textContent = DEBUG_DATE.toLocaleDateString('en-US', { 
        weekday: 'long', 
        month: 'long', 
        day: 'numeric', 
        year: 'numeric' 
      });
    }

    // Update time display
    function updateTimeDisplay() {
      const now = getDebugNow();
      const options = { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' };
      let dateText = now.toLocaleDateString('en-US', options);
      if (DEBUG_MODE) {
        dateText += ' (DEBUG)';
      }
      document.getElementById('timeDisplay').textContent = dateText;
    }

    // Get greeting based on time of day
    function getGreeting() {
      const hour = getDebugNow().getHours();
      if (hour < 12) return 'Good morning';
      if (hour < 17) return 'Good afternoon';
      return 'Good evening';
    }

    /**
     * Show "Continue to X" banner if user was redirected from another page
     */
    function showContinueBanner() {
      try {
        const urlParams = new URLSearchParams(window.location.search);
        const continueUrl = urlParams.get('continue');
        
        if (!continueUrl) return;
        
        const decodedUrl = decodeURIComponent(continueUrl);
        
        // Don't show for home page
        if (decodedUrl === '/' || decodedUrl === '/index.html' || decodedUrl === 'index.html') return;
        
        // Get friendly page name
        const pageName = getFriendlyPageName(decodedUrl);
        
        // Create and show the banner
        const banner = document.createElement('div');
        banner.id = 'continueBanner';
        banner.className = 'continue-banner';
        banner.innerHTML = `
          <div class="continue-content">
            <span class="continue-text">‚Ü©Ô∏è Continue to <strong>${pageName}</strong></span>
            <a href="${decodedUrl}" class="continue-btn">Go ‚Üí</a>
            <button class="continue-dismiss" onclick="this.parentElement.parentElement.remove()">√ó</button>
          </div>
        `;
        
        // Insert at top of signed-in content
        const signedInContent = document.getElementById('signedInContent');
        if (signedInContent) {
          signedInContent.insertBefore(banner, signedInContent.firstChild);
        }
        
        // Clean up URL (remove continue param from address bar)
        window.history.replaceState({}, '', window.location.pathname);
        
      } catch (err) {
        console.warn('Continue banner error:', err);
      }
    }

    /**
     * Get a friendly display name for a page URL
     */
    function getFriendlyPageName(url) {
      const path = url.split('?')[0];
      const params = new URLSearchParams(url.includes('?') ? url.split('?')[1] : '');
      
      // Helper to capitalize
      const cap = (s) => s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
      
      const pageNames = {
        'player.html': () => params.get('name') ? `${params.get('name')}'s Page` : 'Player Page',
        'team.html': () => params.get('team') ? `Team ${cap(params.get('team'))}` : 'Team Page',
        'current-season-team.html': () => params.get('team') ? `Team ${cap(params.get('team'))}` : 'Team Page',
        'season.html': () => 'Season Stats',
        'batting.html': () => 'Batting Stats',
        'pitching.html': () => 'Pitching Stats',
        'teams.html': () => 'All Teams',
        'players.html': () => 'All Players',
        'playoffs.html': () => 'Playoff Bracket',
        'projections.html': () => 'Playoff Projections',
        'playoff-clinching.html': () => 'Clinching Scenarios',
        'weekend-preview.html': () => 'Weekend Preview',
        'game-preview.html': () => 'Game Preview',
        'leaders.html': () => 'Career Leaders',
        'milestones.html': () => 'Milestones',
        'compare.html': () => 'Player Comparison',
        'team_compare.html': () => 'Team Comparison',
        'h2h_grid.html': () => 'Head-to-Head',
        'charts.html': () => 'Charts',
        'pictures.html': () => 'Photo Gallery',
        'favorites.html': () => 'Favorites',
        'roster-management.html': () => 'Roster Management',
        'profile.html': () => 'My Profile',
        'aces-directory.html': () => 'Directory',
        'game-tracker.html': () => 'Game Tracker',
        'notifications.html': () => 'Notifications',
        'current-season.html': () => 'Current Season',
        'seasons.html': () => 'All Seasons',
        'awards.html': () => 'Awards',
        'league-rules.html': () => 'League Rules',
        'league-history.html': () => 'League History'
      };
      
      // Find matching page
      for (const [page, getName] of Object.entries(pageNames)) {
        if (path.includes(page)) {
          return getName();
        }
      }
      
      // Fallback: clean up filename
      const filename = path.split('/').pop().replace('.html', '').replace(/-/g, ' ');
      return filename.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ') || 'Previous Page';
    }

    // Calculate days until game
    function getDaysUntil(gameDate) {
      const now = getDebugNow();
      now.setHours(0, 0, 0, 0);
      
      let date;
      if (gameDate?.seconds) {
        date = new Date(gameDate.seconds * 1000);
      } else {
        date = new Date(gameDate);
      }
      date.setHours(0, 0, 0, 0);
      
      const diffTime = date - now;
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      return diffDays;
    }

    // Format date for display
    // Time can come from: 
    //   1) The date field itself (timestamp with time, e.g., "December 7, 2025 at 10:00:00 AM UTC-5")
    //   2) A separate 'time' field (string, e.g., "10:00")
    function formatGameDate(gameDate, gameTimeField = null) {
      let date;
      if (gameDate?.seconds) {
        date = new Date(gameDate.seconds * 1000);
      } else {
        date = new Date(gameDate);
      }
      
      // Determine time display
      let timeDisplay = 'TBD';
      
      // First, check if there's a separate time field (takes priority)
      if (gameTimeField) {
        // Format like "10:00" to "10:00 AM"
        const timeParts = gameTimeField.split(':');
        if (timeParts.length >= 2) {
          let hours = parseInt(timeParts[0], 10);
          const minutes = timeParts[1];
          const ampm = hours >= 12 ? 'PM' : 'AM';
          hours = hours % 12 || 12;
          timeDisplay = `${hours}:${minutes} ${ampm}`;
        } else {
          timeDisplay = gameTimeField; // Use as-is if can't parse
        }
      } else {
        // Fall back to time from the date timestamp
        // Check if the time is midnight (00:00) - likely means no time was set
        const hours = date.getHours();
        const minutes = date.getMinutes();
        if (hours === 0 && minutes === 0) {
          timeDisplay = 'TBD';
        } else {
          timeDisplay = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        }
      }
      
      return {
        day: date.getDate(),
        month: date.toLocaleDateString('en-US', { month: 'short' }),
        weekday: date.toLocaleDateString('en-US', { weekday: 'short' }),
        time: timeDisplay,
        full: date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })
      };
    }

    // Render next game card
    async function renderNextGame(game) {
      const container = document.getElementById('nextGameContent');
      
      if (!game) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìÖ</div>
            <h3>No Upcoming Games</h3>
            <p>Check back when the schedule is posted!</p>
          </div>
        `;
        return;
      }

      const daysUntil = getDaysUntil(game.date);
      const dateInfo = formatGameDate(game.date, game.time);
      const isHome = game.isHome;
      
      // Get user's RSVP status
      let userRsvp = 'pending';
      if (currentUser) {
        try {
          const rsvps = await getGameRSVPs(game.id);
          if (rsvps[currentUser.uid]) {
            userRsvp = rsvps[currentUser.uid].status || 'pending';
            // Store for action items check
            userRsvpStatuses[game.id] = userRsvp;
          }
        } catch (e) {
          console.log('Could not load RSVP status');
        }
      }

      // Update preview link
      const previewLink = document.getElementById('nextGamePreviewLink');
      previewLink.href = getGamePreviewUrl(game);
      previewLink.style.display = 'inline-flex';

      container.innerHTML = `
        <div class="game-matchup">
          <div class="matchup-teams">
            <div class="team-info">
              <div class="team-name">${capitalize(isHome ? linkedTeam : game.opponent)}</div>
              <div class="team-label">${isHome ? 'Home' : 'Away'}</div>
            </div>
            <div class="vs-badge">VS</div>
            <div class="team-info">
              <div class="team-name">${capitalize(isHome ? game.opponent : linkedTeam)}</div>
              <div class="team-label">${isHome ? 'Away' : 'Home'}</div>
            </div>
          </div>
          <div class="game-details">
            <div class="game-detail">
              <span>üìÖ</span> ${dateInfo.full}
            </div>
            <div class="game-detail">
              <span>‚è∞</span> ${dateInfo.time}
            </div>
            <div class="game-detail">
              <span>üìç</span> ${getDefaultLocation(game)}
            </div>
            <div class="game-detail">
              <span>${game.gameType?.toLowerCase() === 'playoff' ? 'üèÜ' : '‚öæ'}</span> ${game.gameType?.toLowerCase() === 'playoff' ? 'Playoff' : 'Regular Season'}
            </div>
          </div>
        </div>
        <div class="game-actions">
          <div class="countdown">
            <div class="countdown-number">${daysUntil}</div>
            <div class="countdown-label">${daysUntil === 1 ? 'day away' : 'days away'}</div>
          </div>
          <div class="rsvp-buttons">
            <button class="rsvp-btn yes ${userRsvp === 'yes' ? 'active' : ''}" data-status="yes" data-game="${game.id}">‚úì Yes</button>
            <button class="rsvp-btn maybe ${userRsvp === 'maybe' ? 'active' : ''}" data-status="maybe" data-game="${game.id}">? Maybe</button>
            <button class="rsvp-btn no ${userRsvp === 'no' ? 'active' : ''}" data-status="no" data-game="${game.id}">‚úó No</button>
          </div>
        </div>
      `;

      // Add RSVP button handlers
      container.querySelectorAll('.rsvp-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const status = e.target.dataset.status;
          const gameId = e.target.dataset.game;
          
          try {
            const result = await updateRSVP(
              gameId,
              currentUser.uid,
              status,
              userProfile?.displayName || currentUser.displayName || 'Unknown',
              linkedTeam
            );
            
            if (result.success) {
              // Update UI
              container.querySelectorAll('.rsvp-btn').forEach(b => b.classList.remove('active'));
              e.target.classList.add('active');
              
              // Refresh upcoming games list
              renderUpcomingGames(upcomingGames);
            }
          } catch (error) {
            console.error('Error updating RSVP:', error);
          }
        });
      });
    }

    // Render upcoming games list
    async function renderUpcomingGames(games) {
      const container = document.getElementById('upcomingGamesList');
      
      if (!games || games.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìÖ</div>
            <h3>No Upcoming Games</h3>
            <p>Check back when the schedule is posted!</p>
          </div>
        `;
        return;
      }

      // Get RSVPs for all games
      const rsvpPromises = games.map(g => getGameRSVPs(g.id));
      const allRsvps = await Promise.all(rsvpPromises);

      // Store user's RSVP status for each game (for action items check)
      games.forEach((game, index) => {
        const rsvps = allRsvps[index] || {};
        const userRsvp = rsvps[currentUser?.uid]?.status;
        if (userRsvp) {
          userRsvpStatuses[game.id] = userRsvp;
        }
      });

      // Skip first game (shown in featured card)
      const gamesToShow = games.slice(1, 6);
      
      if (gamesToShow.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <p style="color: var(--text-light);">Only one game scheduled - shown above!</p>
          </div>
        `;
        return;
      }

      container.innerHTML = gamesToShow.map((game, index) => {
        const dateInfo = formatGameDate(game.date, game.time);
        const rsvps = allRsvps[index + 1] || {};
        const userRsvp = rsvps[currentUser?.uid]?.status || 'pending';
        const isPlayoff = game.gameType?.toLowerCase() === 'playoff';
        const previewUrl = getGamePreviewUrl(game);
        
        return `
          <a href="${previewUrl}" class="game-item">
            <div class="game-date-box">
              <div class="game-date-day">${dateInfo.day}</div>
              <div class="game-date-month">${dateInfo.month}</div>
            </div>
            <div class="game-info">
              <div class="game-opponent">${game.isHome ? 'vs' : '@'} ${capitalize(game.opponent)}</div>
              <div class="game-meta">
                <span>${isPlayoff ? 'üèÜ Playoff' : '‚öæ Regular'}</span>
                <span>${dateInfo.time}</span>
                <span>${getDefaultLocation(game)}</span>
              </div>
            </div>
            <div class="game-rsvp-status ${userRsvp}">${userRsvp === 'pending' ? 'RSVP?' : userRsvp.toUpperCase()}</div>
          </a>
        `;
      }).join('');
    }

    // Store user RSVPs for action items check
    let userRsvpStatuses = {};

    // ========== NOTIFICATION FUNCTIONS ==========
    
    /**
     * Check the user's notification status and return action item if needed
     * Checks both profile settings AND browser permission
     */
    function getNotificationStatus() {
      const result = {
        needsAction: false,
        title: '',
        description: '',
        href: 'profile.html#notifications',
        urgent: false
      };

      // Check if browser supports notifications
      if (!('Notification' in window)) {
        // Browser doesn't support - no action needed (they can't enable anyway)
        return result;
      }

      const profileEnabled = userProfile?.notificationsEnabled === true;
      const browserPermission = Notification.permission;
      const hasTokens = userProfile?.fcmTokens && userProfile.fcmTokens.length > 0;

      // Case 1: Never enabled notifications in profile
      if (!profileEnabled) {
        result.needsAction = true;
        result.title = 'Enable push notifications';
        result.description = 'Get alerts for schedule changes, RSVP reminders & scores';
        result.urgent = false;
        return result;
      }

      // Case 2: Profile enabled but browser denied/not asked
      if (profileEnabled && browserPermission === 'denied') {
        result.needsAction = true;
        result.title = 'Notifications blocked by browser';
        result.description = 'Allow notifications in browser settings to receive alerts';
        result.urgent = true; // Urgent because they WANT notifications but can't get them
        return result;
      }

      // Case 3: Profile enabled but browser not yet asked (shouldn't happen often)
      if (profileEnabled && browserPermission === 'default') {
        result.needsAction = true;
        result.title = 'Complete notification setup';
        result.description = 'Click to finish enabling push notifications';
        result.urgent = true;
        return result;
      }

      // Case 4: Both enabled but no FCM token (rare edge case)
      if (profileEnabled && browserPermission === 'granted' && !hasTokens) {
        result.needsAction = true;
        result.title = 'Refresh notification setup';
        result.description = 'Your notification token needs to be refreshed';
        result.urgent = false;
        return result;
      }

      // All good - no action needed
      return result;
    }

    /**
     * Load and listen to user's notifications from Firestore
     */
    function setupNotificationFeed(userId) {
      const notificationsRef = collection(db, 'users', userId, 'notifications');
      const q = query(notificationsRef, orderBy('createdAt', 'desc'), limit(20));

      // Real-time listener for notifications
      notificationUnsubscribe = onSnapshot(q, (snapshot) => {
        userNotifications = [];
        snapshot.forEach(doc => {
          userNotifications.push({
            id: doc.id,
            ...doc.data()
          });
        });
        renderNotificationFeed();
      }, (error) => {
        console.warn('Error loading notifications:', error);
        renderNotificationFeed(); // Show empty state on error
      });
    }

    /**
     * Render the notification feed UI
     */
    function renderNotificationFeed() {
      const container = document.getElementById('notificationFeed');
      const countBadge = document.getElementById('unreadNotificationCount');
      
      if (!container) return;

      const unreadCount = userNotifications.filter(n => !n.read).length;
      
      // Update badge
      if (unreadCount > 0) {
        countBadge.textContent = unreadCount;
        countBadge.style.display = 'inline';
      } else {
        countBadge.style.display = 'none';
      }

      // Empty state
      if (userNotifications.length === 0) {
        container.innerHTML = `
          <div class="notification-empty">
            <div class="notification-empty-icon">üì≠</div>
            <p>No notifications yet</p>
            <p style="font-size: 0.8rem; margin-top: 0.25rem;">You'll see game reminders, score updates & more here</p>
          </div>
        `;
        return;
      }

      // Render notifications
      container.innerHTML = userNotifications.map(notif => `
        <div class="notification-item ${notif.read ? '' : 'unread'}" data-id="${notif.id}">
          <div class="notification-icon">${getNotificationIcon(notif.type)}</div>
          <div class="notification-content">
            <div class="notification-title">${escapeHtml(notif.title || 'Notification')}</div>
            <div class="notification-body">${escapeHtml(notif.body || '')}</div>
            <div class="notification-time">${formatNotificationTime(notif.createdAt)}</div>
          </div>
          <button class="notification-clear-btn" onclick="clearNotification('${notif.id}')" title="Clear">‚úï</button>
        </div>
      `).join('');

      // Add action buttons if there are notifications
      if (userNotifications.length > 0) {
        container.innerHTML += `
          <div class="notification-actions">
            ${unreadCount > 0 ? `<button class="notification-action-btn mark-read" onclick="markAllNotificationsRead()">Mark all read</button>` : ''}
            <button class="notification-action-btn clear-all" onclick="clearAllNotifications()">Clear all</button>
          </div>
        `;
      }

      // Add click handlers to mark as read
      container.querySelectorAll('.notification-item').forEach(item => {
        item.addEventListener('click', (e) => {
          // Don't trigger if clicking the clear button
          if (e.target.closest('.notification-clear-btn')) return;
          
          const notifId = item.dataset.id;
          const notif = userNotifications.find(n => n.id === notifId);
          
          // Mark as read
          if (notif && !notif.read) {
            markNotificationRead(notifId);
          }
          
          // Navigate if there's a link
          if (notif?.link) {
            window.location.href = notif.link;
          }
        });
      });
    }

    /**
     * Get appropriate icon for notification type
     */
    function getNotificationIcon(type) {
      const icons = {
        'game_reminder': 'üìÖ',
        'rsvp_reminder': '‚úâÔ∏è',
        'score_update': 'üèÜ',
        'schedule_change': 'üîÑ',
        'lineup_change': 'üìã',
        'announcement': 'üì¢',
        'milestone': 'üéâ',
        'team_update': 'üë•'
      };
      return icons[type] || 'üîî';
    }

    /**
     * Format notification timestamp
     */
    function formatNotificationTime(timestamp) {
      if (!timestamp) return '';
      
      const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / (1000 * 60));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    /**
     * Escape HTML to prevent XSS
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Mark a single notification as read
     */
    async function markNotificationRead(notifId) {
      if (!currentUser) return;
      
      try {
        const notifRef = doc(db, 'users', currentUser.uid, 'notifications', notifId);
        await updateDoc(notifRef, { read: true });
      } catch (error) {
        console.error('Error marking notification read:', error);
      }
    }

    // Make functions globally accessible for onclick handlers
    window.clearNotification = async function(notifId) {
      if (!currentUser) return;
      
      try {
        const notifRef = doc(db, 'users', currentUser.uid, 'notifications', notifId);
        await deleteDoc(notifRef);
      } catch (error) {
        console.error('Error clearing notification:', error);
      }
    };

    window.markAllNotificationsRead = async function() {
      if (!currentUser || userNotifications.length === 0) return;
      
      try {
        const unreadNotifs = userNotifications.filter(n => !n.read);
        await Promise.all(unreadNotifs.map(notif => {
          const notifRef = doc(db, 'users', currentUser.uid, 'notifications', notif.id);
          return updateDoc(notifRef, { read: true });
        }));
      } catch (error) {
        console.error('Error marking all as read:', error);
      }
    };

    window.clearAllNotifications = async function() {
      if (!currentUser || userNotifications.length === 0) return;
      
      if (!confirm('Clear all notifications?')) return;
      
      try {
        await Promise.all(userNotifications.map(notif => {
          const notifRef = doc(db, 'users', currentUser.uid, 'notifications', notif.id);
          return deleteDoc(notifRef);
        }));
      } catch (error) {
        console.error('Error clearing all notifications:', error);
      }
    };

    // Render action items
    function renderActionItems() {
      const container = document.getElementById('actionItems');
      const countBadge = document.getElementById('actionCount');
      const actions = [];

      // ========== CAPTAIN/STAFF ACTION ITEMS ==========
      if (isCaptainOrStaff) {
        // Check for games needing scores (highest priority for captains)
        if (gamesNeedingScores.length > 0) {
          actions.push({
            icon: 'üî¢',
            title: 'Submit game scores',
            description: `${gamesNeedingScores.length} game${gamesNeedingScores.length > 1 ? 's' : ''} need final scores`,
            href: 'submit-score.html',
            urgent: true // Always urgent - scores should be submitted promptly
          });
        }
        
        // Check for games needing stats
        if (gamesNeedingStats.length > 0) {
          actions.push({
            icon: 'üìä',
            title: 'Submit game stats',
            description: `${gamesNeedingStats.length} game${gamesNeedingStats.length > 1 ? 's' : ''} need player stats`,
            href: 'submit-stats.html',
            urgent: gamesNeedingStats.length >= 3 // Urgent if 3+ games backlog
          });
        }
      }

      // ========== PLAYER ACTION ITEMS ==========
      // Check for pending RSVPs - only count games where user hasn't responded
      const pendingRsvpGames = upcomingGames.filter(g => {
        const status = userRsvpStatuses[g.id];
        // Pending if no status or status is 'pending' or 'none'
        return !status || status === 'pending' || status === 'none';
      });

      if (pendingRsvpGames.length > 0) {
        actions.push({
          icon: '‚úâÔ∏è',
          title: 'RSVP to upcoming games',
          description: `${pendingRsvpGames.length} game${pendingRsvpGames.length > 1 ? 's' : ''} need your response`,
          href: 'roster-management.html',
          urgent: pendingRsvpGames.some(g => getDaysUntil(g.date) <= 2)
        });
      }

      // Check if player profile is linked
      if (!linkedPlayer) {
        actions.push({
          icon: 'üîó',
          title: 'Link your player profile',
          description: 'Connect your account to see your stats',
          href: 'link-player.html',
          urgent: false
        });
      }

      // Check for profile completion
      if (!userProfile?.displayName) {
        actions.push({
          icon: 'üë§',
          title: 'Complete your profile',
          description: 'Add your display name and photo',
          href: 'profile.html',
          urgent: false
        });
      }

      // ========== NOTIFICATION ACTION ITEMS ==========
      // Check notification status - we want to encourage all users to enable
      const notificationStatus = getNotificationStatus();
      if (notificationStatus.needsAction) {
        actions.push({
          icon: 'üîî',
          title: notificationStatus.title,
          description: notificationStatus.description,
          href: notificationStatus.href,
          urgent: notificationStatus.urgent
        });
      }

      // Update badge
      if (actions.length > 0) {
        countBadge.textContent = actions.length;
        countBadge.style.display = 'inline';
      } else {
        countBadge.style.display = 'none';
      }

      if (actions.length === 0) {
        container.innerHTML = `
          <div class="empty-state" style="padding: 1rem;">
            <p style="color: var(--success-color); font-weight: 600;">‚úì All caught up!</p>
          </div>
        `;
        return;
      }

      container.innerHTML = actions.map(action => `
        <a href="${action.href}" class="action-item ${action.urgent ? 'urgent' : ''}">
          <div class="action-icon">${action.icon}</div>
          <div class="action-content">
            <div class="action-title">${action.title}</div>
            <div class="action-description">${action.description}</div>
          </div>
          <div class="action-arrow">‚Üí</div>
        </a>
      `).join('');
    }

    // Render quick stats
    function renderQuickStats(stats) {
      const statsContainer = document.getElementById('quickStats');
      const noStatsMessage = document.getElementById('noStatsMessage');
      const viewFullLink = document.getElementById('viewFullStatsLink');

      if (!stats || !linkedPlayer) {
        statsContainer.style.display = 'none';
        noStatsMessage.style.display = 'block';
        return;
      }

      statsContainer.style.display = 'grid';
      noStatsMessage.style.display = 'none';
      
      // Link to player page using authenticated user's Firebase UID
      viewFullLink.href = `player.html?id=${currentUser.uid}`;
      viewFullLink.style.display = 'inline-flex';

      // Calculate batting average properly: H / AB
      let avgDisplay = '.---';
      const hits = stats.h ?? stats.hits ?? 0;
      const atBats = stats.ab ?? stats.atBats ?? 0;
      
      if (atBats > 0) {
        const avg = hits / atBats;
        // Format as .XXX (e.g., .333, .250, .400)
        avgDisplay = avg.toFixed(3).replace(/^0/, ''); // Remove leading zero
      }

      document.getElementById('statAvg').textContent = avgDisplay;
      document.getElementById('statHits').textContent = hits || '--';
      document.getElementById('statRuns').textContent = stats.r ?? stats.runs ?? '--';
      document.getElementById('statGames').textContent = stats.g ?? stats.games ?? '--';
    }

    // Render favorites
    function renderFavorites(profile) {
      const teamsContainer = document.getElementById('favoriteTeams');
      const playersContainer = document.getElementById('favoritePlayers');
      const noFavoritesMessage = document.getElementById('noFavoritesMessage');
      const favoritesContent = document.getElementById('favoritesContent');

      const favoriteTeams = profile?.favoriteTeams || [];
      const favoritePlayers = profile?.favoritePlayers || [];

      if (favoriteTeams.length === 0 && favoritePlayers.length === 0) {
        favoritesContent.style.display = 'none';
        noFavoritesMessage.style.display = 'block';
        return;
      }

      favoritesContent.style.display = 'block';
      noFavoritesMessage.style.display = 'none';

      if (favoriteTeams.length > 0) {
        teamsContainer.innerHTML = favoriteTeams.map(team => `
          <a href="team.html?team=${encodeURIComponent(team)}" class="favorite-chip">
            <span>üèÜ</span> ${team}
          </a>
        `).join('');
      } else {
        teamsContainer.innerHTML = '<span style="color: var(--text-light); font-size: 0.9rem;">No favorite teams</span>';
      }

      if (favoritePlayers.length > 0) {
        playersContainer.innerHTML = favoritePlayers.map(player => `
          <a href="player.html?player=${encodeURIComponent(player)}" class="favorite-chip">
            <span>‚≠ê</span> ${player}
          </a>
        `).join('');
      } else {
        playersContainer.innerHTML = '<span style="color: var(--text-light); font-size: 0.9rem;">No favorite players</span>';
      }
    }

    // Check daily games completion progress
    async function checkDailyGamesProgress() {
      if (!currentUser) return;
      
      try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
        const { db } = await import('./firebase-data.js');
        
        // Calculate day number (same logic as games.html)
        const LAUNCH_DATE = '2026-01-06';
        const [launchYear, launchMonth, launchDay] = LAUNCH_DATE.split('-').map(Number);
        const start = new Date(launchYear, launchMonth - 1, launchDay);
        start.setHours(0, 0, 0, 0);
        
        // Use debug date if in debug mode, otherwise use real date
        const now = DEBUG_MODE ? getDebugNow() : new Date();
        now.setHours(0, 0, 0, 0);
        
        const daysSinceLaunch = Math.floor((now - start) / (1000 * 60 * 60 * 24));
        const dayNum = Math.max(1, daysSinceLaunch + 1);
        
        // If we're before the launch date, don't show progress
        if (daysSinceLaunch < 0) {
          console.log('üìÖ Daily games not yet launched');
          return;
        }
        
        // Game configs matching games.html
        const GAME_CONFIGS = {
          grid: {
            collection: 'acesGridGames',
            subcollection: 'puzzles',
            docIdFormat: (d) => `puzzle_${d}`,
            checkCompletion: (data) => data.gameOver === true
          },
          connections: {
            collection: 'acesConnectionsGames',
            subcollection: 'dailyGames',
            docIdFormat: (d) => String(d),
            checkCompletion: (data) => data.isComplete === true || data.gameOver === true
          },
          wordle: {
            collection: 'acesWordleGames',
            subcollection: 'dailyGames',
            docIdFormat: (d) => String(d),
            checkCompletion: (data) => data.gameOver === true
          },
          higherLower: {
            collection: 'acesHigherLowerGames',
            subcollection: 'puzzles',
            docIdFormat: (d) => `puzzle_${d}`,
            checkCompletion: (data) => data.gameOver === true
          },
          whoAmI: {
            collection: 'acesWhoAmIGames',
            subcollection: 'dailyGames',
            docIdFormat: (d) => String(d),
            checkCompletion: (data) => data.gameOver === true
          },
          recall: {
            collection: 'acesRosterRecallGames',
            subcollection: 'dailyGames',
            docIdFormat: (d) => String(d),
            checkCompletion: (data) => data.phase === 'finished'
          }
        };
        
        let completedCount = 0;
        const totalGames = Object.keys(GAME_CONFIGS).length;
        
        for (const [gameKey, config] of Object.entries(GAME_CONFIGS)) {
          try {
            const docId = config.docIdFormat(dayNum);
            const gameRef = doc(db, config.collection, currentUser.uid, config.subcollection, docId);
            const gameDoc = await getDoc(gameRef);
            
            if (gameDoc.exists()) {
              const data = gameDoc.data();
              if (config.checkCompletion(data)) {
                completedCount++;
                continue;
              }
            }
            
            // Fallback: check stats doc
            const statsRef = doc(db, config.collection, currentUser.uid);
            const statsDoc = await getDoc(statsRef);
            
            if (statsDoc.exists()) {
              const stats = statsDoc.data();
              if (stats.lastPlayedPuzzle === dayNum || stats.lastPuzzle === dayNum) {
                completedCount++;
              }
            }
          } catch (e) {
            // Silently continue on errors
          }
        }
        
        // Update the progress badge
        const progressBadge = document.getElementById('gamesProgress');
        if (completedCount > 0) {
          progressBadge.textContent = `${completedCount}/${totalGames}`;
          progressBadge.style.display = 'inline';
          
          if (completedCount === totalGames) {
            progressBadge.className = 'games-progress'; // Full completion - green
          } else {
            progressBadge.className = 'games-progress partial'; // Partial - yellow
          }
        } else {
          // Don't show badge if nothing completed
          progressBadge.style.display = 'none';
        }
        
        console.log(`üéÆ Daily games progress: ${completedCount}/${totalGames} (Day ${dayNum})`);
        
      } catch (error) {
        console.log('Could not check daily games progress:', error);
      }
    }

    // Check for games needing scores (captain/staff action item)
    async function checkGamesNeedingScores() {
      if (!linkedTeam || !currentSeason?.id) return [];
      
      try {
        const now = getDebugNow();
        now.setHours(23, 59, 59, 999); // Include today
        
        // Get all games for the current season
        const allGames = await getSeasonGames(currentSeason.id);
        
        const needsScores = allGames.filter(game => {
          // Check if this game involves the captain's team
          const homeTeam = (game.homeTeamName || game['home team'] || game.homeTeam || '').toLowerCase();
          const awayTeam = (game.awayTeamName || game['away team'] || game.awayTeam || '').toLowerCase();
          const teamLower = linkedTeam.toLowerCase();
          
          if (homeTeam !== teamLower && awayTeam !== teamLower) {
            return false;
          }
          
          // Parse game date
          let gameDate = null;
          if (game.date?.seconds) {
            gameDate = new Date(game.date.seconds * 1000);
          } else if (game.date?.toDate) {
            gameDate = game.date.toDate();
          } else if (game.date) {
            gameDate = new Date(game.date);
          }
          
          // Skip future games
          if (!gameDate || gameDate > now) {
            return false;
          }
          
          // Check if game has a score
          const hasScore = 
            (game.homeScore !== undefined && game.homeScore !== null && game.homeScore !== '') ||
            (game.awayScore !== undefined && game.awayScore !== null && game.awayScore !== '') ||
            (game['home score'] && String(game['home score']).trim() !== '') ||
            (game['away score'] && String(game['away score']).trim() !== '') ||
            (game.winner && game.winner.trim() !== '');
          
          return !hasScore;
        });
        
        console.log(`üéØ Found ${needsScores.length} games needing scores for Team ${linkedTeam}`);
        return needsScores;
        
      } catch (error) {
        console.error('Error checking games needing scores:', error);
        return [];
      }
    }

    // Check for games needing stats (captain/staff action item)
    // This checks if any player stats have been submitted for games involving the team
    async function checkGamesNeedingStats() {
      if (!linkedTeam || !currentSeason?.id) return [];
      
      try {
        const now = getDebugNow();
        now.setHours(23, 59, 59, 999);
        
        // Get all games for the current season
        const allGames = await getSeasonGames(currentSeason.id);
        
        // Filter to past games involving the team that HAVE scores
        const completedTeamGames = allGames.filter(game => {
          const homeTeam = (game.homeTeamName || game['home team'] || game.homeTeam || '').toLowerCase();
          const awayTeam = (game.awayTeamName || game['away team'] || game.awayTeam || '').toLowerCase();
          const teamLower = linkedTeam.toLowerCase();
          
          if (homeTeam !== teamLower && awayTeam !== teamLower) {
            return false;
          }
          
          // Parse game date
          let gameDate = null;
          if (game.date?.seconds) {
            gameDate = new Date(game.date.seconds * 1000);
          } else if (game.date?.toDate) {
            gameDate = game.date.toDate();
          } else if (game.date) {
            gameDate = new Date(game.date);
          }
          
          // Skip future games
          if (!gameDate || gameDate > now) {
            return false;
          }
          
          // Only check games that have scores (completed games)
          const hasScore = 
            (game.homeScore !== undefined && game.homeScore !== null && game.homeScore !== '') ||
            (game.awayScore !== undefined && game.awayScore !== null && game.awayScore !== '') ||
            (game['home score'] && String(game['home score']).trim() !== '') ||
            (game['away score'] && String(game['away score']).trim() !== '') ||
            (game.winner && game.winner.trim() !== '');
          
          return hasScore;
        });
        
        // For each completed game, check if stats have been submitted
        // Stats are stored in playerStats/{legacyId}/games/{seasonId}_{gameId}
        // We'll check if ANY stats exist for the game by querying
        const gamesWithoutStats = [];
        
        for (const game of completedTeamGames) {
          try {
            // Build the expected game doc ID pattern
            // Games use format like "10_12_2025_white_vs_blue"
            const gameId = game.id;
            const seasonGameId = `${currentSeason.id}_${gameId}`;
            
            // Check if the game has statsSubmitted flag (if we add this later)
            // For now, we'll check if there's at least one playerStats entry for this game
            // This is expensive, so we use a simple heuristic: check the game's statsSubmitted field
            if (game.statsSubmitted === true) {
              continue; // Stats already submitted
            }
            
            // If no explicit flag, we assume stats are needed for recent games
            // In production, you'd query playerStats collection
            gamesWithoutStats.push(game);
            
          } catch (e) {
            // If we can't determine, assume needs stats
            gamesWithoutStats.push(game);
          }
        }
        
        console.log(`üìä Found ${gamesWithoutStats.length} games needing stats for Team ${linkedTeam}`);
        return gamesWithoutStats;
        
      } catch (error) {
        console.error('Error checking games needing stats:', error);
        return [];
      }
    }

    // Check if user is captain or team staff
    function checkCaptainOrStaffRole() {
      if (!userProfile) return false;
      
      const userRole = userProfile.userRole;
      
      // Check global roles
      if (userRole === USER_ROLES.ADMIN || 
          userRole === USER_ROLES.LEAGUE_STAFF ||
          userRole === USER_ROLES.CAPTAIN ||
          userRole === USER_ROLES.TEAM_STAFF) {
        return true;
      }
      
      // Check team-specific roles
      if (userProfile.teamRoles && linkedTeam) {
        const teamRole = userProfile.teamRoles[linkedTeam] || 
                         userProfile.teamRoles[linkedTeam.toLowerCase()] ||
                         userProfile.teamRoles[capitalize(linkedTeam)];
        if (teamRole?.status === 'active' && 
            (teamRole.role === USER_ROLES.CAPTAIN || teamRole.role === USER_ROLES.TEAM_STAFF)) {
          return true;
        }
      }
      
      // Legacy captain flag
      if (userProfile.isCaptain === true) {
        return true;
      }
      
      return false;
    }

    // Setup captain features
    async function setupCaptainFeatures() {
      const isCaptain = await isUserCaptain();
      const captainCard = document.getElementById('captainCard');

      if (isCaptain) {
        captainCard.style.display = 'block';
        
        // Get RSVP counts for next game
        if (upcomingGames.length > 0) {
          const nextGame = upcomingGames[0];
          const rsvps = await getGameRSVPs(nextGame.id);
          
          let yes = 0, maybe = 0, no = 0, pending = 0;
          Object.values(rsvps).forEach(r => {
            switch(r.status) {
              case 'yes': yes++; break;
              case 'maybe': maybe++; break;
              case 'no': no++; break;
              default: pending++;
            }
          });

          document.getElementById('rsvpYesCount').textContent = yes;
          document.getElementById('rsvpMaybeCount').textContent = maybe;
          document.getElementById('rsvpNoCount').textContent = no;
          document.getElementById('rsvpPendingCount').textContent = pending;
        }
      }
    }

    // Main initialization
    async function initDashboard(user) {
      try {
        currentUser = user;
        
        // Mark dashboard as visited today (for daily check-in redirect)
        const today = new Date().toLocaleDateString('en-CA'); // Local date YYYY-MM-DD
        localStorage.setItem('lastDashboardVisit', today);
        
        // Check if user was redirected here - show continue banner
        showContinueBanner();
        
        // Get user profile
        const profileResult = await getUserProfile(user.uid);
        userProfile = profileResult.success ? profileResult.data : {};
        
        // Get current season
        currentSeason = await getCurrentSeason();
        
        // Extract linked info
        linkedTeam = userProfile?.linkedTeam || userProfile?.team || null;
        linkedPlayer = userProfile?.linkedPlayer || null;

        // Update greeting
        const displayName = userProfile?.displayName || user.displayName || 'Player';
        const firstName = displayName.split(' ')[0];
        document.getElementById('greetingText').textContent = `${getGreeting()}, ${firstName}!`;
        
        // Update team context with actual season name (e.g., "2025 Fall")
        const seasonDisplayName = currentSeason ? `${currentSeason.year} ${capitalize(currentSeason.season || '')}` : 'Current Season';
        if (linkedTeam) {
          document.getElementById('teamContext').textContent = `Team ${capitalize(linkedTeam)} ‚Ä¢ ${seasonDisplayName}`;
        } else {
          document.getElementById('teamContext').textContent = seasonDisplayName || 'Welcome to Mountainside Aces';
        }

        // Update time display
        updateTimeDisplay();

        // Set My Team quick link with team parameter
        const myTeamLink = document.getElementById('myTeamLink');
        if (linkedTeam) {
          myTeamLink.href = `current-season-team.html?team=${encodeURIComponent(linkedTeam)}`;
        } else {
          myTeamLink.href = 'current-season.html'; // Fallback if no team linked
        }

        // Update Current Season link label with actual season name (e.g., "2025 Fall")
        if (currentSeason) {
          const seasonLabel = document.getElementById('currentSeasonLabel');
          const seasonIcon = currentSeason.season?.toLowerCase() === 'fall' ? 'üçÇ' : '‚òÄÔ∏è';
          const seasonName = `${currentSeason.year} ${capitalize(currentSeason.season || '')}`;
          seasonLabel.textContent = seasonName;
          
          // Update the icon too
          const currentSeasonLink = document.getElementById('currentSeasonLink');
          currentSeasonLink.querySelector('.quick-link-icon').textContent = seasonIcon;
        }

        // Check daily games completion
        await checkDailyGamesProgress();

        // Load upcoming games if team is linked
        if (linkedTeam && currentSeason?.id) {
          let allGames = await getUpcomingTeamGames(linkedTeam, currentSeason.id);
          
          // In debug mode, filter games relative to DEBUG_DATE instead of today
          if (DEBUG_MODE) {
            const debugNow = getDebugNow();
            debugNow.setHours(0, 0, 0, 0);
            
            // Get ALL team games for the season (since getUpcomingTeamGames filters by real today)
            // We need to re-fetch without the date filter
            try {
              const { collection, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
              const { db } = await import('./firebase-data.js');
              
              const gamesRef = collection(db, 'seasons', currentSeason.id, 'games');
              const allGamesSnap = await getDocs(gamesRef);
              
              const teamIdLower = linkedTeam.toLowerCase();
              allGames = [];
              
              allGamesSnap.forEach(doc => {
                const data = doc.data();
                const homeTeamValue = data.homeTeamId || data.homeTeamName || data.homeTeam || data['home team'] || '';
                const awayTeamValue = data.awayTeamId || data.awayTeamName || data.awayTeam || data['away team'] || '';
                
                const homeTeamMatch = homeTeamValue.toLowerCase() === teamIdLower;
                const awayTeamMatch = awayTeamValue.toLowerCase() === teamIdLower;
                
                if (!homeTeamMatch && !awayTeamMatch) return;
                
                // Parse game date
                let gameDate;
                if (data.date?.seconds) {
                  gameDate = new Date(data.date.seconds * 1000);
                } else if (data.date) {
                  gameDate = new Date(data.date);
                } else {
                  return;
                }
                
                const gameDateCompare = new Date(gameDate);
                gameDateCompare.setHours(0, 0, 0, 0);
                
                // Include games from DEBUG_DATE forward
                if (gameDateCompare >= debugNow) {
                  const opponent = homeTeamMatch ? awayTeamValue : homeTeamValue;
                  const gameType = data.game_type || data.gameType || 'Regular';
                  
                  allGames.push({
                    id: doc.id,
                    ...data,
                    homeTeam: homeTeamValue,
                    awayTeam: awayTeamValue,
                    gameType: gameType,
                    isHome: homeTeamMatch,
                    opponent: opponent
                  });
                }
              });
              
              // Sort by date
              allGames.sort((a, b) => {
                const dateA = a.date?.seconds || new Date(a.date).getTime() / 1000 || 0;
                const dateB = b.date?.seconds || new Date(b.date).getTime() / 1000 || 0;
                return dateA - dateB;
              });
              
              console.log(`üîß DEBUG: Found ${allGames.length} games from ${debugNow.toDateString()} forward`);
            } catch (e) {
              console.error('Debug mode game fetch error:', e);
            }
          }
          
          upcomingGames = allGames;
          console.log(`üìÖ Loaded ${upcomingGames.length} upcoming games`);
          
          // Render next game
          await renderNextGame(upcomingGames[0]);
          
          // Render upcoming games list
          await renderUpcomingGames(upcomingGames);
        } else {
          renderNextGame(null);
          renderUpcomingGames([]);
        }

        // Load player stats if linked
        if (linkedPlayer && currentSeason?.id) {
          try {
            const seasonStats = await getSeasonPlayerStatsOptimized(currentSeason.id);
            const playerStats = seasonStats.find(p => 
              p.name?.toLowerCase() === linkedPlayer.toLowerCase() ||
              p.player?.toLowerCase() === linkedPlayer.toLowerCase()
            );
            renderQuickStats(playerStats);
          } catch (e) {
            console.log('Could not load player stats');
            renderQuickStats(null);
          }
        } else {
          renderQuickStats(null);
        }

        // Check if user is captain/staff and load their action items
        isCaptainOrStaff = checkCaptainOrStaffRole();
        if (isCaptainOrStaff) {
          console.log('üéñÔ∏è User is captain/staff - checking for pending scores and stats...');
          // Load games needing scores and stats in parallel
          [gamesNeedingScores, gamesNeedingStats] = await Promise.all([
            checkGamesNeedingScores(),
            checkGamesNeedingStats()
          ]);
        }

        // Render action items (includes captain items if applicable)
        renderActionItems();

        // Setup notification feed (real-time listener)
        setupNotificationFeed(user.uid);

        // Render favorites
        renderFavorites(userProfile);

        // Setup captain features
        await setupCaptainFeatures();

        // Check if we should show app setup banner (no FCM tokens)
        checkSetupBanner(userProfile);

        // Hide loading, show content
        document.getElementById('loadingOverlay').classList.add('hidden');
        document.getElementById('signedInContent').style.display = 'block';

      } catch (error) {
        console.error('‚ùå Error initializing dashboard:', error);
        document.getElementById('loadingOverlay').classList.add('hidden');
        document.getElementById('signedInContent').style.display = 'block';
      }
    }

    // Auth state listener
    onAuthChange(async (user) => {
      console.log('üîê Auth state:', user ? user.email : 'Not signed in');
      
      if (user) {
        await initDashboard(user);
      } else {
        // Cleanup notification listener if exists
        if (notificationUnsubscribe) {
          notificationUnsubscribe();
          notificationUnsubscribe = null;
        }
        
        document.getElementById('loadingOverlay').classList.add('hidden');
        document.getElementById('notSignedInState').style.display = 'flex';
        document.getElementById('signedInContent').style.display = 'none';
      }
    });

    // Update time every minute
    setInterval(updateTimeDisplay, 60000);

    // ========================================
    // APP SETUP BANNER FUNCTIONS
    // ========================================
    
    /**
     * Check if we should show the app setup banner
     * Shows if: no FCM tokens AND not snoozed in last 24 hours
     */
    function checkSetupBanner(profile) {
      const banner = document.getElementById('setupBanner');
      if (!banner) return;
      
      // Debug logging
      console.log('üì± Setup banner check:', {
        hasFcmTokens: profile?.fcmTokens,
        tokenCount: profile?.fcmTokens?.length || 0,
        notificationsEnabled: profile?.notificationsEnabled
      });
      
      // Check if user has FCM tokens
      const hasFCMTokens = profile?.fcmTokens && Array.isArray(profile.fcmTokens) && profile.fcmTokens.length > 0;
      
      if (hasFCMTokens) {
        // User already has notifications set up
        console.log('üì± User has FCM tokens - hiding banner');
        banner.classList.remove('visible');
        return;
      }
      
      // Check if banner was snoozed
      const snoozeKey = 'setupBannerSnoozedUntil';
      const snoozedUntil = localStorage.getItem(snoozeKey);
      
      if (snoozedUntil) {
        const snoozeTime = parseInt(snoozedUntil, 10);
        if (Date.now() < snoozeTime) {
          // Still in snooze period
          console.log('üì± Setup banner snoozed until', new Date(snoozeTime).toLocaleString());
          banner.classList.remove('visible');
          return;
        }
      }
      
      // Show the banner
      console.log('üì± Showing app setup banner (no FCM tokens)');
      banner.classList.add('visible');
    }
    
    /**
     * Dismiss the setup banner for 24 hours
     */
    window.dismissSetupBanner = function() {
      const banner = document.getElementById('setupBanner');
      if (banner) {
        banner.classList.remove('visible');
      }
      
      // Snooze for 24 hours
      const snoozeKey = 'setupBannerSnoozedUntil';
      const snoozeUntil = Date.now() + (24 * 60 * 60 * 1000); // 24 hours from now
      localStorage.setItem(snoozeKey, snoozeUntil.toString());
      
      console.log('üì± Setup banner snoozed for 24 hours');
    }
  </script>
  <script type="module">
    import { NavigationComponent } from './nav-component.js';
    // Navigation auto-initializes on load!
  </script>
  <script src="mobile-enhancements.js"></script>
  <script src="theme-toggle.js"></script>
  </body>
  </html>
